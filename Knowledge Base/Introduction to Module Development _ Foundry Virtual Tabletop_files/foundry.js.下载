
/**
 * Once the Window has loaded
 */
window.addEventListener("DOMContentLoaded", async function() {

  /**
   * Bound a number between some minimum and maximum value, inclusively.
   * @memberof Math
   * @param {number} num    The current value
   * @param {number} min    The minimum allowed value
   * @param {number} max    The maximum allowed value
   * @return {number}       The clamped number
   */
  Math.clamped = function(num, min, max) {
    return Math.min(max, Math.max(num, min));
  };

  // Display notifications
  displayNotifications();

  // Handle multiple header dropdowns
  const header = document.getElementById("main-header");
  for (const dropdownToggle of header.getElementsByClassName("dropdown-trigger")) {
    dropdownToggle.addEventListener("change", _closeOtherDropdowns);
  }

  // Highlight code blocks
  if ( "hljs" in window ) hljs.highlightAll();

  // Handle Privacy Policy acceptance
  handleSubmitPrivacyPolicyForm();

  // Shuffle Hosting Partners
  shuffleHostingPartners();

  // Populate bug report form
  if ( document.body.classList.contains("contact-us") ) populateBugReportForm();

  // Handle scrolling anchors
  document.body.querySelectorAll("a.scrollto").forEach(el => el.addEventListener("click", _onScrollTo));

  // Activate Collapsible Sections
  activateCollapsibleSections();

  // Activate Licenses page
  activateLicensesPage();

  // Handle OAuth login page
  activateOAuthLogin();

  // Add copy to clipboard widget functionality
  const copyInputs = document.getElementsByClassName("copy-input");
  for (const copyInput of copyInputs) {
    copyInput.addEventListener("click", _copyToClipboard)
  }
}, {once: true, passive: true});


// ----------------------------------------------------------


function displayNotifications() {
  const notifications = document.querySelectorAll(".notification");
  for ( let n of notifications ) {
    if ( n.classList.contains("permanent") ) continue;
    setTimeout(() => n.parentElement.removeChild(n), 4000);
  }
}


// ----------------------------------------------------------


function addNotification(type, message, {duration=5000, permanent=false, parentElement=undefined}={}) {
  const container = parentElement ? document.getElementById(parentElement) : document.getElementById("banner-messages");
  const notification = document.createElement("p");
  notification.classList.add("notification", type);
  notification.innerHTML = message;
  container.appendChild(notification);
  return new Promise(resolve => {
    if ( permanent ) return resolve();
    setTimeout(() => {
      notification.remove();
      resolve();
    }, duration);
  })
}

// ----------------------------------------------------------

function clearNotifications() {
  const notifications = document.querySelectorAll(".notification");
  for ( let n of notifications ) {
    n.remove();
  }
}

// ----------------------------------------------------------


async function fadeOut(element, ms) {
  element.style.opacity = 0;
  element.style.setProperty("transition", "opacity " + ms + "ms");
  await new Promise(resolve => window.setTimeout(resolve, ms));
  element.style.display = 'none';
  element.style.opacity = 1;
  return element;
}


// ----------------------------------------------------------

/**
 * Display progress of some major operation like loading data.
 * @param {string} label      A text label to display
 * @param {number} pct        A percentage of progress between 0 and 100
 */
function displayProgressBar({label, pct}={}) {
  const loader = document.getElementById("loading");

  // Complete loading
  if ( pct === 100 ) {
    if ( !loader.hidden ) fadeOut(loader, 2000);
    return;
  }

  // Continue loading
  pct = Math.round(Math.clamped(pct, 0, 100));
  loader.querySelector("#context").textContent = label;
  loader.querySelector("#loading-bar").style.width = `${pct}%`;
  loader.querySelector("#progress").textContent = `${pct}%`;
  loader.style.display = "block";
}

// ----------------------------------------------------------


function createEditor(elementId, options) {

  // Get the target element and form
  const textarea = document.getElementById(elementId);
  const isRequired = textarea.required;
  const form = textarea.form;

  // Add form handler in editor initialization
  options.init_instance_callback = editor => {
    form.onsubmit = event => {
      const content = editor.save();
      if ( isRequired && (content === "") ) {
        event.preventDefault();
        return false;
      }
    };
  };

  // Activate the editor
  options.target = textarea;
  textarea.required = false;
  tinyMCE.init(options);
}


// ----------------------------------------------------------

/**
 * Shuffle the displayed order of hosting partners on the article/partnerships page
 */
function shuffleHostingPartners() {
  if ( !/article\/partnerships/.test(window.location.href) ) return;
  const partners = Array.from(document.querySelectorAll(".hosting-provider"));
  partners.sort((a, b) => Math.random() - 0.5);
  const insertBefore = document.getElementById("content");
  for (const partner of partners) {
    insertBefore.before(partner);
  }
}

// ----------------------------------------------------------

/**
 * Update the displayed state of a form button with a new icon and/or button text.
 * @param {HTMLButtonElement} button          The button to update
 * @param {object} [options={}]               Button update options
 * @param {boolean} [options.disabled]        A new disabled state
 * @param {string} [options.iconClass]        A new icon class
 * @param {string} [options.text]             New button text
 */
function _updateButton(button, {disabled, iconClass, text}={}) {

  // Update disabled state
  if ( disabled !== undefined ) button.disabled = disabled;

  // Update the Font-Awesome icon
  if ( iconClass ) {
    const i = button.querySelector("i");
    i.className = iconClass;
  }

  // Update button text
  if ( text !== undefined ) {
    const l = button.querySelector("label");
    l.innerText = text;
  }
}

// ----------------------------------------------------------


/**
 * Update the software download URL when the platform or version select inputs change
 */
function updateDownloadURL(event) {
  event.preventDefault();
  const form = event.currentTarget.form;
  const {platform, build} = form;

  // Conditionally disable certain options
  if ( platform.value ) {
    const selected = platform.selectedOptions[0];
    const minGeneration = Number(selected.dataset.generation ?? 0);
    const minBuild = Number(selected.dataset.build ?? 0);
    for ( const opt of build.options ) {
      if ( !opt.value ) continue;
      const g = Number(opt.dataset.generation ?? 0);
      const b = Number(opt.value);
      opt.disabled = (g < minGeneration) || (b < minBuild);
      if ( opt.selected && opt.disabled ) build.value = ""; // Reset to unselected
    }
  }
  if ( build.value ) {
    const selected = build.selectedOptions[0];
    const g = Number(selected.dataset.generation ?? 0);
    const b = Number(selected.value || 0);
    for ( const opt of platform.options ) {
      if ( !opt.value ) continue;
      const minGeneration = Number(opt.dataset.generation);
      const minBuild = Number(opt.build);
      opt.disabled = (g < minGeneration) || (b < minBuild);
      if ( opt.selected && opt.disabled ) platform.value = ""; // Reset to unselected
    }
  }

  // Determine whether download is possible
  const hasTimeout = document.body.querySelector("#seconds-remaining")?.value;
  const canDownload = platform.value && build.value && !hasTimeout;

  // Update download link URL
  const download = document.querySelector('#download-software');
  download.href = canDownload ? `/releases/download?build=${build.value}&platform=${platform.value}` : "";
  download.toggleAttribute("disabled", !canDownload);

  // Updated timed download link
  const timed = document.querySelector("#timed-link");
  timed.toggleAttribute("disabled", !canDownload);
}

// ----------------------------------------------------------


function activateLicensesPage() {
  if ( !/licenses/.test(window.location.href) ) return;

  // Disable download buttons for a while when file is being downloaded
  const downloadSoftware = document.body.querySelector("#download-software");
  if ( downloadSoftware ) downloadSoftware.addEventListener("click", disableDownloadButtonsForTimeout);

  // Grab the timeout if it exists, and if so, timeout the buttons
  const secondsRemaining = document.body.querySelector("#seconds-remaining");
  if ( secondsRemaining ) disableDownloadButtonsForTimeout(secondsRemaining.value);

  // Handle license name changes
  const forms = document.body.querySelectorAll("form.license-name");
  for ( const form of forms ) form.addEventListener("submit", _onSubmitLicenseNameForm);
}

// ----------------------------------------------------------

/**
 * Special handling used on the OAuth authorization view.
 */
function activateOAuthLogin() {
  const allowBtn  = document.querySelector("button#oauth-submit");
  if ( !allowBtn ) return;
  const authForm = allowBtn.form;
  authForm.addEventListener("submit", (event) => {
    // Disable buttons
    for ( const button of authForm.querySelectorAll("button") ) {
      if ( button === event.submitter ) _updateButton(allowBtn, {disabled: true, iconClass: "fas fa-spinner fa-spin"});
      else _updateButton(button, {disabled: true});
    }
    // Enable hidden input
    const input = authForm.querySelector(event.submitter.name === "allow" ? "#oauth-allow" : "#oauth-cancel");
    input.disabled = false;
  });
}

// ----------------------------------------------------------

function disableDownloadButtonsForTimeout(timeout=1) {
  // Disable the buttons for a duration
  const buttons = document.querySelectorAll('.software-download > .button');
  const parent = buttons[0].parentElement;
  for ( const button of buttons ) {
    button.setAttribute('disabled', '');
    parent.setAttribute('disabled', '');
    parent.title = `Slow down! You have downloaded the software too many times and must wait ${timeout} seconds before trying again.`;

    // Update the title to indicate remaining time every second
    const interval = setInterval(() => {
      timeout--;
      parent.title = `Slow down! You have downloaded the software too many times and must wait ${timeout} seconds before trying again.`;
    }, 1000);

    // Set timeout to re-enable the buttons
    setTimeout(() => {
      clearInterval(interval);
      button.removeAttribute('disabled');
      parent.removeAttribute('disabled');
      parent.title = "";
    }, timeout * 1000);
  }
}

// ----------------------------------------------------------

/**
 * Obtain a time-limited download link URL for the Foundry software
 */
async function getTimedDownloadLink(event) {
  event.preventDefault();
  const buildSelect = document.querySelector('select[name="build"]');
  const buildTitle = buildSelect.options[buildSelect.selectedIndex].textContent;
  const platformSelect = document.querySelector('select[name="platform"]');
  const platformTitle = platformSelect.options[platformSelect.selectedIndex].textContent

  // Request the download link
  const href = document.querySelector('#download-software').href;
  const response = await fetch(href+"&response_type=json", { method: 'GET' });
  const responseJson = await response.json();
  if ( !response.ok ) {
    disableDownloadButtonsForTimeout(responseJson.secondsRemaining);
    return addNotification("error", "Could not obtain download link - " + responseJson.error);
  }

  // Disable the buttons briefly
  disableDownloadButtonsForTimeout(0.5);

  // Copy the URL to clipboard
  navigator.clipboard.writeText(responseJson.url).then(function() {
    addNotification("info", `Temporary download link for ${platformTitle} ${buildTitle} copied to clipboard, this link is valid for ${responseJson.lifetime} seconds.`);
  }, function(err) {
    addNotification("error", `Unable to obtain temporary download link and copy to clipboard.`);
  });
}

// ----------------------------------------------------------

/**
 * Obtain cookie data from the browser
 * @param {string} name     The cookie name
 * @returns {string|null}   The value of the retrieved cookie
 */
function _getCookie(name) {
  let cookieValue = null;
  if ( document.cookie && document.cookie !== '' ) {
    const cookies = document.cookie.split(';');
    for ( let i = 0; i < cookies.length; i++ ) {
      const cookie = cookies[i].trim();
      // Does this cookie string begin with the name we want?
      if ( cookie.substring(0, name.length + 1) === (name + '=') ) {
        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
        break;
      }
    }
  }
  return cookieValue;
}

// ----------------------------------------------------------

/**
 * Define reusable logic which is used when the process fails
 * @private
 */
function _fail(notificationReason, notificationOptions) {
  if ( notificationReason ) addNotification("error", notificationReason, notificationOptions);
}

// ----------------------------------------------------------

/**
 * Handle edits to individual license names on the user profile licenses component.
 * @param {SubmitEvent} event
 */
async function _onSubmitLicenseNameForm(event) {
  event.preventDefault();
  const l = event.currentTarget.closest(".license");
  const form = event.currentTarget.closest("form");
  const isActive = l.classList.contains("active");
  const input = form.name;
  const value = form.querySelector("span.value");
  const button = form.querySelector("button");

  // Activate the form
  if ( !isActive ) {
    value.toggleAttribute("hidden", true);
    input.toggleAttribute("hidden", false);
    l.classList.add("active");
    button.className = "icon fa-solid fa-save";
    return;
  }

  // Process form data
  const name = input.value.trim();
  l.classList.remove("active");
  value.textContent = input.value = input.placeholder = name;
  button.className = "icon fa-solid fa-edit";
  input.toggleAttribute("hidden", true);
  value.toggleAttribute("hidden", false);

  // Submit the update form
  const response = await fetch("licenses/_rename", {
    method: "POST",
    body: `{"key": "${l.dataset.key}", "name": "${name}"}`,
    headers: {"X-CSRFToken": _getCookie("csrftoken"), "Content-Type": "application/json"}
  });
  if (!response.ok) {
    const failureText = (await response.text()) || response.statusText;
    return _fail(failureText, {permanent: true, parentElement: l.id});
  }
}

// ----------------------------------------------------------


/**
 * Handle page loads which include a recaptcha attempt
 */
function onRecaptchaLoad() {
  const client = grecaptcha.render("recaptcha-badge", {
    sitekey: RECAPTCHA_PUBLIC_KEY,
    badge: 'inline',
    size: 'invisible'
  });
  grecaptcha.ready(() => {
    grecaptcha.execute(client, {action: 'login'}).then(token => {
      document.getElementById('recaptcha').value = token;
    });
  });
}


// ----------------------------------------------------------


function populateBugReportForm() {
  async function populateBugTemplate() {
    if (tinyMCE.activeEditor.getContent() !== '') return;
    const template = await fetch("/static/data/bug.html");
    const content = await template.text();
    tinyMCE.activeEditor.setContent(content);
  }

  const select = document.getElementById("id_category");
  select.onchange = async ev => {
    if ( ev.target.value === "bug" ) {
      await populateBugTemplate();
    }
  };

  // First load template initialization
  window.onload = () => {
    if ( select.value == "bug" ) {
      populateBugTemplate();
    }
  }
}

// ----------------------------------------------------------


function handleSubmitPrivacyPolicyForm() {
  const form = document.getElementById("privacy-policy-prompt");
  if ( !form ) return;
  const buttons = form.querySelectorAll("button");

  // Track which button was clicked
  buttons.forEach(b => {
    b.onclick = ev => b.setAttribute("clicked", "");
  });

  // Submit the form
  form.onsubmit = async event => {
    event.preventDefault();
    form.disabled = true;
    const fd = new FormData(form);
    const clicked = form.querySelector("[clicked]");
    fd.set(clicked.name, clicked.name);
    const response = await fetch(form.action, {
      method: "POST",
      body: fd
    });
    form.parentElement.removeChild(form);
    if ( clicked.name === "agree" ) {
      addNotification("info", "Thank you for agreeing to our Privacy Policy, you may now browse the website.")
    }
  }
}

// ----------------------------------------------------------


/**
 * Smoothly scroll to the top of the page
 * @param {string} selector     A css selector to scroll to
 * @param {number} duration     Animation duration in milliseconds
 * @param {number} padding      A percentage of the window height which is used as padding above the scroll position
 */
function scrollToElement(selector, duration, padding=0.2) {

  // Get the element location
  const targetElement = selector instanceof HTMLElement ? selector : document.body.querySelector(selector);
  if ( !targetElement ) return;

  // Get the scroll target
  const scrollTarget = Math.max(targetElement.offsetTop - (window.innerHeight * padding), 0);

  // Already there
  let current = document.scrollingElement.scrollTop;
  if (current === scrollTarget) return;

  // Animation function
  let ease = 0;
  let t0 = null;
  function step(t1) {
    if ( t0 !== null ) {
      const stop = (Math.PI/2);
      ease += stop * ((t1 - t0)/duration);
      if (ease >= stop) return document.scrollingElement.scrollTop = scrollTarget;
      const r = Math.cos(ease);
      document.scrollingElement.scrollTop = (current * r) + (scrollTarget * (1-r));
    }
    t0 = t1;
    window.requestAnimationFrame(step);
  }
  window.requestAnimationFrame(step);
}

function _onScrollTo(event) {
  event.preventDefault();
  const a = event.currentTarget;
  const selector = a.getAttribute("href");
  return scrollToElement(selector, 500);
}

// ----------------------------------------------------------

/**
 * Activate collapsible sections within articles
 */
function activateCollapsibleSections() {
  const sections = document.getElementsByClassName("collapsible");
  for ( let collapsible of sections ) {
    const header = collapsible.querySelector(".collapsible-header");
    header.addEventListener("click", () => {
      collapsible.classList.toggle("active");
      const content = collapsible.querySelector(".collapsible-content");
      if ( !content ) return;
      if (content.style.maxHeight){
        content.style.maxHeight = null;
      } else {
        content.style.maxHeight = content.scrollHeight + "px";
      }
    });
  }
}

// ----------------------------------------------------------


/**
 * Reset the form by removing an input's value
 */
function _resetInput(elementId) {
  const input = document.getElementById(elementId);
  input.value = "";
  clearNotifications();
}

/**
 * A copy to clipboard function for the clipboard input widget.
 */
async function _copyToClipboard(event) {
  event.preventDefault();
  const label = event.currentTarget;
  const target = label.children[0];
  if (target && target.value) {
    await navigator.clipboard.writeText(target.value);
    return addNotification("info", `Copied ${target.value} to clipboard.`);
  } else {
    return addNotification("error", `Could not copy text from ${target.id}.`);
  }
}

// ----------------------------------------------------------

/**
 * Close other header dropdowns when a header dropdown is clicked
 */
async function _closeOtherDropdowns(event) {
  const dropdownToggle = event.currentTarget;
  const header = document.getElementById("main-header");
  const closeDropdowns = header.getElementsByClassName("dropdown-trigger");

  for (const closeDropdown of closeDropdowns) {
    if (closeDropdown !== dropdownToggle) {
      closeDropdown.checked = false;
    }
  }
}

// ----------------------------------------------------------
