"use strict";
const electron = require("electron");
const path$1 = require("path");
const utils$1 = require("@electron-toolkit/utils");
const fs = require("fs/promises");
const AdmZip = require("adm-zip");
const require$$5 = require("@babel/parser");
const require$$0 = require("tty");
const require$$1 = require("util");
const MagicString = require("magic-string");
const fs$1 = require("fs");
function _interopNamespaceDefault(e) {
  const n = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
  if (e) {
    for (const k in e) {
      if (k !== "default") {
        const d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: () => e[k]
        });
      }
    }
  }
  n.default = e;
  return Object.freeze(n);
}
const path__namespace = /* @__PURE__ */ _interopNamespaceDefault(path$1);
const fs__namespace = /* @__PURE__ */ _interopNamespaceDefault(fs);
class FileSystemHandler {
  async selectDirectory() {
    const { canceled, filePaths } = await electron.dialog.showOpenDialog({
      properties: ["openDirectory"]
    });
    if (canceled || filePaths.length === 0) {
      return null;
    }
    return filePaths[0];
  }
  async selectFile(extensions) {
    const filters = extensions && extensions.length > 0 ? [{ name: "Files", extensions: extensions.map((e) => e.replace(".", "")) }] : [];
    const { canceled, filePaths } = await electron.dialog.showOpenDialog({
      properties: ["openFile"],
      filters
    });
    if (canceled || filePaths.length === 0) {
      return null;
    }
    return filePaths[0];
  }
  async readJson(filePath) {
    const content = await fs.readFile(filePath, "utf-8");
    if (!content || content.trim() === "") {
      return {};
    }
    try {
      return JSON.parse(content);
    } catch (error) {
      console.error("Failed to parse JSON:", filePath, error);
      return {};
    }
  }
  async writeJson(filePath, data) {
    await fs.writeFile(filePath, JSON.stringify(data, null, 2), "utf-8");
  }
  async readFile(filePath) {
    return fs.readFile(filePath, "utf-8");
  }
  async writeFile(filePath, content) {
    await fs.writeFile(filePath, content, "utf-8");
  }
  async getFiles(dirPath, extensions = []) {
    const files = [];
    async function traverse2(currentPath) {
      const stat = await fs.stat(currentPath);
      if (stat.isFile()) {
        if (extensions.length === 0 || extensions.includes(path$1.extname(currentPath))) {
          files.push(currentPath);
        }
        return;
      }
      const entries = await fs.readdir(currentPath, { withFileTypes: true });
      for (const entry of entries) {
        const fullPath = path$1.join(currentPath, entry.name);
        if (entry.isDirectory()) {
          await traverse2(fullPath);
        } else if (entry.isFile()) {
          if (extensions.length === 0 || extensions.includes(path$1.extname(entry.name))) {
            files.push(fullPath);
          }
        }
      }
    }
    await traverse2(dirPath);
    return files;
  }
  async showSaveDialog(defaultPath) {
    const { canceled, filePath } = await electron.dialog.showSaveDialog({
      defaultPath,
      filters: [{ name: "All Files", extensions: ["*"] }]
    });
    return canceled ? null : filePath;
  }
  async extractZip(zipPath) {
    try {
      const zip = new AdmZip(zipPath);
      const targetDir = zipPath.replace(/\.zip$/i, "") + "_unpacked";
      zip.extractAllTo(targetDir, true);
      return targetDir;
    } catch (error) {
      console.error("Failed to extract zip:", error);
      throw error;
    }
  }
  async calculateProgress(filePath) {
    try {
      if (!filePath.toLowerCase().endsWith(".json")) {
        return { total: 0, translated: 0, percentage: 0 };
      }
      const content = await fs.readFile(filePath, "utf-8");
      const json = JSON.parse(content);
      let total = 0;
      let translated = 0;
      const traverse2 = (obj) => {
        for (const key in obj) {
          const value = obj[key];
          if (typeof value === "object" && value !== null) {
            traverse2(value);
          } else if (typeof value === "string") {
            total++;
            if (/[\u4e00-\u9fa5\u3040-\u30ff\uac00-\ud7af]/.test(value)) {
              translated++;
            }
          }
        }
      };
      traverse2(json);
      return {
        total,
        translated,
        percentage: total > 0 ? Math.round(translated / total * 100) : 0
      };
    } catch (error) {
      console.error(`Error calculating progress for ${filePath}:`, error);
      return { total: 0, translated: 0, percentage: 0 };
    }
  }
  async deleteFile(filePath) {
    await fs.unlink(filePath);
  }
  async fileExists(filePath) {
    try {
      await fs.access(filePath);
      return true;
    } catch {
      return false;
    }
  }
}
const fileSystem = new FileSystemHandler();
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var lib$6 = {};
var context$1 = {};
var traverseNode = {};
var context = {};
var path = {};
var virtualTypes = {};
var hasRequiredVirtualTypes;
function requireVirtualTypes() {
  if (hasRequiredVirtualTypes) return virtualTypes;
  hasRequiredVirtualTypes = 1;
  Object.defineProperty(virtualTypes, "__esModule", {
    value: true
  });
  virtualTypes.Var = virtualTypes.User = virtualTypes.Statement = virtualTypes.SpreadProperty = virtualTypes.Scope = virtualTypes.RestProperty = virtualTypes.ReferencedMemberExpression = virtualTypes.ReferencedIdentifier = virtualTypes.Referenced = virtualTypes.Pure = virtualTypes.NumericLiteralTypeAnnotation = virtualTypes.Generated = virtualTypes.ForAwaitStatement = virtualTypes.Flow = virtualTypes.Expression = virtualTypes.ExistentialTypeParam = virtualTypes.BlockScoped = virtualTypes.BindingIdentifier = void 0;
  virtualTypes.ReferencedIdentifier = ["Identifier", "JSXIdentifier"];
  virtualTypes.ReferencedMemberExpression = ["MemberExpression"];
  virtualTypes.BindingIdentifier = ["Identifier"];
  virtualTypes.Statement = ["Statement"];
  virtualTypes.Expression = ["Expression"];
  virtualTypes.Scope = ["Scopable", "Pattern"];
  virtualTypes.Referenced = null;
  virtualTypes.BlockScoped = ["FunctionDeclaration", "ClassDeclaration", "VariableDeclaration"];
  virtualTypes.Var = ["VariableDeclaration"];
  virtualTypes.User = null;
  virtualTypes.Generated = null;
  virtualTypes.Pure = null;
  virtualTypes.Flow = ["Flow", "ImportDeclaration", "ExportDeclaration", "ImportSpecifier"];
  virtualTypes.RestProperty = ["RestElement"];
  virtualTypes.SpreadProperty = ["RestElement"];
  virtualTypes.ExistentialTypeParam = ["ExistsTypeAnnotation"];
  virtualTypes.NumericLiteralTypeAnnotation = ["NumberLiteralTypeAnnotation"];
  virtualTypes.ForAwaitStatement = ["ForOfStatement"];
  return virtualTypes;
}
var src = { exports: {} };
var browser = { exports: {} };
var ms;
var hasRequiredMs;
function requireMs() {
  if (hasRequiredMs) return ms;
  hasRequiredMs = 1;
  var s = 1e3;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  ms = function(val, options2) {
    options2 = options2 || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse2(val);
    } else if (type === "number" && isFinite(val)) {
      return options2.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
    );
  };
  function parse2(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
      str
    );
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return void 0;
    }
  }
  function fmtShort(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d) {
      return Math.round(ms2 / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms2 / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms2 / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms2 / s) + "s";
    }
    return ms2 + "ms";
  }
  function fmtLong(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d) {
      return plural(ms2, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms2, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms2, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms2, msAbs, s, "second");
    }
    return ms2 + " ms";
  }
  function plural(ms2, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms2 / n) + " " + name + (isPlural ? "s" : "");
  }
  return ms;
}
var common;
var hasRequiredCommon;
function requireCommon() {
  if (hasRequiredCommon) return common;
  hasRequiredCommon = 1;
  function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = requireMs();
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key) => {
      createDebug[key] = env[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0; i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug(...args) {
        if (!debug.enabled) {
          return;
        }
        const self2 = debug;
        const curr = Number(/* @__PURE__ */ new Date());
        const ms2 = curr - (prevTime || curr);
        self2.diff = ms2;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
          if (match === "%%") {
            return "%";
          }
          index++;
          const formatter = createDebug.formatters[format];
          if (typeof formatter === "function") {
            const val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug.namespace = namespace;
      debug.useColors = createDebug.useColors();
      debug.color = createDebug.selectColor(namespace);
      debug.extend = extend;
      debug.destroy = createDebug.destroy;
      Object.defineProperty(debug, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug);
      }
      return debug;
    }
    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
      for (const ns of split) {
        if (ns[0] === "-") {
          createDebug.skips.push(ns.slice(1));
        } else {
          createDebug.names.push(ns);
        }
      }
    }
    function matchesTemplate(search, template) {
      let searchIndex = 0;
      let templateIndex = 0;
      let starIndex = -1;
      let matchIndex = 0;
      while (searchIndex < search.length) {
        if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
          if (template[templateIndex] === "*") {
            starIndex = templateIndex;
            matchIndex = searchIndex;
            templateIndex++;
          } else {
            searchIndex++;
            templateIndex++;
          }
        } else if (starIndex !== -1) {
          templateIndex = starIndex + 1;
          matchIndex++;
          searchIndex = matchIndex;
        } else {
          return false;
        }
      }
      while (templateIndex < template.length && template[templateIndex] === "*") {
        templateIndex++;
      }
      return templateIndex === template.length;
    }
    function disable() {
      const namespaces = [
        ...createDebug.names,
        ...createDebug.skips.map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      for (const skip of createDebug.skips) {
        if (matchesTemplate(name, skip)) {
          return false;
        }
      }
      for (const ns of createDebug.names) {
        if (matchesTemplate(name, ns)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  common = setup;
  return common;
}
var hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser) return browser.exports;
  hasRequiredBrowser = 1;
  (function(module, exports$1) {
    exports$1.formatArgs = formatArgs;
    exports$1.save = save;
    exports$1.load = load;
    exports$1.useColors = useColors;
    exports$1.storage = localstorage();
    exports$1.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports$1.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports$1.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports$1.storage.setItem("debug", namespaces);
        } else {
          exports$1.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports$1.storage.getItem("debug") || exports$1.storage.getItem("DEBUG");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module.exports = requireCommon()(exports$1);
    const { formatters: formatters2 } = module.exports;
    formatters2.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  })(browser, browser.exports);
  return browser.exports;
}
var node$1 = { exports: {} };
var hasRequiredNode$1;
function requireNode$1() {
  if (hasRequiredNode$1) return node$1.exports;
  hasRequiredNode$1 = 1;
  (function(module, exports$1) {
    const tty = require$$0;
    const util2 = require$$1;
    exports$1.init = init;
    exports$1.log = log;
    exports$1.formatArgs = formatArgs;
    exports$1.save = save;
    exports$1.load = load;
    exports$1.useColors = useColors;
    exports$1.destroy = util2.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports$1.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require("supports-color");
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports$1.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports$1.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports$1.inspectOpts ? Boolean(exports$1.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports$1.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util2.formatWithOptions(exports$1.inspectOpts, ...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug) {
      debug.inspectOpts = {};
      const keys = Object.keys(exports$1.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports$1.inspectOpts[keys[i]];
      }
    }
    module.exports = requireCommon()(exports$1);
    const { formatters: formatters2 } = module.exports;
    formatters2.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters2.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts);
    };
  })(node$1, node$1.exports);
  return node$1.exports;
}
var hasRequiredSrc;
function requireSrc() {
  if (hasRequiredSrc) return src.exports;
  hasRequiredSrc = 1;
  if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
    src.exports = requireBrowser();
  } else {
    src.exports = requireNode$1();
  }
  return src.exports;
}
var scope = {};
var renamer = {};
var lib$5 = {};
var isReactComponent = {};
var buildMatchMemberExpression = {};
var matchesPattern = {};
var generated$3 = {};
var shallowEqual = {};
var hasRequiredShallowEqual;
function requireShallowEqual() {
  if (hasRequiredShallowEqual) return shallowEqual;
  hasRequiredShallowEqual = 1;
  Object.defineProperty(shallowEqual, "__esModule", {
    value: true
  });
  shallowEqual.default = shallowEqual$1;
  function shallowEqual$1(actual, expected) {
    const keys = Object.keys(expected);
    for (const key of keys) {
      if (actual[key] !== expected[key]) {
        return false;
      }
    }
    return true;
  }
  return shallowEqual;
}
var deprecationWarning = {};
var hasRequiredDeprecationWarning;
function requireDeprecationWarning() {
  if (hasRequiredDeprecationWarning) return deprecationWarning;
  hasRequiredDeprecationWarning = 1;
  Object.defineProperty(deprecationWarning, "__esModule", {
    value: true
  });
  deprecationWarning.default = deprecationWarning$1;
  const warnings = /* @__PURE__ */ new Set();
  function deprecationWarning$1(oldName, newName, prefix = "", cacheKey = oldName) {
    if (warnings.has(cacheKey)) return;
    warnings.add(cacheKey);
    const {
      internal,
      trace
    } = captureShortStackTrace(1, 2);
    if (internal) {
      return;
    }
    console.warn(`${prefix}\`${oldName}\` has been deprecated, please migrate to \`${newName}\`
${trace}`);
  }
  function captureShortStackTrace(skip, length) {
    const {
      stackTraceLimit,
      prepareStackTrace
    } = Error;
    let stackTrace;
    Error.stackTraceLimit = 1 + skip + length;
    Error.prepareStackTrace = function(err, stack) {
      stackTrace = stack;
    };
    new Error().stack;
    Error.stackTraceLimit = stackTraceLimit;
    Error.prepareStackTrace = prepareStackTrace;
    if (!stackTrace) return {
      internal: false,
      trace: ""
    };
    const shortStackTrace = stackTrace.slice(1 + skip, 1 + skip + length);
    return {
      internal: /[\\/]@babel[\\/]/.test(shortStackTrace[1].getFileName()),
      trace: shortStackTrace.map((frame) => `    at ${frame}`).join("\n")
    };
  }
  return deprecationWarning;
}
var hasRequiredGenerated$3;
function requireGenerated$3() {
  if (hasRequiredGenerated$3) return generated$3;
  hasRequiredGenerated$3 = 1;
  Object.defineProperty(generated$3, "__esModule", {
    value: true
  });
  generated$3.isAccessor = isAccessor;
  generated$3.isAnyTypeAnnotation = isAnyTypeAnnotation;
  generated$3.isArgumentPlaceholder = isArgumentPlaceholder;
  generated$3.isArrayExpression = isArrayExpression;
  generated$3.isArrayPattern = isArrayPattern;
  generated$3.isArrayTypeAnnotation = isArrayTypeAnnotation;
  generated$3.isArrowFunctionExpression = isArrowFunctionExpression;
  generated$3.isAssignmentExpression = isAssignmentExpression;
  generated$3.isAssignmentPattern = isAssignmentPattern;
  generated$3.isAwaitExpression = isAwaitExpression;
  generated$3.isBigIntLiteral = isBigIntLiteral;
  generated$3.isBinary = isBinary;
  generated$3.isBinaryExpression = isBinaryExpression;
  generated$3.isBindExpression = isBindExpression;
  generated$3.isBlock = isBlock;
  generated$3.isBlockParent = isBlockParent;
  generated$3.isBlockStatement = isBlockStatement;
  generated$3.isBooleanLiteral = isBooleanLiteral;
  generated$3.isBooleanLiteralTypeAnnotation = isBooleanLiteralTypeAnnotation;
  generated$3.isBooleanTypeAnnotation = isBooleanTypeAnnotation;
  generated$3.isBreakStatement = isBreakStatement;
  generated$3.isCallExpression = isCallExpression;
  generated$3.isCatchClause = isCatchClause;
  generated$3.isClass = isClass;
  generated$3.isClassAccessorProperty = isClassAccessorProperty;
  generated$3.isClassBody = isClassBody;
  generated$3.isClassDeclaration = isClassDeclaration;
  generated$3.isClassExpression = isClassExpression;
  generated$3.isClassImplements = isClassImplements;
  generated$3.isClassMethod = isClassMethod;
  generated$3.isClassPrivateMethod = isClassPrivateMethod;
  generated$3.isClassPrivateProperty = isClassPrivateProperty;
  generated$3.isClassProperty = isClassProperty;
  generated$3.isCompletionStatement = isCompletionStatement;
  generated$3.isConditional = isConditional;
  generated$3.isConditionalExpression = isConditionalExpression;
  generated$3.isContinueStatement = isContinueStatement;
  generated$3.isDebuggerStatement = isDebuggerStatement;
  generated$3.isDecimalLiteral = isDecimalLiteral;
  generated$3.isDeclaration = isDeclaration;
  generated$3.isDeclareClass = isDeclareClass;
  generated$3.isDeclareExportAllDeclaration = isDeclareExportAllDeclaration;
  generated$3.isDeclareExportDeclaration = isDeclareExportDeclaration;
  generated$3.isDeclareFunction = isDeclareFunction;
  generated$3.isDeclareInterface = isDeclareInterface;
  generated$3.isDeclareModule = isDeclareModule;
  generated$3.isDeclareModuleExports = isDeclareModuleExports;
  generated$3.isDeclareOpaqueType = isDeclareOpaqueType;
  generated$3.isDeclareTypeAlias = isDeclareTypeAlias;
  generated$3.isDeclareVariable = isDeclareVariable;
  generated$3.isDeclaredPredicate = isDeclaredPredicate;
  generated$3.isDecorator = isDecorator;
  generated$3.isDirective = isDirective;
  generated$3.isDirectiveLiteral = isDirectiveLiteral;
  generated$3.isDoExpression = isDoExpression;
  generated$3.isDoWhileStatement = isDoWhileStatement;
  generated$3.isEmptyStatement = isEmptyStatement;
  generated$3.isEmptyTypeAnnotation = isEmptyTypeAnnotation;
  generated$3.isEnumBody = isEnumBody;
  generated$3.isEnumBooleanBody = isEnumBooleanBody;
  generated$3.isEnumBooleanMember = isEnumBooleanMember;
  generated$3.isEnumDeclaration = isEnumDeclaration;
  generated$3.isEnumDefaultedMember = isEnumDefaultedMember;
  generated$3.isEnumMember = isEnumMember;
  generated$3.isEnumNumberBody = isEnumNumberBody;
  generated$3.isEnumNumberMember = isEnumNumberMember;
  generated$3.isEnumStringBody = isEnumStringBody;
  generated$3.isEnumStringMember = isEnumStringMember;
  generated$3.isEnumSymbolBody = isEnumSymbolBody;
  generated$3.isExistsTypeAnnotation = isExistsTypeAnnotation;
  generated$3.isExportAllDeclaration = isExportAllDeclaration;
  generated$3.isExportDeclaration = isExportDeclaration;
  generated$3.isExportDefaultDeclaration = isExportDefaultDeclaration;
  generated$3.isExportDefaultSpecifier = isExportDefaultSpecifier;
  generated$3.isExportNamedDeclaration = isExportNamedDeclaration;
  generated$3.isExportNamespaceSpecifier = isExportNamespaceSpecifier;
  generated$3.isExportSpecifier = isExportSpecifier;
  generated$3.isExpression = isExpression;
  generated$3.isExpressionStatement = isExpressionStatement;
  generated$3.isExpressionWrapper = isExpressionWrapper;
  generated$3.isFile = isFile;
  generated$3.isFlow = isFlow;
  generated$3.isFlowBaseAnnotation = isFlowBaseAnnotation;
  generated$3.isFlowDeclaration = isFlowDeclaration;
  generated$3.isFlowPredicate = isFlowPredicate;
  generated$3.isFlowType = isFlowType;
  generated$3.isFor = isFor;
  generated$3.isForInStatement = isForInStatement;
  generated$3.isForOfStatement = isForOfStatement;
  generated$3.isForStatement = isForStatement;
  generated$3.isForXStatement = isForXStatement;
  generated$3.isFunction = isFunction;
  generated$3.isFunctionDeclaration = isFunctionDeclaration;
  generated$3.isFunctionExpression = isFunctionExpression;
  generated$3.isFunctionParameter = isFunctionParameter;
  generated$3.isFunctionParent = isFunctionParent;
  generated$3.isFunctionTypeAnnotation = isFunctionTypeAnnotation;
  generated$3.isFunctionTypeParam = isFunctionTypeParam;
  generated$3.isGenericTypeAnnotation = isGenericTypeAnnotation;
  generated$3.isIdentifier = isIdentifier;
  generated$3.isIfStatement = isIfStatement;
  generated$3.isImmutable = isImmutable2;
  generated$3.isImport = isImport;
  generated$3.isImportAttribute = isImportAttribute;
  generated$3.isImportDeclaration = isImportDeclaration;
  generated$3.isImportDefaultSpecifier = isImportDefaultSpecifier;
  generated$3.isImportExpression = isImportExpression;
  generated$3.isImportNamespaceSpecifier = isImportNamespaceSpecifier;
  generated$3.isImportOrExportDeclaration = isImportOrExportDeclaration;
  generated$3.isImportSpecifier = isImportSpecifier;
  generated$3.isIndexedAccessType = isIndexedAccessType;
  generated$3.isInferredPredicate = isInferredPredicate;
  generated$3.isInterfaceDeclaration = isInterfaceDeclaration;
  generated$3.isInterfaceExtends = isInterfaceExtends;
  generated$3.isInterfaceTypeAnnotation = isInterfaceTypeAnnotation;
  generated$3.isInterpreterDirective = isInterpreterDirective;
  generated$3.isIntersectionTypeAnnotation = isIntersectionTypeAnnotation;
  generated$3.isJSX = isJSX;
  generated$3.isJSXAttribute = isJSXAttribute;
  generated$3.isJSXClosingElement = isJSXClosingElement;
  generated$3.isJSXClosingFragment = isJSXClosingFragment;
  generated$3.isJSXElement = isJSXElement;
  generated$3.isJSXEmptyExpression = isJSXEmptyExpression;
  generated$3.isJSXExpressionContainer = isJSXExpressionContainer;
  generated$3.isJSXFragment = isJSXFragment;
  generated$3.isJSXIdentifier = isJSXIdentifier;
  generated$3.isJSXMemberExpression = isJSXMemberExpression;
  generated$3.isJSXNamespacedName = isJSXNamespacedName;
  generated$3.isJSXOpeningElement = isJSXOpeningElement;
  generated$3.isJSXOpeningFragment = isJSXOpeningFragment;
  generated$3.isJSXSpreadAttribute = isJSXSpreadAttribute;
  generated$3.isJSXSpreadChild = isJSXSpreadChild;
  generated$3.isJSXText = isJSXText;
  generated$3.isLVal = isLVal;
  generated$3.isLabeledStatement = isLabeledStatement;
  generated$3.isLiteral = isLiteral;
  generated$3.isLogicalExpression = isLogicalExpression;
  generated$3.isLoop = isLoop;
  generated$3.isMemberExpression = isMemberExpression;
  generated$3.isMetaProperty = isMetaProperty;
  generated$3.isMethod = isMethod;
  generated$3.isMiscellaneous = isMiscellaneous;
  generated$3.isMixedTypeAnnotation = isMixedTypeAnnotation;
  generated$3.isModuleDeclaration = isModuleDeclaration;
  generated$3.isModuleExpression = isModuleExpression;
  generated$3.isModuleSpecifier = isModuleSpecifier;
  generated$3.isNewExpression = isNewExpression;
  generated$3.isNoop = isNoop;
  generated$3.isNullLiteral = isNullLiteral;
  generated$3.isNullLiteralTypeAnnotation = isNullLiteralTypeAnnotation;
  generated$3.isNullableTypeAnnotation = isNullableTypeAnnotation;
  generated$3.isNumberLiteral = isNumberLiteral;
  generated$3.isNumberLiteralTypeAnnotation = isNumberLiteralTypeAnnotation;
  generated$3.isNumberTypeAnnotation = isNumberTypeAnnotation;
  generated$3.isNumericLiteral = isNumericLiteral;
  generated$3.isObjectExpression = isObjectExpression;
  generated$3.isObjectMember = isObjectMember;
  generated$3.isObjectMethod = isObjectMethod;
  generated$3.isObjectPattern = isObjectPattern;
  generated$3.isObjectProperty = isObjectProperty;
  generated$3.isObjectTypeAnnotation = isObjectTypeAnnotation;
  generated$3.isObjectTypeCallProperty = isObjectTypeCallProperty;
  generated$3.isObjectTypeIndexer = isObjectTypeIndexer;
  generated$3.isObjectTypeInternalSlot = isObjectTypeInternalSlot;
  generated$3.isObjectTypeProperty = isObjectTypeProperty;
  generated$3.isObjectTypeSpreadProperty = isObjectTypeSpreadProperty;
  generated$3.isOpaqueType = isOpaqueType;
  generated$3.isOptionalCallExpression = isOptionalCallExpression;
  generated$3.isOptionalIndexedAccessType = isOptionalIndexedAccessType;
  generated$3.isOptionalMemberExpression = isOptionalMemberExpression;
  generated$3.isParenthesizedExpression = isParenthesizedExpression;
  generated$3.isPattern = isPattern;
  generated$3.isPatternLike = isPatternLike;
  generated$3.isPipelineBareFunction = isPipelineBareFunction;
  generated$3.isPipelinePrimaryTopicReference = isPipelinePrimaryTopicReference;
  generated$3.isPipelineTopicExpression = isPipelineTopicExpression;
  generated$3.isPlaceholder = isPlaceholder;
  generated$3.isPrivate = isPrivate;
  generated$3.isPrivateName = isPrivateName;
  generated$3.isProgram = isProgram;
  generated$3.isProperty = isProperty;
  generated$3.isPureish = isPureish;
  generated$3.isQualifiedTypeIdentifier = isQualifiedTypeIdentifier;
  generated$3.isRecordExpression = isRecordExpression;
  generated$3.isRegExpLiteral = isRegExpLiteral;
  generated$3.isRegexLiteral = isRegexLiteral;
  generated$3.isRestElement = isRestElement;
  generated$3.isRestProperty = isRestProperty;
  generated$3.isReturnStatement = isReturnStatement;
  generated$3.isScopable = isScopable;
  generated$3.isSequenceExpression = isSequenceExpression;
  generated$3.isSpreadElement = isSpreadElement;
  generated$3.isSpreadProperty = isSpreadProperty;
  generated$3.isStandardized = isStandardized;
  generated$3.isStatement = isStatement;
  generated$3.isStaticBlock = isStaticBlock;
  generated$3.isStringLiteral = isStringLiteral;
  generated$3.isStringLiteralTypeAnnotation = isStringLiteralTypeAnnotation;
  generated$3.isStringTypeAnnotation = isStringTypeAnnotation;
  generated$3.isSuper = isSuper;
  generated$3.isSwitchCase = isSwitchCase;
  generated$3.isSwitchStatement = isSwitchStatement;
  generated$3.isSymbolTypeAnnotation = isSymbolTypeAnnotation;
  generated$3.isTSAnyKeyword = isTSAnyKeyword;
  generated$3.isTSArrayType = isTSArrayType;
  generated$3.isTSAsExpression = isTSAsExpression;
  generated$3.isTSBaseType = isTSBaseType;
  generated$3.isTSBigIntKeyword = isTSBigIntKeyword;
  generated$3.isTSBooleanKeyword = isTSBooleanKeyword;
  generated$3.isTSCallSignatureDeclaration = isTSCallSignatureDeclaration;
  generated$3.isTSConditionalType = isTSConditionalType;
  generated$3.isTSConstructSignatureDeclaration = isTSConstructSignatureDeclaration;
  generated$3.isTSConstructorType = isTSConstructorType;
  generated$3.isTSDeclareFunction = isTSDeclareFunction;
  generated$3.isTSDeclareMethod = isTSDeclareMethod;
  generated$3.isTSEntityName = isTSEntityName;
  generated$3.isTSEnumBody = isTSEnumBody;
  generated$3.isTSEnumDeclaration = isTSEnumDeclaration;
  generated$3.isTSEnumMember = isTSEnumMember;
  generated$3.isTSExportAssignment = isTSExportAssignment;
  generated$3.isTSExpressionWithTypeArguments = isTSExpressionWithTypeArguments;
  generated$3.isTSExternalModuleReference = isTSExternalModuleReference;
  generated$3.isTSFunctionType = isTSFunctionType;
  generated$3.isTSImportEqualsDeclaration = isTSImportEqualsDeclaration;
  generated$3.isTSImportType = isTSImportType;
  generated$3.isTSIndexSignature = isTSIndexSignature;
  generated$3.isTSIndexedAccessType = isTSIndexedAccessType;
  generated$3.isTSInferType = isTSInferType;
  generated$3.isTSInstantiationExpression = isTSInstantiationExpression;
  generated$3.isTSInterfaceBody = isTSInterfaceBody;
  generated$3.isTSInterfaceDeclaration = isTSInterfaceDeclaration;
  generated$3.isTSIntersectionType = isTSIntersectionType;
  generated$3.isTSIntrinsicKeyword = isTSIntrinsicKeyword;
  generated$3.isTSLiteralType = isTSLiteralType;
  generated$3.isTSMappedType = isTSMappedType;
  generated$3.isTSMethodSignature = isTSMethodSignature;
  generated$3.isTSModuleBlock = isTSModuleBlock;
  generated$3.isTSModuleDeclaration = isTSModuleDeclaration;
  generated$3.isTSNamedTupleMember = isTSNamedTupleMember;
  generated$3.isTSNamespaceExportDeclaration = isTSNamespaceExportDeclaration;
  generated$3.isTSNeverKeyword = isTSNeverKeyword;
  generated$3.isTSNonNullExpression = isTSNonNullExpression;
  generated$3.isTSNullKeyword = isTSNullKeyword;
  generated$3.isTSNumberKeyword = isTSNumberKeyword;
  generated$3.isTSObjectKeyword = isTSObjectKeyword;
  generated$3.isTSOptionalType = isTSOptionalType;
  generated$3.isTSParameterProperty = isTSParameterProperty;
  generated$3.isTSParenthesizedType = isTSParenthesizedType;
  generated$3.isTSPropertySignature = isTSPropertySignature;
  generated$3.isTSQualifiedName = isTSQualifiedName;
  generated$3.isTSRestType = isTSRestType;
  generated$3.isTSSatisfiesExpression = isTSSatisfiesExpression;
  generated$3.isTSStringKeyword = isTSStringKeyword;
  generated$3.isTSSymbolKeyword = isTSSymbolKeyword;
  generated$3.isTSTemplateLiteralType = isTSTemplateLiteralType;
  generated$3.isTSThisType = isTSThisType;
  generated$3.isTSTupleType = isTSTupleType;
  generated$3.isTSType = isTSType;
  generated$3.isTSTypeAliasDeclaration = isTSTypeAliasDeclaration;
  generated$3.isTSTypeAnnotation = isTSTypeAnnotation;
  generated$3.isTSTypeAssertion = isTSTypeAssertion;
  generated$3.isTSTypeElement = isTSTypeElement;
  generated$3.isTSTypeLiteral = isTSTypeLiteral;
  generated$3.isTSTypeOperator = isTSTypeOperator;
  generated$3.isTSTypeParameter = isTSTypeParameter;
  generated$3.isTSTypeParameterDeclaration = isTSTypeParameterDeclaration;
  generated$3.isTSTypeParameterInstantiation = isTSTypeParameterInstantiation;
  generated$3.isTSTypePredicate = isTSTypePredicate;
  generated$3.isTSTypeQuery = isTSTypeQuery;
  generated$3.isTSTypeReference = isTSTypeReference;
  generated$3.isTSUndefinedKeyword = isTSUndefinedKeyword;
  generated$3.isTSUnionType = isTSUnionType;
  generated$3.isTSUnknownKeyword = isTSUnknownKeyword;
  generated$3.isTSVoidKeyword = isTSVoidKeyword;
  generated$3.isTaggedTemplateExpression = isTaggedTemplateExpression;
  generated$3.isTemplateElement = isTemplateElement;
  generated$3.isTemplateLiteral = isTemplateLiteral;
  generated$3.isTerminatorless = isTerminatorless;
  generated$3.isThisExpression = isThisExpression;
  generated$3.isThisTypeAnnotation = isThisTypeAnnotation;
  generated$3.isThrowStatement = isThrowStatement;
  generated$3.isTopicReference = isTopicReference;
  generated$3.isTryStatement = isTryStatement;
  generated$3.isTupleExpression = isTupleExpression;
  generated$3.isTupleTypeAnnotation = isTupleTypeAnnotation;
  generated$3.isTypeAlias = isTypeAlias;
  generated$3.isTypeAnnotation = isTypeAnnotation;
  generated$3.isTypeCastExpression = isTypeCastExpression;
  generated$3.isTypeParameter = isTypeParameter;
  generated$3.isTypeParameterDeclaration = isTypeParameterDeclaration;
  generated$3.isTypeParameterInstantiation = isTypeParameterInstantiation;
  generated$3.isTypeScript = isTypeScript;
  generated$3.isTypeofTypeAnnotation = isTypeofTypeAnnotation;
  generated$3.isUnaryExpression = isUnaryExpression;
  generated$3.isUnaryLike = isUnaryLike;
  generated$3.isUnionTypeAnnotation = isUnionTypeAnnotation;
  generated$3.isUpdateExpression = isUpdateExpression;
  generated$3.isUserWhitespacable = isUserWhitespacable;
  generated$3.isV8IntrinsicIdentifier = isV8IntrinsicIdentifier;
  generated$3.isVariableDeclaration = isVariableDeclaration;
  generated$3.isVariableDeclarator = isVariableDeclarator;
  generated$3.isVariance = isVariance;
  generated$3.isVoidPattern = isVoidPattern;
  generated$3.isVoidTypeAnnotation = isVoidTypeAnnotation;
  generated$3.isWhile = isWhile;
  generated$3.isWhileStatement = isWhileStatement;
  generated$3.isWithStatement = isWithStatement;
  generated$3.isYieldExpression = isYieldExpression;
  var _shallowEqual = requireShallowEqual();
  var _deprecationWarning = requireDeprecationWarning();
  function isArrayExpression(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ArrayExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isAssignmentExpression(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "AssignmentExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isBinaryExpression(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "BinaryExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isInterpreterDirective(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "InterpreterDirective") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isDirective(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "Directive") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isDirectiveLiteral(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "DirectiveLiteral") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isBlockStatement(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "BlockStatement") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isBreakStatement(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "BreakStatement") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isCallExpression(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "CallExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isCatchClause(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "CatchClause") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isConditionalExpression(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ConditionalExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isContinueStatement(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ContinueStatement") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isDebuggerStatement(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "DebuggerStatement") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isDoWhileStatement(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "DoWhileStatement") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isEmptyStatement(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "EmptyStatement") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isExpressionStatement(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ExpressionStatement") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isFile(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "File") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isForInStatement(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ForInStatement") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isForStatement(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ForStatement") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isFunctionDeclaration(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "FunctionDeclaration") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isFunctionExpression(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "FunctionExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isIdentifier(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "Identifier") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isIfStatement(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "IfStatement") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isLabeledStatement(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "LabeledStatement") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isStringLiteral(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "StringLiteral") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isNumericLiteral(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "NumericLiteral") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isNullLiteral(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "NullLiteral") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isBooleanLiteral(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "BooleanLiteral") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isRegExpLiteral(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "RegExpLiteral") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isLogicalExpression(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "LogicalExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isMemberExpression(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "MemberExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isNewExpression(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "NewExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isProgram(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "Program") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isObjectExpression(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ObjectExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isObjectMethod(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ObjectMethod") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isObjectProperty(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ObjectProperty") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isRestElement(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "RestElement") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isReturnStatement(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ReturnStatement") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isSequenceExpression(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "SequenceExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isParenthesizedExpression(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ParenthesizedExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isSwitchCase(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "SwitchCase") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isSwitchStatement(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "SwitchStatement") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isThisExpression(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ThisExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isThrowStatement(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ThrowStatement") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTryStatement(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TryStatement") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isUnaryExpression(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "UnaryExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isUpdateExpression(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "UpdateExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isVariableDeclaration(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "VariableDeclaration") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isVariableDeclarator(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "VariableDeclarator") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isWhileStatement(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "WhileStatement") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isWithStatement(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "WithStatement") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isAssignmentPattern(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "AssignmentPattern") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isArrayPattern(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ArrayPattern") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isArrowFunctionExpression(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ArrowFunctionExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isClassBody(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ClassBody") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isClassExpression(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ClassExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isClassDeclaration(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ClassDeclaration") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isExportAllDeclaration(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ExportAllDeclaration") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isExportDefaultDeclaration(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ExportDefaultDeclaration") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isExportNamedDeclaration(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ExportNamedDeclaration") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isExportSpecifier(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ExportSpecifier") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isForOfStatement(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ForOfStatement") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isImportDeclaration(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ImportDeclaration") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isImportDefaultSpecifier(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ImportDefaultSpecifier") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isImportNamespaceSpecifier(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ImportNamespaceSpecifier") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isImportSpecifier(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ImportSpecifier") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isImportExpression(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ImportExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isMetaProperty(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "MetaProperty") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isClassMethod(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ClassMethod") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isObjectPattern(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ObjectPattern") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isSpreadElement(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "SpreadElement") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isSuper(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "Super") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTaggedTemplateExpression(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TaggedTemplateExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTemplateElement(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TemplateElement") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTemplateLiteral(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TemplateLiteral") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isYieldExpression(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "YieldExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isAwaitExpression(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "AwaitExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isImport(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "Import") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isBigIntLiteral(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "BigIntLiteral") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isExportNamespaceSpecifier(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ExportNamespaceSpecifier") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isOptionalMemberExpression(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "OptionalMemberExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isOptionalCallExpression(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "OptionalCallExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isClassProperty(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ClassProperty") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isClassAccessorProperty(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ClassAccessorProperty") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isClassPrivateProperty(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ClassPrivateProperty") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isClassPrivateMethod(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ClassPrivateMethod") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isPrivateName(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "PrivateName") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isStaticBlock(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "StaticBlock") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isImportAttribute(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ImportAttribute") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isAnyTypeAnnotation(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "AnyTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isArrayTypeAnnotation(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ArrayTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isBooleanTypeAnnotation(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "BooleanTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isBooleanLiteralTypeAnnotation(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "BooleanLiteralTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isNullLiteralTypeAnnotation(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "NullLiteralTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isClassImplements(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ClassImplements") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isDeclareClass(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "DeclareClass") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isDeclareFunction(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "DeclareFunction") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isDeclareInterface(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "DeclareInterface") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isDeclareModule(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "DeclareModule") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isDeclareModuleExports(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "DeclareModuleExports") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isDeclareTypeAlias(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "DeclareTypeAlias") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isDeclareOpaqueType(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "DeclareOpaqueType") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isDeclareVariable(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "DeclareVariable") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isDeclareExportDeclaration(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "DeclareExportDeclaration") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isDeclareExportAllDeclaration(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "DeclareExportAllDeclaration") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isDeclaredPredicate(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "DeclaredPredicate") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isExistsTypeAnnotation(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ExistsTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isFunctionTypeAnnotation(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "FunctionTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isFunctionTypeParam(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "FunctionTypeParam") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isGenericTypeAnnotation(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "GenericTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isInferredPredicate(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "InferredPredicate") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isInterfaceExtends(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "InterfaceExtends") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isInterfaceDeclaration(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "InterfaceDeclaration") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isInterfaceTypeAnnotation(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "InterfaceTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isIntersectionTypeAnnotation(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "IntersectionTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isMixedTypeAnnotation(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "MixedTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isEmptyTypeAnnotation(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "EmptyTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isNullableTypeAnnotation(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "NullableTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isNumberLiteralTypeAnnotation(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "NumberLiteralTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isNumberTypeAnnotation(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "NumberTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isObjectTypeAnnotation(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ObjectTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isObjectTypeInternalSlot(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ObjectTypeInternalSlot") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isObjectTypeCallProperty(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ObjectTypeCallProperty") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isObjectTypeIndexer(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ObjectTypeIndexer") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isObjectTypeProperty(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ObjectTypeProperty") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isObjectTypeSpreadProperty(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ObjectTypeSpreadProperty") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isOpaqueType(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "OpaqueType") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isQualifiedTypeIdentifier(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "QualifiedTypeIdentifier") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isStringLiteralTypeAnnotation(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "StringLiteralTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isStringTypeAnnotation(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "StringTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isSymbolTypeAnnotation(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "SymbolTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isThisTypeAnnotation(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ThisTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTupleTypeAnnotation(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TupleTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTypeofTypeAnnotation(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TypeofTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTypeAlias(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TypeAlias") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTypeAnnotation(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TypeAnnotation") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTypeCastExpression(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TypeCastExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTypeParameter(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TypeParameter") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTypeParameterDeclaration(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TypeParameterDeclaration") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTypeParameterInstantiation(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TypeParameterInstantiation") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isUnionTypeAnnotation(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "UnionTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isVariance(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "Variance") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isVoidTypeAnnotation(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "VoidTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isEnumDeclaration(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "EnumDeclaration") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isEnumBooleanBody(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "EnumBooleanBody") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isEnumNumberBody(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "EnumNumberBody") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isEnumStringBody(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "EnumStringBody") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isEnumSymbolBody(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "EnumSymbolBody") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isEnumBooleanMember(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "EnumBooleanMember") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isEnumNumberMember(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "EnumNumberMember") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isEnumStringMember(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "EnumStringMember") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isEnumDefaultedMember(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "EnumDefaultedMember") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isIndexedAccessType(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "IndexedAccessType") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isOptionalIndexedAccessType(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "OptionalIndexedAccessType") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isJSXAttribute(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "JSXAttribute") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isJSXClosingElement(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "JSXClosingElement") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isJSXElement(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "JSXElement") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isJSXEmptyExpression(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "JSXEmptyExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isJSXExpressionContainer(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "JSXExpressionContainer") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isJSXSpreadChild(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "JSXSpreadChild") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isJSXIdentifier(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "JSXIdentifier") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isJSXMemberExpression(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "JSXMemberExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isJSXNamespacedName(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "JSXNamespacedName") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isJSXOpeningElement(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "JSXOpeningElement") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isJSXSpreadAttribute(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "JSXSpreadAttribute") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isJSXText(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "JSXText") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isJSXFragment(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "JSXFragment") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isJSXOpeningFragment(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "JSXOpeningFragment") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isJSXClosingFragment(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "JSXClosingFragment") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isNoop(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "Noop") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isPlaceholder(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "Placeholder") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isV8IntrinsicIdentifier(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "V8IntrinsicIdentifier") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isArgumentPlaceholder(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ArgumentPlaceholder") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isBindExpression(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "BindExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isDecorator(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "Decorator") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isDoExpression(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "DoExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isExportDefaultSpecifier(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ExportDefaultSpecifier") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isRecordExpression(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "RecordExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTupleExpression(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TupleExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isDecimalLiteral(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "DecimalLiteral") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isModuleExpression(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "ModuleExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTopicReference(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TopicReference") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isPipelineTopicExpression(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "PipelineTopicExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isPipelineBareFunction(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "PipelineBareFunction") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isPipelinePrimaryTopicReference(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "PipelinePrimaryTopicReference") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isVoidPattern(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "VoidPattern") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSParameterProperty(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSParameterProperty") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSDeclareFunction(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSDeclareFunction") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSDeclareMethod(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSDeclareMethod") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSQualifiedName(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSQualifiedName") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSCallSignatureDeclaration(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSCallSignatureDeclaration") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSConstructSignatureDeclaration(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSConstructSignatureDeclaration") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSPropertySignature(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSPropertySignature") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSMethodSignature(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSMethodSignature") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSIndexSignature(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSIndexSignature") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSAnyKeyword(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSAnyKeyword") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSBooleanKeyword(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSBooleanKeyword") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSBigIntKeyword(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSBigIntKeyword") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSIntrinsicKeyword(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSIntrinsicKeyword") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSNeverKeyword(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSNeverKeyword") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSNullKeyword(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSNullKeyword") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSNumberKeyword(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSNumberKeyword") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSObjectKeyword(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSObjectKeyword") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSStringKeyword(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSStringKeyword") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSSymbolKeyword(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSSymbolKeyword") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSUndefinedKeyword(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSUndefinedKeyword") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSUnknownKeyword(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSUnknownKeyword") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSVoidKeyword(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSVoidKeyword") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSThisType(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSThisType") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSFunctionType(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSFunctionType") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSConstructorType(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSConstructorType") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSTypeReference(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSTypeReference") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSTypePredicate(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSTypePredicate") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSTypeQuery(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSTypeQuery") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSTypeLiteral(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSTypeLiteral") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSArrayType(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSArrayType") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSTupleType(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSTupleType") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSOptionalType(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSOptionalType") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSRestType(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSRestType") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSNamedTupleMember(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSNamedTupleMember") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSUnionType(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSUnionType") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSIntersectionType(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSIntersectionType") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSConditionalType(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSConditionalType") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSInferType(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSInferType") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSParenthesizedType(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSParenthesizedType") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSTypeOperator(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSTypeOperator") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSIndexedAccessType(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSIndexedAccessType") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSMappedType(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSMappedType") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSTemplateLiteralType(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSTemplateLiteralType") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSLiteralType(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSLiteralType") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSExpressionWithTypeArguments(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSExpressionWithTypeArguments") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSInterfaceDeclaration(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSInterfaceDeclaration") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSInterfaceBody(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSInterfaceBody") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSTypeAliasDeclaration(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSTypeAliasDeclaration") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSInstantiationExpression(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSInstantiationExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSAsExpression(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSAsExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSSatisfiesExpression(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSSatisfiesExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSTypeAssertion(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSTypeAssertion") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSEnumBody(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSEnumBody") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSEnumDeclaration(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSEnumDeclaration") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSEnumMember(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSEnumMember") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSModuleDeclaration(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSModuleDeclaration") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSModuleBlock(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSModuleBlock") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSImportType(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSImportType") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSImportEqualsDeclaration(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSImportEqualsDeclaration") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSExternalModuleReference(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSExternalModuleReference") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSNonNullExpression(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSNonNullExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSExportAssignment(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSExportAssignment") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSNamespaceExportDeclaration(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSNamespaceExportDeclaration") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSTypeAnnotation(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSTypeParameterInstantiation(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSTypeParameterInstantiation") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSTypeParameterDeclaration(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSTypeParameterDeclaration") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSTypeParameter(node2, opts) {
    if (!node2) return false;
    if (node2.type !== "TSTypeParameter") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isStandardized(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "ArrayExpression":
      case "AssignmentExpression":
      case "BinaryExpression":
      case "InterpreterDirective":
      case "Directive":
      case "DirectiveLiteral":
      case "BlockStatement":
      case "BreakStatement":
      case "CallExpression":
      case "CatchClause":
      case "ConditionalExpression":
      case "ContinueStatement":
      case "DebuggerStatement":
      case "DoWhileStatement":
      case "EmptyStatement":
      case "ExpressionStatement":
      case "File":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "Identifier":
      case "IfStatement":
      case "LabeledStatement":
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "LogicalExpression":
      case "MemberExpression":
      case "NewExpression":
      case "Program":
      case "ObjectExpression":
      case "ObjectMethod":
      case "ObjectProperty":
      case "RestElement":
      case "ReturnStatement":
      case "SequenceExpression":
      case "ParenthesizedExpression":
      case "SwitchCase":
      case "SwitchStatement":
      case "ThisExpression":
      case "ThrowStatement":
      case "TryStatement":
      case "UnaryExpression":
      case "UpdateExpression":
      case "VariableDeclaration":
      case "VariableDeclarator":
      case "WhileStatement":
      case "WithStatement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ArrowFunctionExpression":
      case "ClassBody":
      case "ClassExpression":
      case "ClassDeclaration":
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ExportSpecifier":
      case "ForOfStatement":
      case "ImportDeclaration":
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
      case "ImportExpression":
      case "MetaProperty":
      case "ClassMethod":
      case "ObjectPattern":
      case "SpreadElement":
      case "Super":
      case "TaggedTemplateExpression":
      case "TemplateElement":
      case "TemplateLiteral":
      case "YieldExpression":
      case "AwaitExpression":
      case "Import":
      case "BigIntLiteral":
      case "ExportNamespaceSpecifier":
      case "OptionalMemberExpression":
      case "OptionalCallExpression":
      case "ClassProperty":
      case "ClassAccessorProperty":
      case "ClassPrivateProperty":
      case "ClassPrivateMethod":
      case "PrivateName":
      case "StaticBlock":
      case "ImportAttribute":
        break;
      case "Placeholder":
        switch (node2.expectedNode) {
          case "Identifier":
          case "StringLiteral":
          case "BlockStatement":
          case "ClassBody":
            break;
          default:
            return false;
        }
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isExpression(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "ArrayExpression":
      case "AssignmentExpression":
      case "BinaryExpression":
      case "CallExpression":
      case "ConditionalExpression":
      case "FunctionExpression":
      case "Identifier":
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "LogicalExpression":
      case "MemberExpression":
      case "NewExpression":
      case "ObjectExpression":
      case "SequenceExpression":
      case "ParenthesizedExpression":
      case "ThisExpression":
      case "UnaryExpression":
      case "UpdateExpression":
      case "ArrowFunctionExpression":
      case "ClassExpression":
      case "ImportExpression":
      case "MetaProperty":
      case "Super":
      case "TaggedTemplateExpression":
      case "TemplateLiteral":
      case "YieldExpression":
      case "AwaitExpression":
      case "Import":
      case "BigIntLiteral":
      case "OptionalMemberExpression":
      case "OptionalCallExpression":
      case "TypeCastExpression":
      case "JSXElement":
      case "JSXFragment":
      case "BindExpression":
      case "DoExpression":
      case "RecordExpression":
      case "TupleExpression":
      case "DecimalLiteral":
      case "ModuleExpression":
      case "TopicReference":
      case "PipelineTopicExpression":
      case "PipelineBareFunction":
      case "PipelinePrimaryTopicReference":
      case "TSInstantiationExpression":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        break;
      case "Placeholder":
        switch (node2.expectedNode) {
          case "Expression":
          case "Identifier":
          case "StringLiteral":
            break;
          default:
            return false;
        }
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isBinary(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "BinaryExpression":
      case "LogicalExpression":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isScopable(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "BlockStatement":
      case "CatchClause":
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "Program":
      case "ObjectMethod":
      case "SwitchStatement":
      case "WhileStatement":
      case "ArrowFunctionExpression":
      case "ClassExpression":
      case "ClassDeclaration":
      case "ForOfStatement":
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "StaticBlock":
      case "TSModuleBlock":
        break;
      case "Placeholder":
        if (node2.expectedNode === "BlockStatement") break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isBlockParent(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "BlockStatement":
      case "CatchClause":
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "Program":
      case "ObjectMethod":
      case "SwitchStatement":
      case "WhileStatement":
      case "ArrowFunctionExpression":
      case "ForOfStatement":
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "StaticBlock":
      case "TSModuleBlock":
        break;
      case "Placeholder":
        if (node2.expectedNode === "BlockStatement") break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isBlock(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "BlockStatement":
      case "Program":
      case "TSModuleBlock":
        break;
      case "Placeholder":
        if (node2.expectedNode === "BlockStatement") break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isStatement(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "BlockStatement":
      case "BreakStatement":
      case "ContinueStatement":
      case "DebuggerStatement":
      case "DoWhileStatement":
      case "EmptyStatement":
      case "ExpressionStatement":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "IfStatement":
      case "LabeledStatement":
      case "ReturnStatement":
      case "SwitchStatement":
      case "ThrowStatement":
      case "TryStatement":
      case "VariableDeclaration":
      case "WhileStatement":
      case "WithStatement":
      case "ClassDeclaration":
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ForOfStatement":
      case "ImportDeclaration":
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "InterfaceDeclaration":
      case "OpaqueType":
      case "TypeAlias":
      case "EnumDeclaration":
      case "TSDeclareFunction":
      case "TSInterfaceDeclaration":
      case "TSTypeAliasDeclaration":
      case "TSEnumDeclaration":
      case "TSModuleDeclaration":
      case "TSImportEqualsDeclaration":
      case "TSExportAssignment":
      case "TSNamespaceExportDeclaration":
        break;
      case "Placeholder":
        switch (node2.expectedNode) {
          case "Statement":
          case "Declaration":
          case "BlockStatement":
            break;
          default:
            return false;
        }
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTerminatorless(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "BreakStatement":
      case "ContinueStatement":
      case "ReturnStatement":
      case "ThrowStatement":
      case "YieldExpression":
      case "AwaitExpression":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isCompletionStatement(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "BreakStatement":
      case "ContinueStatement":
      case "ReturnStatement":
      case "ThrowStatement":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isConditional(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "ConditionalExpression":
      case "IfStatement":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isLoop(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "WhileStatement":
      case "ForOfStatement":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isWhile(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "DoWhileStatement":
      case "WhileStatement":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isExpressionWrapper(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "ExpressionStatement":
      case "ParenthesizedExpression":
      case "TypeCastExpression":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isFor(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "ForInStatement":
      case "ForStatement":
      case "ForOfStatement":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isForXStatement(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "ForInStatement":
      case "ForOfStatement":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isFunction(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "ObjectMethod":
      case "ArrowFunctionExpression":
      case "ClassMethod":
      case "ClassPrivateMethod":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isFunctionParent(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "ObjectMethod":
      case "ArrowFunctionExpression":
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "StaticBlock":
      case "TSModuleBlock":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isPureish(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "ArrowFunctionExpression":
      case "BigIntLiteral":
      case "DecimalLiteral":
        break;
      case "Placeholder":
        if (node2.expectedNode === "StringLiteral") break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isDeclaration(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "FunctionDeclaration":
      case "VariableDeclaration":
      case "ClassDeclaration":
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ImportDeclaration":
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "InterfaceDeclaration":
      case "OpaqueType":
      case "TypeAlias":
      case "EnumDeclaration":
      case "TSDeclareFunction":
      case "TSInterfaceDeclaration":
      case "TSTypeAliasDeclaration":
      case "TSEnumDeclaration":
      case "TSModuleDeclaration":
      case "TSImportEqualsDeclaration":
        break;
      case "Placeholder":
        if (node2.expectedNode === "Declaration") break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isFunctionParameter(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "Identifier":
      case "RestElement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
      case "VoidPattern":
        break;
      case "Placeholder":
        if (node2.expectedNode === "Identifier") break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isPatternLike(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "Identifier":
      case "MemberExpression":
      case "RestElement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
      case "VoidPattern":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        break;
      case "Placeholder":
        switch (node2.expectedNode) {
          case "Pattern":
          case "Identifier":
            break;
          default:
            return false;
        }
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isLVal(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "Identifier":
      case "MemberExpression":
      case "RestElement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
      case "TSParameterProperty":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        break;
      case "Placeholder":
        switch (node2.expectedNode) {
          case "Pattern":
          case "Identifier":
            break;
          default:
            return false;
        }
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSEntityName(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "Identifier":
      case "TSQualifiedName":
        break;
      case "Placeholder":
        if (node2.expectedNode === "Identifier") break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isLiteral(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "TemplateLiteral":
      case "BigIntLiteral":
      case "DecimalLiteral":
        break;
      case "Placeholder":
        if (node2.expectedNode === "StringLiteral") break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isImmutable2(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "BigIntLiteral":
      case "JSXAttribute":
      case "JSXClosingElement":
      case "JSXElement":
      case "JSXExpressionContainer":
      case "JSXSpreadChild":
      case "JSXOpeningElement":
      case "JSXText":
      case "JSXFragment":
      case "JSXOpeningFragment":
      case "JSXClosingFragment":
      case "DecimalLiteral":
        break;
      case "Placeholder":
        if (node2.expectedNode === "StringLiteral") break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isUserWhitespacable(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "ObjectMethod":
      case "ObjectProperty":
      case "ObjectTypeInternalSlot":
      case "ObjectTypeCallProperty":
      case "ObjectTypeIndexer":
      case "ObjectTypeProperty":
      case "ObjectTypeSpreadProperty":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isMethod(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "ObjectMethod":
      case "ClassMethod":
      case "ClassPrivateMethod":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isObjectMember(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "ObjectMethod":
      case "ObjectProperty":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isProperty(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "ObjectProperty":
      case "ClassProperty":
      case "ClassAccessorProperty":
      case "ClassPrivateProperty":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isUnaryLike(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "UnaryExpression":
      case "SpreadElement":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isPattern(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
      case "VoidPattern":
        break;
      case "Placeholder":
        if (node2.expectedNode === "Pattern") break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isClass(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "ClassExpression":
      case "ClassDeclaration":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isImportOrExportDeclaration(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ImportDeclaration":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isExportDeclaration(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isModuleSpecifier(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "ExportSpecifier":
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
      case "ExportNamespaceSpecifier":
      case "ExportDefaultSpecifier":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isAccessor(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "ClassAccessorProperty":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isPrivate(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "ClassPrivateProperty":
      case "ClassPrivateMethod":
      case "PrivateName":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isFlow(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "AnyTypeAnnotation":
      case "ArrayTypeAnnotation":
      case "BooleanTypeAnnotation":
      case "BooleanLiteralTypeAnnotation":
      case "NullLiteralTypeAnnotation":
      case "ClassImplements":
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "DeclaredPredicate":
      case "ExistsTypeAnnotation":
      case "FunctionTypeAnnotation":
      case "FunctionTypeParam":
      case "GenericTypeAnnotation":
      case "InferredPredicate":
      case "InterfaceExtends":
      case "InterfaceDeclaration":
      case "InterfaceTypeAnnotation":
      case "IntersectionTypeAnnotation":
      case "MixedTypeAnnotation":
      case "EmptyTypeAnnotation":
      case "NullableTypeAnnotation":
      case "NumberLiteralTypeAnnotation":
      case "NumberTypeAnnotation":
      case "ObjectTypeAnnotation":
      case "ObjectTypeInternalSlot":
      case "ObjectTypeCallProperty":
      case "ObjectTypeIndexer":
      case "ObjectTypeProperty":
      case "ObjectTypeSpreadProperty":
      case "OpaqueType":
      case "QualifiedTypeIdentifier":
      case "StringLiteralTypeAnnotation":
      case "StringTypeAnnotation":
      case "SymbolTypeAnnotation":
      case "ThisTypeAnnotation":
      case "TupleTypeAnnotation":
      case "TypeofTypeAnnotation":
      case "TypeAlias":
      case "TypeAnnotation":
      case "TypeCastExpression":
      case "TypeParameter":
      case "TypeParameterDeclaration":
      case "TypeParameterInstantiation":
      case "UnionTypeAnnotation":
      case "Variance":
      case "VoidTypeAnnotation":
      case "EnumDeclaration":
      case "EnumBooleanBody":
      case "EnumNumberBody":
      case "EnumStringBody":
      case "EnumSymbolBody":
      case "EnumBooleanMember":
      case "EnumNumberMember":
      case "EnumStringMember":
      case "EnumDefaultedMember":
      case "IndexedAccessType":
      case "OptionalIndexedAccessType":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isFlowType(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "AnyTypeAnnotation":
      case "ArrayTypeAnnotation":
      case "BooleanTypeAnnotation":
      case "BooleanLiteralTypeAnnotation":
      case "NullLiteralTypeAnnotation":
      case "ExistsTypeAnnotation":
      case "FunctionTypeAnnotation":
      case "GenericTypeAnnotation":
      case "InterfaceTypeAnnotation":
      case "IntersectionTypeAnnotation":
      case "MixedTypeAnnotation":
      case "EmptyTypeAnnotation":
      case "NullableTypeAnnotation":
      case "NumberLiteralTypeAnnotation":
      case "NumberTypeAnnotation":
      case "ObjectTypeAnnotation":
      case "StringLiteralTypeAnnotation":
      case "StringTypeAnnotation":
      case "SymbolTypeAnnotation":
      case "ThisTypeAnnotation":
      case "TupleTypeAnnotation":
      case "TypeofTypeAnnotation":
      case "UnionTypeAnnotation":
      case "VoidTypeAnnotation":
      case "IndexedAccessType":
      case "OptionalIndexedAccessType":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isFlowBaseAnnotation(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "AnyTypeAnnotation":
      case "BooleanTypeAnnotation":
      case "NullLiteralTypeAnnotation":
      case "MixedTypeAnnotation":
      case "EmptyTypeAnnotation":
      case "NumberTypeAnnotation":
      case "StringTypeAnnotation":
      case "SymbolTypeAnnotation":
      case "ThisTypeAnnotation":
      case "VoidTypeAnnotation":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isFlowDeclaration(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "InterfaceDeclaration":
      case "OpaqueType":
      case "TypeAlias":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isFlowPredicate(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "DeclaredPredicate":
      case "InferredPredicate":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isEnumBody(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "EnumBooleanBody":
      case "EnumNumberBody":
      case "EnumStringBody":
      case "EnumSymbolBody":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isEnumMember(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "EnumBooleanMember":
      case "EnumNumberMember":
      case "EnumStringMember":
      case "EnumDefaultedMember":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isJSX(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "JSXAttribute":
      case "JSXClosingElement":
      case "JSXElement":
      case "JSXEmptyExpression":
      case "JSXExpressionContainer":
      case "JSXSpreadChild":
      case "JSXIdentifier":
      case "JSXMemberExpression":
      case "JSXNamespacedName":
      case "JSXOpeningElement":
      case "JSXSpreadAttribute":
      case "JSXText":
      case "JSXFragment":
      case "JSXOpeningFragment":
      case "JSXClosingFragment":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isMiscellaneous(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "Noop":
      case "Placeholder":
      case "V8IntrinsicIdentifier":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTypeScript(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "TSParameterProperty":
      case "TSDeclareFunction":
      case "TSDeclareMethod":
      case "TSQualifiedName":
      case "TSCallSignatureDeclaration":
      case "TSConstructSignatureDeclaration":
      case "TSPropertySignature":
      case "TSMethodSignature":
      case "TSIndexSignature":
      case "TSAnyKeyword":
      case "TSBooleanKeyword":
      case "TSBigIntKeyword":
      case "TSIntrinsicKeyword":
      case "TSNeverKeyword":
      case "TSNullKeyword":
      case "TSNumberKeyword":
      case "TSObjectKeyword":
      case "TSStringKeyword":
      case "TSSymbolKeyword":
      case "TSUndefinedKeyword":
      case "TSUnknownKeyword":
      case "TSVoidKeyword":
      case "TSThisType":
      case "TSFunctionType":
      case "TSConstructorType":
      case "TSTypeReference":
      case "TSTypePredicate":
      case "TSTypeQuery":
      case "TSTypeLiteral":
      case "TSArrayType":
      case "TSTupleType":
      case "TSOptionalType":
      case "TSRestType":
      case "TSNamedTupleMember":
      case "TSUnionType":
      case "TSIntersectionType":
      case "TSConditionalType":
      case "TSInferType":
      case "TSParenthesizedType":
      case "TSTypeOperator":
      case "TSIndexedAccessType":
      case "TSMappedType":
      case "TSTemplateLiteralType":
      case "TSLiteralType":
      case "TSExpressionWithTypeArguments":
      case "TSInterfaceDeclaration":
      case "TSInterfaceBody":
      case "TSTypeAliasDeclaration":
      case "TSInstantiationExpression":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSEnumBody":
      case "TSEnumDeclaration":
      case "TSEnumMember":
      case "TSModuleDeclaration":
      case "TSModuleBlock":
      case "TSImportType":
      case "TSImportEqualsDeclaration":
      case "TSExternalModuleReference":
      case "TSNonNullExpression":
      case "TSExportAssignment":
      case "TSNamespaceExportDeclaration":
      case "TSTypeAnnotation":
      case "TSTypeParameterInstantiation":
      case "TSTypeParameterDeclaration":
      case "TSTypeParameter":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSTypeElement(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "TSCallSignatureDeclaration":
      case "TSConstructSignatureDeclaration":
      case "TSPropertySignature":
      case "TSMethodSignature":
      case "TSIndexSignature":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSType(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "TSAnyKeyword":
      case "TSBooleanKeyword":
      case "TSBigIntKeyword":
      case "TSIntrinsicKeyword":
      case "TSNeverKeyword":
      case "TSNullKeyword":
      case "TSNumberKeyword":
      case "TSObjectKeyword":
      case "TSStringKeyword":
      case "TSSymbolKeyword":
      case "TSUndefinedKeyword":
      case "TSUnknownKeyword":
      case "TSVoidKeyword":
      case "TSThisType":
      case "TSFunctionType":
      case "TSConstructorType":
      case "TSTypeReference":
      case "TSTypePredicate":
      case "TSTypeQuery":
      case "TSTypeLiteral":
      case "TSArrayType":
      case "TSTupleType":
      case "TSOptionalType":
      case "TSRestType":
      case "TSUnionType":
      case "TSIntersectionType":
      case "TSConditionalType":
      case "TSInferType":
      case "TSParenthesizedType":
      case "TSTypeOperator":
      case "TSIndexedAccessType":
      case "TSMappedType":
      case "TSTemplateLiteralType":
      case "TSLiteralType":
      case "TSExpressionWithTypeArguments":
      case "TSImportType":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isTSBaseType(node2, opts) {
    if (!node2) return false;
    switch (node2.type) {
      case "TSAnyKeyword":
      case "TSBooleanKeyword":
      case "TSBigIntKeyword":
      case "TSIntrinsicKeyword":
      case "TSNeverKeyword":
      case "TSNullKeyword":
      case "TSNumberKeyword":
      case "TSObjectKeyword":
      case "TSStringKeyword":
      case "TSSymbolKeyword":
      case "TSUndefinedKeyword":
      case "TSUnknownKeyword":
      case "TSVoidKeyword":
      case "TSThisType":
      case "TSTemplateLiteralType":
      case "TSLiteralType":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isNumberLiteral(node2, opts) {
    (0, _deprecationWarning.default)("isNumberLiteral", "isNumericLiteral");
    if (!node2) return false;
    if (node2.type !== "NumberLiteral") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isRegexLiteral(node2, opts) {
    (0, _deprecationWarning.default)("isRegexLiteral", "isRegExpLiteral");
    if (!node2) return false;
    if (node2.type !== "RegexLiteral") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isRestProperty(node2, opts) {
    (0, _deprecationWarning.default)("isRestProperty", "isRestElement");
    if (!node2) return false;
    if (node2.type !== "RestProperty") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isSpreadProperty(node2, opts) {
    (0, _deprecationWarning.default)("isSpreadProperty", "isSpreadElement");
    if (!node2) return false;
    if (node2.type !== "SpreadProperty") return false;
    return opts == null || (0, _shallowEqual.default)(node2, opts);
  }
  function isModuleDeclaration(node2, opts) {
    (0, _deprecationWarning.default)("isModuleDeclaration", "isImportOrExportDeclaration");
    return isImportOrExportDeclaration(node2, opts);
  }
  return generated$3;
}
var hasRequiredMatchesPattern;
function requireMatchesPattern() {
  if (hasRequiredMatchesPattern) return matchesPattern;
  hasRequiredMatchesPattern = 1;
  Object.defineProperty(matchesPattern, "__esModule", {
    value: true
  });
  matchesPattern.default = matchesPattern$1;
  var _index = requireGenerated$3();
  function isMemberExpressionLike(node2) {
    return (0, _index.isMemberExpression)(node2) || (0, _index.isMetaProperty)(node2);
  }
  function matchesPattern$1(member, match, allowPartial) {
    if (!isMemberExpressionLike(member)) return false;
    const parts = Array.isArray(match) ? match : match.split(".");
    const nodes = [];
    let node2;
    for (node2 = member; isMemberExpressionLike(node2); node2 = (_object = node2.object) != null ? _object : node2.meta) {
      var _object;
      nodes.push(node2.property);
    }
    nodes.push(node2);
    if (nodes.length < parts.length) return false;
    if (!allowPartial && nodes.length > parts.length) return false;
    for (let i = 0, j = nodes.length - 1; i < parts.length; i++, j--) {
      const node3 = nodes[j];
      let value;
      if ((0, _index.isIdentifier)(node3)) {
        value = node3.name;
      } else if ((0, _index.isStringLiteral)(node3)) {
        value = node3.value;
      } else if ((0, _index.isThisExpression)(node3)) {
        value = "this";
      } else if ((0, _index.isSuper)(node3)) {
        value = "super";
      } else if ((0, _index.isPrivateName)(node3)) {
        value = "#" + node3.id.name;
      } else {
        return false;
      }
      if (parts[i] !== value) return false;
    }
    return true;
  }
  return matchesPattern;
}
var hasRequiredBuildMatchMemberExpression;
function requireBuildMatchMemberExpression() {
  if (hasRequiredBuildMatchMemberExpression) return buildMatchMemberExpression;
  hasRequiredBuildMatchMemberExpression = 1;
  Object.defineProperty(buildMatchMemberExpression, "__esModule", {
    value: true
  });
  buildMatchMemberExpression.default = buildMatchMemberExpression$1;
  var _matchesPattern = requireMatchesPattern();
  function buildMatchMemberExpression$1(match, allowPartial) {
    const parts = match.split(".");
    return (member) => (0, _matchesPattern.default)(member, parts, allowPartial);
  }
  return buildMatchMemberExpression;
}
var hasRequiredIsReactComponent;
function requireIsReactComponent() {
  if (hasRequiredIsReactComponent) return isReactComponent;
  hasRequiredIsReactComponent = 1;
  Object.defineProperty(isReactComponent, "__esModule", {
    value: true
  });
  isReactComponent.default = void 0;
  var _buildMatchMemberExpression = requireBuildMatchMemberExpression();
  const isReactComponent$1 = (0, _buildMatchMemberExpression.default)("React.Component");
  isReactComponent.default = isReactComponent$1;
  return isReactComponent;
}
var isCompatTag = {};
var hasRequiredIsCompatTag;
function requireIsCompatTag() {
  if (hasRequiredIsCompatTag) return isCompatTag;
  hasRequiredIsCompatTag = 1;
  Object.defineProperty(isCompatTag, "__esModule", {
    value: true
  });
  isCompatTag.default = isCompatTag$1;
  function isCompatTag$1(tagName) {
    return !!tagName && /^[a-z]/.test(tagName);
  }
  return isCompatTag;
}
var buildChildren = {};
var cleanJSXElementLiteralChild = {};
var generated$2 = {};
var lowercase = {};
var validate = {};
var definitions = {};
var core = {};
var is = {};
var isType = {};
var hasRequiredIsType;
function requireIsType() {
  if (hasRequiredIsType) return isType;
  hasRequiredIsType = 1;
  Object.defineProperty(isType, "__esModule", {
    value: true
  });
  isType.default = isType$1;
  var _index = requireDefinitions();
  function isType$1(nodeType, targetType) {
    if (nodeType === targetType) return true;
    if (nodeType == null) return false;
    if (_index.ALIAS_KEYS[targetType]) return false;
    const aliases = _index.FLIPPED_ALIAS_KEYS[targetType];
    if (aliases != null && aliases.includes(nodeType)) return true;
    return false;
  }
  return isType;
}
var isPlaceholderType = {};
var hasRequiredIsPlaceholderType;
function requireIsPlaceholderType() {
  if (hasRequiredIsPlaceholderType) return isPlaceholderType;
  hasRequiredIsPlaceholderType = 1;
  Object.defineProperty(isPlaceholderType, "__esModule", {
    value: true
  });
  isPlaceholderType.default = isPlaceholderType$1;
  var _index = requireDefinitions();
  function isPlaceholderType$1(placeholderType, targetType) {
    if (placeholderType === targetType) return true;
    const aliases = _index.PLACEHOLDERS_ALIAS[placeholderType];
    if (aliases != null && aliases.includes(targetType)) return true;
    return false;
  }
  return isPlaceholderType;
}
var hasRequiredIs;
function requireIs() {
  if (hasRequiredIs) return is;
  hasRequiredIs = 1;
  Object.defineProperty(is, "__esModule", {
    value: true
  });
  is.default = is$1;
  var _shallowEqual = requireShallowEqual();
  var _isType = requireIsType();
  var _isPlaceholderType = requireIsPlaceholderType();
  var _index = requireDefinitions();
  function is$1(type, node2, opts) {
    if (!node2) return false;
    const matches = (0, _isType.default)(node2.type, type);
    if (!matches) {
      if (!opts && node2.type === "Placeholder" && type in _index.FLIPPED_ALIAS_KEYS) {
        return (0, _isPlaceholderType.default)(node2.expectedNode, type);
      }
      return false;
    }
    if (opts === void 0) {
      return true;
    } else {
      return (0, _shallowEqual.default)(node2, opts);
    }
  }
  return is;
}
var isValidIdentifier = {};
var lib$4 = {};
var identifier = {};
var hasRequiredIdentifier;
function requireIdentifier() {
  if (hasRequiredIdentifier) return identifier;
  hasRequiredIdentifier = 1;
  Object.defineProperty(identifier, "__esModule", {
    value: true
  });
  identifier.isIdentifierChar = isIdentifierChar;
  identifier.isIdentifierName = isIdentifierName;
  identifier.isIdentifierStart = isIdentifierStart;
  let nonASCIIidentifierStartChars = "------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------";
  let nonASCIIidentifierChars = "------------------------------------------------------------------------------------------------------------------------------------------------------";
  const nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
  const nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
  nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
  const astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 7, 25, 39, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 5, 57, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 24, 43, 261, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 33, 24, 3, 24, 45, 74, 6, 0, 67, 12, 65, 1, 2, 0, 15, 4, 10, 7381, 42, 31, 98, 114, 8702, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 208, 30, 2, 2, 2, 1, 2, 6, 3, 4, 10, 1, 225, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4381, 3, 5773, 3, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 8489];
  const astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 78, 5, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 199, 7, 137, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 55, 9, 266, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 233, 0, 3, 0, 8, 1, 6, 0, 475, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
  function isInAstralSet(code, set) {
    let pos = 65536;
    for (let i = 0, length = set.length; i < length; i += 2) {
      pos += set[i];
      if (pos > code) return false;
      pos += set[i + 1];
      if (pos >= code) return true;
    }
    return false;
  }
  function isIdentifierStart(code) {
    if (code < 65) return code === 36;
    if (code <= 90) return true;
    if (code < 97) return code === 95;
    if (code <= 122) return true;
    if (code <= 65535) {
      return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
    }
    return isInAstralSet(code, astralIdentifierStartCodes);
  }
  function isIdentifierChar(code) {
    if (code < 48) return code === 36;
    if (code < 58) return true;
    if (code < 65) return false;
    if (code <= 90) return true;
    if (code < 97) return code === 95;
    if (code <= 122) return true;
    if (code <= 65535) {
      return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
    }
    return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
  }
  function isIdentifierName(name) {
    let isFirst = true;
    for (let i = 0; i < name.length; i++) {
      let cp = name.charCodeAt(i);
      if ((cp & 64512) === 55296 && i + 1 < name.length) {
        const trail = name.charCodeAt(++i);
        if ((trail & 64512) === 56320) {
          cp = 65536 + ((cp & 1023) << 10) + (trail & 1023);
        }
      }
      if (isFirst) {
        isFirst = false;
        if (!isIdentifierStart(cp)) {
          return false;
        }
      } else if (!isIdentifierChar(cp)) {
        return false;
      }
    }
    return !isFirst;
  }
  return identifier;
}
var keyword = {};
var hasRequiredKeyword;
function requireKeyword() {
  if (hasRequiredKeyword) return keyword;
  hasRequiredKeyword = 1;
  Object.defineProperty(keyword, "__esModule", {
    value: true
  });
  keyword.isKeyword = isKeyword;
  keyword.isReservedWord = isReservedWord;
  keyword.isStrictBindOnlyReservedWord = isStrictBindOnlyReservedWord;
  keyword.isStrictBindReservedWord = isStrictBindReservedWord;
  keyword.isStrictReservedWord = isStrictReservedWord;
  const reservedWords = {
    keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
    strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
    strictBind: ["eval", "arguments"]
  };
  const keywords = new Set(reservedWords.keyword);
  const reservedWordsStrictSet = new Set(reservedWords.strict);
  const reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
  function isReservedWord(word, inModule) {
    return inModule && word === "await" || word === "enum";
  }
  function isStrictReservedWord(word, inModule) {
    return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
  }
  function isStrictBindOnlyReservedWord(word) {
    return reservedWordsStrictBindSet.has(word);
  }
  function isStrictBindReservedWord(word, inModule) {
    return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
  }
  function isKeyword(word) {
    return keywords.has(word);
  }
  return keyword;
}
var hasRequiredLib$6;
function requireLib$6() {
  if (hasRequiredLib$6) return lib$4;
  hasRequiredLib$6 = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", {
      value: true
    });
    Object.defineProperty(exports$1, "isIdentifierChar", {
      enumerable: true,
      get: function() {
        return _identifier.isIdentifierChar;
      }
    });
    Object.defineProperty(exports$1, "isIdentifierName", {
      enumerable: true,
      get: function() {
        return _identifier.isIdentifierName;
      }
    });
    Object.defineProperty(exports$1, "isIdentifierStart", {
      enumerable: true,
      get: function() {
        return _identifier.isIdentifierStart;
      }
    });
    Object.defineProperty(exports$1, "isKeyword", {
      enumerable: true,
      get: function() {
        return _keyword.isKeyword;
      }
    });
    Object.defineProperty(exports$1, "isReservedWord", {
      enumerable: true,
      get: function() {
        return _keyword.isReservedWord;
      }
    });
    Object.defineProperty(exports$1, "isStrictBindOnlyReservedWord", {
      enumerable: true,
      get: function() {
        return _keyword.isStrictBindOnlyReservedWord;
      }
    });
    Object.defineProperty(exports$1, "isStrictBindReservedWord", {
      enumerable: true,
      get: function() {
        return _keyword.isStrictBindReservedWord;
      }
    });
    Object.defineProperty(exports$1, "isStrictReservedWord", {
      enumerable: true,
      get: function() {
        return _keyword.isStrictReservedWord;
      }
    });
    var _identifier = requireIdentifier();
    var _keyword = requireKeyword();
  })(lib$4);
  return lib$4;
}
var hasRequiredIsValidIdentifier;
function requireIsValidIdentifier() {
  if (hasRequiredIsValidIdentifier) return isValidIdentifier;
  hasRequiredIsValidIdentifier = 1;
  Object.defineProperty(isValidIdentifier, "__esModule", {
    value: true
  });
  isValidIdentifier.default = isValidIdentifier$1;
  var _helperValidatorIdentifier = requireLib$6();
  function isValidIdentifier$1(name, reserved = true) {
    if (typeof name !== "string") return false;
    if (reserved) {
      if ((0, _helperValidatorIdentifier.isKeyword)(name) || (0, _helperValidatorIdentifier.isStrictReservedWord)(name, true)) {
        return false;
      }
    }
    return (0, _helperValidatorIdentifier.isIdentifierName)(name);
  }
  return isValidIdentifier;
}
var lib$3 = {};
var hasRequiredLib$5;
function requireLib$5() {
  if (hasRequiredLib$5) return lib$3;
  hasRequiredLib$5 = 1;
  Object.defineProperty(lib$3, "__esModule", {
    value: true
  });
  lib$3.readCodePoint = readCodePoint;
  lib$3.readInt = readInt;
  lib$3.readStringContents = readStringContents;
  var _isDigit = function isDigit(code) {
    return code >= 48 && code <= 57;
  };
  const forbiddenNumericSeparatorSiblings = {
    decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),
    hex: /* @__PURE__ */ new Set([46, 88, 95, 120])
  };
  const isAllowedNumericSeparatorSibling = {
    bin: (ch) => ch === 48 || ch === 49,
    oct: (ch) => ch >= 48 && ch <= 55,
    dec: (ch) => ch >= 48 && ch <= 57,
    hex: (ch) => ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102
  };
  function readStringContents(type, input, pos, lineStart, curLine, errors) {
    const initialPos = pos;
    const initialLineStart = lineStart;
    const initialCurLine = curLine;
    let out = "";
    let firstInvalidLoc = null;
    let chunkStart = pos;
    const {
      length
    } = input;
    for (; ; ) {
      if (pos >= length) {
        errors.unterminated(initialPos, initialLineStart, initialCurLine);
        out += input.slice(chunkStart, pos);
        break;
      }
      const ch = input.charCodeAt(pos);
      if (isStringEnd(type, ch, input, pos)) {
        out += input.slice(chunkStart, pos);
        break;
      }
      if (ch === 92) {
        out += input.slice(chunkStart, pos);
        const res = readEscapedChar(input, pos, lineStart, curLine, type === "template", errors);
        if (res.ch === null && !firstInvalidLoc) {
          firstInvalidLoc = {
            pos,
            lineStart,
            curLine
          };
        } else {
          out += res.ch;
        }
        ({
          pos,
          lineStart,
          curLine
        } = res);
        chunkStart = pos;
      } else if (ch === 8232 || ch === 8233) {
        ++pos;
        ++curLine;
        lineStart = pos;
      } else if (ch === 10 || ch === 13) {
        if (type === "template") {
          out += input.slice(chunkStart, pos) + "\n";
          ++pos;
          if (ch === 13 && input.charCodeAt(pos) === 10) {
            ++pos;
          }
          ++curLine;
          chunkStart = lineStart = pos;
        } else {
          errors.unterminated(initialPos, initialLineStart, initialCurLine);
        }
      } else {
        ++pos;
      }
    }
    return {
      pos,
      str: out,
      firstInvalidLoc,
      lineStart,
      curLine,
      containsInvalid: !!firstInvalidLoc
    };
  }
  function isStringEnd(type, ch, input, pos) {
    if (type === "template") {
      return ch === 96 || ch === 36 && input.charCodeAt(pos + 1) === 123;
    }
    return ch === (type === "double" ? 34 : 39);
  }
  function readEscapedChar(input, pos, lineStart, curLine, inTemplate, errors) {
    const throwOnInvalid = !inTemplate;
    pos++;
    const res = (ch2) => ({
      pos,
      ch: ch2,
      lineStart,
      curLine
    });
    const ch = input.charCodeAt(pos++);
    switch (ch) {
      case 110:
        return res("\n");
      case 114:
        return res("\r");
      case 120: {
        let code;
        ({
          code,
          pos
        } = readHexChar(input, pos, lineStart, curLine, 2, false, throwOnInvalid, errors));
        return res(code === null ? null : String.fromCharCode(code));
      }
      case 117: {
        let code;
        ({
          code,
          pos
        } = readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors));
        return res(code === null ? null : String.fromCodePoint(code));
      }
      case 116:
        return res("	");
      case 98:
        return res("\b");
      case 118:
        return res("\v");
      case 102:
        return res("\f");
      case 13:
        if (input.charCodeAt(pos) === 10) {
          ++pos;
        }
      case 10:
        lineStart = pos;
        ++curLine;
      case 8232:
      case 8233:
        return res("");
      case 56:
      case 57:
        if (inTemplate) {
          return res(null);
        } else {
          errors.strictNumericEscape(pos - 1, lineStart, curLine);
        }
      default:
        if (ch >= 48 && ch <= 55) {
          const startPos = pos - 1;
          const match = /^[0-7]+/.exec(input.slice(startPos, pos + 2));
          let octalStr = match[0];
          let octal = parseInt(octalStr, 8);
          if (octal > 255) {
            octalStr = octalStr.slice(0, -1);
            octal = parseInt(octalStr, 8);
          }
          pos += octalStr.length - 1;
          const next = input.charCodeAt(pos);
          if (octalStr !== "0" || next === 56 || next === 57) {
            if (inTemplate) {
              return res(null);
            } else {
              errors.strictNumericEscape(startPos, lineStart, curLine);
            }
          }
          return res(String.fromCharCode(octal));
        }
        return res(String.fromCharCode(ch));
    }
  }
  function readHexChar(input, pos, lineStart, curLine, len, forceLen, throwOnInvalid, errors) {
    const initialPos = pos;
    let n;
    ({
      n,
      pos
    } = readInt(input, pos, lineStart, curLine, 16, len, forceLen, false, errors, !throwOnInvalid));
    if (n === null) {
      if (throwOnInvalid) {
        errors.invalidEscapeSequence(initialPos, lineStart, curLine);
      } else {
        pos = initialPos - 1;
      }
    }
    return {
      code: n,
      pos
    };
  }
  function readInt(input, pos, lineStart, curLine, radix, len, forceLen, allowNumSeparator, errors, bailOnError) {
    const start = pos;
    const forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;
    const isAllowedSibling = radix === 16 ? isAllowedNumericSeparatorSibling.hex : radix === 10 ? isAllowedNumericSeparatorSibling.dec : radix === 8 ? isAllowedNumericSeparatorSibling.oct : isAllowedNumericSeparatorSibling.bin;
    let invalid = false;
    let total = 0;
    for (let i = 0, e = len == null ? Infinity : len; i < e; ++i) {
      const code = input.charCodeAt(pos);
      let val;
      if (code === 95 && allowNumSeparator !== "bail") {
        const prev = input.charCodeAt(pos - 1);
        const next = input.charCodeAt(pos + 1);
        if (!allowNumSeparator) {
          if (bailOnError) return {
            n: null,
            pos
          };
          errors.numericSeparatorInEscapeSequence(pos, lineStart, curLine);
        } else if (Number.isNaN(next) || !isAllowedSibling(next) || forbiddenSiblings.has(prev) || forbiddenSiblings.has(next)) {
          if (bailOnError) return {
            n: null,
            pos
          };
          errors.unexpectedNumericSeparator(pos, lineStart, curLine);
        }
        ++pos;
        continue;
      }
      if (code >= 97) {
        val = code - 97 + 10;
      } else if (code >= 65) {
        val = code - 65 + 10;
      } else if (_isDigit(code)) {
        val = code - 48;
      } else {
        val = Infinity;
      }
      if (val >= radix) {
        if (val <= 9 && bailOnError) {
          return {
            n: null,
            pos
          };
        } else if (val <= 9 && errors.invalidDigit(pos, lineStart, curLine, radix)) {
          val = 0;
        } else if (forceLen) {
          val = 0;
          invalid = true;
        } else {
          break;
        }
      }
      ++pos;
      total = total * radix + val;
    }
    if (pos === start || len != null && pos - start !== len || invalid) {
      return {
        n: null,
        pos
      };
    }
    return {
      n: total,
      pos
    };
  }
  function readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors) {
    const ch = input.charCodeAt(pos);
    let code;
    if (ch === 123) {
      ++pos;
      ({
        code,
        pos
      } = readHexChar(input, pos, lineStart, curLine, input.indexOf("}", pos) - pos, true, throwOnInvalid, errors));
      ++pos;
      if (code !== null && code > 1114111) {
        if (throwOnInvalid) {
          errors.invalidCodePoint(pos, lineStart, curLine);
        } else {
          return {
            code: null,
            pos
          };
        }
      }
    } else {
      ({
        code,
        pos
      } = readHexChar(input, pos, lineStart, curLine, 4, false, throwOnInvalid, errors));
    }
    return {
      code,
      pos
    };
  }
  return lib$3;
}
var constants = {};
var hasRequiredConstants;
function requireConstants() {
  if (hasRequiredConstants) return constants;
  hasRequiredConstants = 1;
  Object.defineProperty(constants, "__esModule", {
    value: true
  });
  constants.UPDATE_OPERATORS = constants.UNARY_OPERATORS = constants.STRING_UNARY_OPERATORS = constants.STATEMENT_OR_BLOCK_KEYS = constants.NUMBER_UNARY_OPERATORS = constants.NUMBER_BINARY_OPERATORS = constants.LOGICAL_OPERATORS = constants.INHERIT_KEYS = constants.FOR_INIT_KEYS = constants.FLATTENABLE_KEYS = constants.EQUALITY_BINARY_OPERATORS = constants.COMPARISON_BINARY_OPERATORS = constants.COMMENT_KEYS = constants.BOOLEAN_UNARY_OPERATORS = constants.BOOLEAN_NUMBER_BINARY_OPERATORS = constants.BOOLEAN_BINARY_OPERATORS = constants.BINARY_OPERATORS = constants.ASSIGNMENT_OPERATORS = void 0;
  constants.STATEMENT_OR_BLOCK_KEYS = ["consequent", "body", "alternate"];
  constants.FLATTENABLE_KEYS = ["body", "expressions"];
  constants.FOR_INIT_KEYS = ["left", "init"];
  constants.COMMENT_KEYS = ["leadingComments", "trailingComments", "innerComments"];
  const LOGICAL_OPERATORS = constants.LOGICAL_OPERATORS = ["||", "&&", "??"];
  constants.UPDATE_OPERATORS = ["++", "--"];
  const BOOLEAN_NUMBER_BINARY_OPERATORS = constants.BOOLEAN_NUMBER_BINARY_OPERATORS = [">", "<", ">=", "<="];
  const EQUALITY_BINARY_OPERATORS = constants.EQUALITY_BINARY_OPERATORS = ["==", "===", "!=", "!=="];
  const COMPARISON_BINARY_OPERATORS = constants.COMPARISON_BINARY_OPERATORS = [...EQUALITY_BINARY_OPERATORS, "in", "instanceof"];
  const BOOLEAN_BINARY_OPERATORS = constants.BOOLEAN_BINARY_OPERATORS = [...COMPARISON_BINARY_OPERATORS, ...BOOLEAN_NUMBER_BINARY_OPERATORS];
  const NUMBER_BINARY_OPERATORS = constants.NUMBER_BINARY_OPERATORS = ["-", "/", "%", "*", "**", "&", "|", ">>", ">>>", "<<", "^"];
  constants.BINARY_OPERATORS = ["+", ...NUMBER_BINARY_OPERATORS, ...BOOLEAN_BINARY_OPERATORS, "|>"];
  constants.ASSIGNMENT_OPERATORS = ["=", "+=", ...NUMBER_BINARY_OPERATORS.map((op) => op + "="), ...LOGICAL_OPERATORS.map((op) => op + "=")];
  const BOOLEAN_UNARY_OPERATORS = constants.BOOLEAN_UNARY_OPERATORS = ["delete", "!"];
  const NUMBER_UNARY_OPERATORS = constants.NUMBER_UNARY_OPERATORS = ["+", "-", "~"];
  const STRING_UNARY_OPERATORS = constants.STRING_UNARY_OPERATORS = ["typeof"];
  constants.UNARY_OPERATORS = ["void", "throw", ...BOOLEAN_UNARY_OPERATORS, ...NUMBER_UNARY_OPERATORS, ...STRING_UNARY_OPERATORS];
  constants.INHERIT_KEYS = {
    optional: ["typeAnnotation", "typeParameters", "returnType"],
    force: ["start", "loc", "end"]
  };
  {
    constants.BLOCK_SCOPED_SYMBOL = /* @__PURE__ */ Symbol.for("var used to be block scoped");
    constants.NOT_LOCAL_BINDING = /* @__PURE__ */ Symbol.for("should not be considered a local binding");
  }
  return constants;
}
var utils = {};
var hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils) return utils;
  hasRequiredUtils = 1;
  Object.defineProperty(utils, "__esModule", {
    value: true
  });
  utils.allExpandedTypes = utils.VISITOR_KEYS = utils.NODE_UNION_SHAPES__PRIVATE = utils.NODE_PARENT_VALIDATIONS = utils.NODE_FIELDS = utils.FLIPPED_ALIAS_KEYS = utils.DEPRECATED_KEYS = utils.BUILDER_KEYS = utils.ALIAS_KEYS = void 0;
  utils.arrayOf = arrayOf;
  utils.arrayOfType = arrayOfType;
  utils.assertEach = assertEach;
  utils.assertNodeOrValueType = assertNodeOrValueType;
  utils.assertNodeType = assertNodeType;
  utils.assertOneOf = assertOneOf;
  utils.assertOptionalChainStart = assertOptionalChainStart;
  utils.assertShape = assertShape;
  utils.assertValueType = assertValueType;
  utils.chain = chain;
  utils.default = defineType;
  utils.defineAliasedType = defineAliasedType;
  utils.validate = validate2;
  utils.validateArrayOfType = validateArrayOfType;
  utils.validateOptional = validateOptional;
  utils.validateOptionalType = validateOptionalType;
  utils.validateType = validateType;
  var _is = requireIs();
  var _validate = requireValidate();
  const VISITOR_KEYS = utils.VISITOR_KEYS = {};
  const ALIAS_KEYS = utils.ALIAS_KEYS = {};
  const FLIPPED_ALIAS_KEYS = utils.FLIPPED_ALIAS_KEYS = {};
  const NODE_FIELDS = utils.NODE_FIELDS = {};
  const BUILDER_KEYS = utils.BUILDER_KEYS = {};
  const DEPRECATED_KEYS = utils.DEPRECATED_KEYS = {};
  const NODE_PARENT_VALIDATIONS = utils.NODE_PARENT_VALIDATIONS = {};
  const NODE_UNION_SHAPES__PRIVATE = utils.NODE_UNION_SHAPES__PRIVATE = {};
  function getType(val) {
    if (Array.isArray(val)) {
      return "array";
    } else if (val === null) {
      return "null";
    } else {
      return typeof val;
    }
  }
  function validate2(validate22) {
    return {
      validate: validate22
    };
  }
  function validateType(...typeNames) {
    return validate2(assertNodeType(...typeNames));
  }
  function validateOptional(validate22) {
    return {
      validate: validate22,
      optional: true
    };
  }
  function validateOptionalType(...typeNames) {
    return {
      validate: assertNodeType(...typeNames),
      optional: true
    };
  }
  function arrayOf(elementType) {
    return chain(assertValueType("array"), assertEach(elementType));
  }
  function arrayOfType(...typeNames) {
    return arrayOf(assertNodeType(...typeNames));
  }
  function validateArrayOfType(...typeNames) {
    return validate2(arrayOfType(...typeNames));
  }
  function assertEach(callback) {
    const childValidator = process.env.BABEL_TYPES_8_BREAKING ? _validate.validateChild : () => {
    };
    function validator(node2, key, val) {
      if (!Array.isArray(val)) return;
      let i = 0;
      const subKey = {
        toString() {
          return `${key}[${i}]`;
        }
      };
      for (; i < val.length; i++) {
        const v = val[i];
        callback(node2, subKey, v);
        childValidator(node2, subKey, v);
      }
    }
    validator.each = callback;
    return validator;
  }
  function assertOneOf(...values) {
    function validate22(node2, key, val) {
      if (!values.includes(val)) {
        throw new TypeError(`Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`);
      }
    }
    validate22.oneOf = values;
    return validate22;
  }
  const allExpandedTypes = utils.allExpandedTypes = [];
  function assertNodeType(...types2) {
    const expandedTypes = /* @__PURE__ */ new Set();
    allExpandedTypes.push({
      types: types2,
      set: expandedTypes
    });
    function validate22(node2, key, val) {
      const valType = val == null ? void 0 : val.type;
      if (valType != null) {
        if (expandedTypes.has(valType)) {
          (0, _validate.validateChild)(node2, key, val);
          return;
        }
        if (valType === "Placeholder") {
          for (const type of types2) {
            if ((0, _is.default)(type, val)) {
              (0, _validate.validateChild)(node2, key, val);
              return;
            }
          }
        }
      }
      throw new TypeError(`Property ${key} of ${node2.type} expected node to be of a type ${JSON.stringify(types2)} but instead got ${JSON.stringify(valType)}`);
    }
    validate22.oneOfNodeTypes = types2;
    return validate22;
  }
  function assertNodeOrValueType(...types2) {
    function validate22(node2, key, val) {
      const primitiveType = getType(val);
      for (const type of types2) {
        if (primitiveType === type || (0, _is.default)(type, val)) {
          (0, _validate.validateChild)(node2, key, val);
          return;
        }
      }
      throw new TypeError(`Property ${key} of ${node2.type} expected node to be of a type ${JSON.stringify(types2)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
    }
    validate22.oneOfNodeOrValueTypes = types2;
    return validate22;
  }
  function assertValueType(type) {
    function validate22(node2, key, val) {
      if (getType(val) === type) {
        return;
      }
      throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
    }
    validate22.type = type;
    return validate22;
  }
  function assertShape(shape) {
    const keys = Object.keys(shape);
    function validate22(node2, key, val) {
      const errors = [];
      for (const property of keys) {
        try {
          (0, _validate.validateField)(node2, property, val[property], shape[property]);
        } catch (error) {
          if (error instanceof TypeError) {
            errors.push(error.message);
            continue;
          }
          throw error;
        }
      }
      if (errors.length) {
        throw new TypeError(`Property ${key} of ${node2.type} expected to have the following:
${errors.join("\n")}`);
      }
    }
    validate22.shapeOf = shape;
    return validate22;
  }
  function assertOptionalChainStart() {
    function validate22(node2) {
      var _current;
      let current = node2;
      while (node2) {
        const {
          type
        } = current;
        if (type === "OptionalCallExpression") {
          if (current.optional) return;
          current = current.callee;
          continue;
        }
        if (type === "OptionalMemberExpression") {
          if (current.optional) return;
          current = current.object;
          continue;
        }
        break;
      }
      throw new TypeError(`Non-optional ${node2.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ${(_current = current) == null ? void 0 : _current.type}`);
    }
    return validate22;
  }
  function chain(...fns) {
    function validate22(...args) {
      for (const fn of fns) {
        fn(...args);
      }
    }
    validate22.chainOf = fns;
    if (fns.length >= 2 && "type" in fns[0] && fns[0].type === "array" && !("each" in fns[1])) {
      throw new Error(`An assertValueType("array") validator can only be followed by an assertEach(...) validator.`);
    }
    return validate22;
  }
  const validTypeOpts = /* @__PURE__ */ new Set(["aliases", "builder", "deprecatedAlias", "fields", "inherits", "visitor", "validate", "unionShape"]);
  const validFieldKeys = /* @__PURE__ */ new Set(["default", "optional", "deprecated", "validate"]);
  const store = {};
  function defineAliasedType(...aliases) {
    return (type, opts = {}) => {
      let defined = opts.aliases;
      if (!defined) {
        var _store$opts$inherits$;
        if (opts.inherits) defined = (_store$opts$inherits$ = store[opts.inherits].aliases) == null ? void 0 : _store$opts$inherits$.slice();
        defined != null ? defined : defined = [];
        opts.aliases = defined;
      }
      const additional = aliases.filter((a) => !defined.includes(a));
      defined.unshift(...additional);
      defineType(type, opts);
    };
  }
  function defineType(type, opts = {}) {
    const inherits2 = opts.inherits && store[opts.inherits] || {};
    let fields = opts.fields;
    if (!fields) {
      fields = {};
      if (inherits2.fields) {
        const keys = Object.getOwnPropertyNames(inherits2.fields);
        for (const key of keys) {
          const field = inherits2.fields[key];
          const def = field.default;
          if (Array.isArray(def) ? def.length > 0 : def && typeof def === "object") {
            throw new Error("field defaults can only be primitives or empty arrays currently");
          }
          fields[key] = {
            default: Array.isArray(def) ? [] : def,
            optional: field.optional,
            deprecated: field.deprecated,
            validate: field.validate
          };
        }
      }
    }
    const visitor = opts.visitor || inherits2.visitor || [];
    const aliases = opts.aliases || inherits2.aliases || [];
    const builder2 = opts.builder || inherits2.builder || opts.visitor || [];
    for (const k of Object.keys(opts)) {
      if (!validTypeOpts.has(k)) {
        throw new Error(`Unknown type option "${k}" on ${type}`);
      }
    }
    if (opts.deprecatedAlias) {
      DEPRECATED_KEYS[opts.deprecatedAlias] = type;
    }
    for (const key of visitor.concat(builder2)) {
      fields[key] = fields[key] || {};
    }
    for (const key of Object.keys(fields)) {
      const field = fields[key];
      if (field.default !== void 0 && !builder2.includes(key)) {
        field.optional = true;
      }
      if (field.default === void 0) {
        field.default = null;
      } else if (!field.validate && field.default != null) {
        field.validate = assertValueType(getType(field.default));
      }
      for (const k of Object.keys(field)) {
        if (!validFieldKeys.has(k)) {
          throw new Error(`Unknown field key "${k}" on ${type}.${key}`);
        }
      }
    }
    VISITOR_KEYS[type] = opts.visitor = visitor;
    BUILDER_KEYS[type] = opts.builder = builder2;
    NODE_FIELDS[type] = opts.fields = fields;
    ALIAS_KEYS[type] = opts.aliases = aliases;
    aliases.forEach((alias) => {
      FLIPPED_ALIAS_KEYS[alias] = FLIPPED_ALIAS_KEYS[alias] || [];
      FLIPPED_ALIAS_KEYS[alias].push(type);
    });
    if (opts.validate) {
      NODE_PARENT_VALIDATIONS[type] = opts.validate;
    }
    if (opts.unionShape) {
      NODE_UNION_SHAPES__PRIVATE[type] = opts.unionShape;
    }
    store[type] = opts;
  }
  return utils;
}
var hasRequiredCore;
function requireCore() {
  if (hasRequiredCore) return core;
  hasRequiredCore = 1;
  Object.defineProperty(core, "__esModule", {
    value: true
  });
  core.patternLikeCommon = core.importAttributes = core.functionTypeAnnotationCommon = core.functionDeclarationCommon = core.functionCommon = core.classMethodOrPropertyUnionShapeCommon = core.classMethodOrPropertyCommon = core.classMethodOrDeclareMethodCommon = void 0;
  var _is = requireIs();
  var _isValidIdentifier = requireIsValidIdentifier();
  var _helperValidatorIdentifier = requireLib$6();
  var _helperStringParser = requireLib$5();
  var _index = requireConstants();
  var _utils = requireUtils();
  const classMethodOrPropertyUnionShapeCommon = (allowPrivateName = false) => ({
    unionShape: {
      discriminator: "computed",
      shapes: [{
        name: "computed",
        value: [true],
        properties: {
          key: {
            validate: (0, _utils.assertNodeType)("Expression")
          }
        }
      }, {
        name: "nonComputed",
        value: [false],
        properties: {
          key: {
            validate: allowPrivateName ? (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "PrivateName") : (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral")
          }
        }
      }]
    }
  });
  core.classMethodOrPropertyUnionShapeCommon = classMethodOrPropertyUnionShapeCommon;
  const defineType = (0, _utils.defineAliasedType)("Standardized");
  defineType("ArrayExpression", {
    fields: {
      elements: {
        validate: (0, _utils.arrayOf)((0, _utils.assertNodeOrValueType)("null", "Expression", "SpreadElement")),
        default: !process.env.BABEL_TYPES_8_BREAKING ? [] : void 0
      }
    },
    visitor: ["elements"],
    aliases: ["Expression"]
  });
  defineType("AssignmentExpression", {
    fields: {
      operator: {
        validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)("string") : Object.assign((function() {
          const identifier2 = (0, _utils.assertOneOf)(..._index.ASSIGNMENT_OPERATORS);
          const pattern = (0, _utils.assertOneOf)("=");
          return function(node2, key, val) {
            const validator = (0, _is.default)("Pattern", node2.left) ? pattern : identifier2;
            validator(node2, key, val);
          };
        })(), {
          oneOf: _index.ASSIGNMENT_OPERATORS
        })
      },
      left: {
        validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("LVal", "OptionalMemberExpression") : (0, _utils.assertNodeType)("Identifier", "MemberExpression", "OptionalMemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
      },
      right: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    },
    builder: ["operator", "left", "right"],
    visitor: ["left", "right"],
    aliases: ["Expression"]
  });
  defineType("BinaryExpression", {
    builder: ["operator", "left", "right"],
    fields: {
      operator: {
        validate: (0, _utils.assertOneOf)(..._index.BINARY_OPERATORS)
      },
      left: {
        validate: (function() {
          const expression = (0, _utils.assertNodeType)("Expression");
          const inOp = (0, _utils.assertNodeType)("Expression", "PrivateName");
          const validator = Object.assign(function(node2, key, val) {
            const validator2 = node2.operator === "in" ? inOp : expression;
            validator2(node2, key, val);
          }, {
            oneOfNodeTypes: ["Expression", "PrivateName"]
          });
          return validator;
        })()
      },
      right: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    },
    visitor: ["left", "right"],
    aliases: ["Binary", "Expression"]
  });
  defineType("InterpreterDirective", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, _utils.assertValueType)("string")
      }
    }
  });
  defineType("Directive", {
    visitor: ["value"],
    fields: {
      value: {
        validate: (0, _utils.assertNodeType)("DirectiveLiteral")
      }
    }
  });
  defineType("DirectiveLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, _utils.assertValueType)("string")
      }
    }
  });
  defineType("BlockStatement", {
    builder: ["body", "directives"],
    visitor: ["directives", "body"],
    fields: {
      directives: {
        validate: (0, _utils.arrayOfType)("Directive"),
        default: []
      },
      body: (0, _utils.validateArrayOfType)("Statement")
    },
    aliases: ["Scopable", "BlockParent", "Block", "Statement"]
  });
  defineType("BreakStatement", {
    visitor: ["label"],
    fields: {
      label: {
        validate: (0, _utils.assertNodeType)("Identifier"),
        optional: true
      }
    },
    aliases: ["Statement", "Terminatorless", "CompletionStatement"]
  });
  defineType("CallExpression", {
    visitor: ["callee", "typeParameters", "typeArguments", "arguments"],
    builder: ["callee", "arguments"],
    aliases: ["Expression"],
    fields: Object.assign({
      callee: {
        validate: (0, _utils.assertNodeType)("Expression", "Super", "V8IntrinsicIdentifier")
      },
      arguments: (0, _utils.validateArrayOfType)("Expression", "SpreadElement", "ArgumentPlaceholder"),
      typeArguments: {
        validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),
        optional: true
      }
    }, process.env.BABEL_TYPES_8_BREAKING ? {} : {
      optional: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      typeParameters: {
        validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),
        optional: true
      }
    })
  });
  defineType("CatchClause", {
    visitor: ["param", "body"],
    fields: {
      param: {
        validate: (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"),
        optional: true
      },
      body: {
        validate: (0, _utils.assertNodeType)("BlockStatement")
      }
    },
    aliases: ["Scopable", "BlockParent"]
  });
  defineType("ConditionalExpression", {
    visitor: ["test", "consequent", "alternate"],
    fields: {
      test: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      consequent: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      alternate: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    },
    aliases: ["Expression", "Conditional"]
  });
  defineType("ContinueStatement", {
    visitor: ["label"],
    fields: {
      label: {
        validate: (0, _utils.assertNodeType)("Identifier"),
        optional: true
      }
    },
    aliases: ["Statement", "Terminatorless", "CompletionStatement"]
  });
  defineType("DebuggerStatement", {
    aliases: ["Statement"]
  });
  defineType("DoWhileStatement", {
    builder: ["test", "body"],
    visitor: ["body", "test"],
    fields: {
      test: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      body: {
        validate: (0, _utils.assertNodeType)("Statement")
      }
    },
    aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"]
  });
  defineType("EmptyStatement", {
    aliases: ["Statement"]
  });
  defineType("ExpressionStatement", {
    visitor: ["expression"],
    fields: {
      expression: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    },
    aliases: ["Statement", "ExpressionWrapper"]
  });
  defineType("File", {
    builder: ["program", "comments", "tokens"],
    visitor: ["program"],
    fields: {
      program: {
        validate: (0, _utils.assertNodeType)("Program")
      },
      comments: {
        validate: !process.env.BABEL_TYPES_8_BREAKING ? Object.assign(() => {
        }, {
          each: {
            oneOfNodeTypes: ["CommentBlock", "CommentLine"]
          }
        }) : (0, _utils.assertEach)((0, _utils.assertNodeType)("CommentBlock", "CommentLine")),
        optional: true
      },
      tokens: {
        validate: (0, _utils.assertEach)(Object.assign(() => {
        }, {
          type: "any"
        })),
        optional: true
      }
    }
  });
  defineType("ForInStatement", {
    visitor: ["left", "right", "body"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
    fields: {
      left: {
        validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("VariableDeclaration", "LVal") : (0, _utils.assertNodeType)("VariableDeclaration", "Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
      },
      right: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      body: {
        validate: (0, _utils.assertNodeType)("Statement")
      }
    }
  });
  defineType("ForStatement", {
    visitor: ["init", "test", "update", "body"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"],
    fields: {
      init: {
        validate: (0, _utils.assertNodeType)("VariableDeclaration", "Expression"),
        optional: true
      },
      test: {
        validate: (0, _utils.assertNodeType)("Expression"),
        optional: true
      },
      update: {
        validate: (0, _utils.assertNodeType)("Expression"),
        optional: true
      },
      body: {
        validate: (0, _utils.assertNodeType)("Statement")
      }
    }
  });
  const functionCommon = () => ({
    params: (0, _utils.validateArrayOfType)("FunctionParameter"),
    generator: {
      default: false
    },
    async: {
      default: false
    }
  });
  core.functionCommon = functionCommon;
  const functionTypeAnnotationCommon = () => ({
    returnType: {
      validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
      optional: true
    },
    typeParameters: {
      validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
      optional: true
    }
  });
  core.functionTypeAnnotationCommon = functionTypeAnnotationCommon;
  const functionDeclarationCommon = () => Object.assign({}, functionCommon(), {
    declare: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    },
    id: {
      validate: (0, _utils.assertNodeType)("Identifier"),
      optional: true
    }
  });
  core.functionDeclarationCommon = functionDeclarationCommon;
  defineType("FunctionDeclaration", {
    builder: ["id", "params", "body", "generator", "async"],
    visitor: ["id", "typeParameters", "params", "predicate", "returnType", "body"],
    fields: Object.assign({}, functionDeclarationCommon(), functionTypeAnnotationCommon(), {
      body: {
        validate: (0, _utils.assertNodeType)("BlockStatement")
      },
      predicate: {
        validate: (0, _utils.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
        optional: true
      }
    }),
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Statement", "Pureish", "Declaration"],
    validate: !process.env.BABEL_TYPES_8_BREAKING ? void 0 : (function() {
      const identifier2 = (0, _utils.assertNodeType)("Identifier");
      return function(parent, key, node2) {
        if (!(0, _is.default)("ExportDefaultDeclaration", parent)) {
          identifier2(node2, "id", node2.id);
        }
      };
    })()
  });
  defineType("FunctionExpression", {
    inherits: "FunctionDeclaration",
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
    fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {
      id: {
        validate: (0, _utils.assertNodeType)("Identifier"),
        optional: true
      },
      body: {
        validate: (0, _utils.assertNodeType)("BlockStatement")
      },
      predicate: {
        validate: (0, _utils.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
        optional: true
      }
    })
  });
  const patternLikeCommon = () => ({
    typeAnnotation: {
      validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
      optional: true
    },
    optional: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    },
    decorators: {
      validate: (0, _utils.arrayOfType)("Decorator"),
      optional: true
    }
  });
  core.patternLikeCommon = patternLikeCommon;
  defineType("Identifier", {
    builder: ["name"],
    visitor: ["typeAnnotation", "decorators"],
    aliases: ["Expression", "FunctionParameter", "PatternLike", "LVal", "TSEntityName"],
    fields: Object.assign({}, patternLikeCommon(), {
      name: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertValueType)("string"), Object.assign(function(node2, key, val) {
          if (!(0, _isValidIdentifier.default)(val, false)) {
            throw new TypeError(`"${val}" is not a valid identifier name`);
          }
        }, {
          type: "string"
        })) : (0, _utils.assertValueType)("string")
      }
    }),
    validate: process.env.BABEL_TYPES_8_BREAKING ? function(parent, key, node2) {
      const match = /\.(\w+)$/.exec(key.toString());
      if (!match) return;
      const [, parentKey] = match;
      const nonComp = {
        computed: false
      };
      if (parentKey === "property") {
        if ((0, _is.default)("MemberExpression", parent, nonComp)) return;
        if ((0, _is.default)("OptionalMemberExpression", parent, nonComp)) return;
      } else if (parentKey === "key") {
        if ((0, _is.default)("Property", parent, nonComp)) return;
        if ((0, _is.default)("Method", parent, nonComp)) return;
      } else if (parentKey === "exported") {
        if ((0, _is.default)("ExportSpecifier", parent)) return;
      } else if (parentKey === "imported") {
        if ((0, _is.default)("ImportSpecifier", parent, {
          imported: node2
        })) return;
      } else if (parentKey === "meta") {
        if ((0, _is.default)("MetaProperty", parent, {
          meta: node2
        })) return;
      }
      if (((0, _helperValidatorIdentifier.isKeyword)(node2.name) || (0, _helperValidatorIdentifier.isReservedWord)(node2.name, false)) && node2.name !== "this") {
        throw new TypeError(`"${node2.name}" is not a valid identifier`);
      }
    } : void 0
  });
  defineType("IfStatement", {
    visitor: ["test", "consequent", "alternate"],
    aliases: ["Statement", "Conditional"],
    fields: {
      test: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      consequent: {
        validate: (0, _utils.assertNodeType)("Statement")
      },
      alternate: {
        optional: true,
        validate: (0, _utils.assertNodeType)("Statement")
      }
    }
  });
  defineType("LabeledStatement", {
    visitor: ["label", "body"],
    aliases: ["Statement"],
    fields: {
      label: {
        validate: (0, _utils.assertNodeType)("Identifier")
      },
      body: {
        validate: (0, _utils.assertNodeType)("Statement")
      }
    }
  });
  defineType("StringLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, _utils.assertValueType)("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  defineType("NumericLiteral", {
    builder: ["value"],
    deprecatedAlias: "NumberLiteral",
    fields: {
      value: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("number"), Object.assign(function(node2, key, val) {
        }, {
          type: "number"
        }))
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  defineType("NullLiteral", {
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  defineType("BooleanLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, _utils.assertValueType)("boolean")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  defineType("RegExpLiteral", {
    builder: ["pattern", "flags"],
    deprecatedAlias: "RegexLiteral",
    aliases: ["Expression", "Pureish", "Literal"],
    fields: {
      pattern: {
        validate: (0, _utils.assertValueType)("string")
      },
      flags: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertValueType)("string"), Object.assign(function(node2, key, val) {
          const invalid = /[^dgimsuvy]/.exec(val);
          if (invalid) {
            throw new TypeError(`"${invalid[0]}" is not a valid RegExp flag`);
          }
        }, {
          type: "string"
        })) : (0, _utils.assertValueType)("string"),
        default: ""
      }
    }
  });
  defineType("LogicalExpression", {
    builder: ["operator", "left", "right"],
    visitor: ["left", "right"],
    aliases: ["Binary", "Expression"],
    fields: {
      operator: {
        validate: (0, _utils.assertOneOf)(..._index.LOGICAL_OPERATORS)
      },
      left: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      right: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    }
  });
  defineType("MemberExpression", {
    builder: ["object", "property", "computed", ...!process.env.BABEL_TYPES_8_BREAKING ? ["optional"] : []],
    visitor: ["object", "property"],
    aliases: ["Expression", "LVal", "PatternLike"],
    unionShape: {
      discriminator: "computed",
      shapes: [{
        name: "computed",
        value: [true],
        properties: {
          property: {
            validate: (0, _utils.assertNodeType)("Expression")
          }
        }
      }, {
        name: "nonComputed",
        value: [false],
        properties: {
          property: {
            validate: (0, _utils.assertNodeType)("Identifier", "PrivateName")
          }
        }
      }]
    },
    fields: Object.assign({
      object: {
        validate: (0, _utils.assertNodeType)("Expression", "Super")
      },
      property: {
        validate: (function() {
          const normal = (0, _utils.assertNodeType)("Identifier", "PrivateName");
          const computed = (0, _utils.assertNodeType)("Expression");
          const validator = function(node2, key, val) {
            const validator2 = node2.computed ? computed : normal;
            validator2(node2, key, val);
          };
          validator.oneOfNodeTypes = ["Expression", "Identifier", "PrivateName"];
          return validator;
        })()
      },
      computed: {
        default: false
      }
    }, !process.env.BABEL_TYPES_8_BREAKING ? {
      optional: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      }
    } : {})
  });
  defineType("NewExpression", {
    inherits: "CallExpression"
  });
  defineType("Program", {
    visitor: ["directives", "body"],
    builder: ["body", "directives", "sourceType", "interpreter"],
    fields: {
      sourceType: {
        validate: (0, _utils.assertOneOf)("script", "module"),
        default: "script"
      },
      interpreter: {
        validate: (0, _utils.assertNodeType)("InterpreterDirective"),
        default: null,
        optional: true
      },
      directives: {
        validate: (0, _utils.arrayOfType)("Directive"),
        default: []
      },
      body: (0, _utils.validateArrayOfType)("Statement")
    },
    aliases: ["Scopable", "BlockParent", "Block"]
  });
  defineType("ObjectExpression", {
    visitor: ["properties"],
    aliases: ["Expression"],
    fields: {
      properties: (0, _utils.validateArrayOfType)("ObjectMethod", "ObjectProperty", "SpreadElement")
    }
  });
  defineType("ObjectMethod", Object.assign({
    builder: ["kind", "key", "params", "body", "computed", "generator", "async"],
    visitor: ["decorators", "key", "typeParameters", "params", "returnType", "body"]
  }, classMethodOrPropertyUnionShapeCommon(), {
    fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {
      kind: Object.assign({
        validate: (0, _utils.assertOneOf)("method", "get", "set")
      }, !process.env.BABEL_TYPES_8_BREAKING ? {
        default: "method"
      } : {}),
      computed: {
        default: false
      },
      key: {
        validate: (function() {
          const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral");
          const computed = (0, _utils.assertNodeType)("Expression");
          const validator = function(node2, key, val) {
            const validator2 = node2.computed ? computed : normal;
            validator2(node2, key, val);
          };
          validator.oneOfNodeTypes = ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"];
          return validator;
        })()
      },
      decorators: {
        validate: (0, _utils.arrayOfType)("Decorator"),
        optional: true
      },
      body: {
        validate: (0, _utils.assertNodeType)("BlockStatement")
      }
    }),
    aliases: ["UserWhitespacable", "Function", "Scopable", "BlockParent", "FunctionParent", "Method", "ObjectMember"]
  }));
  defineType("ObjectProperty", {
    builder: ["key", "value", "computed", "shorthand", ...!process.env.BABEL_TYPES_8_BREAKING ? ["decorators"] : []],
    unionShape: {
      discriminator: "computed",
      shapes: [{
        name: "computed",
        value: [true],
        properties: {
          key: {
            validate: (0, _utils.assertNodeType)("Expression")
          }
        }
      }, {
        name: "nonComputed",
        value: [false],
        properties: {
          key: {
            validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName")
          }
        }
      }]
    },
    fields: {
      computed: {
        default: false
      },
      key: {
        validate: (function() {
          const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName");
          const computed = (0, _utils.assertNodeType)("Expression");
          const validator = Object.assign(function(node2, key, val) {
            const validator2 = node2.computed ? computed : normal;
            validator2(node2, key, val);
          }, {
            oneOfNodeTypes: ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"]
          });
          return validator;
        })()
      },
      value: {
        validate: (0, _utils.assertNodeType)("Expression", "PatternLike")
      },
      shorthand: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertValueType)("boolean"), Object.assign(function(node2, key, shorthand) {
          if (!shorthand) return;
          if (node2.computed) {
            throw new TypeError("Property shorthand of ObjectProperty cannot be true if computed is true");
          }
          if (!(0, _is.default)("Identifier", node2.key)) {
            throw new TypeError("Property shorthand of ObjectProperty cannot be true if key is not an Identifier");
          }
        }, {
          type: "boolean"
        })) : (0, _utils.assertValueType)("boolean"),
        default: false
      },
      decorators: {
        validate: (0, _utils.arrayOfType)("Decorator"),
        optional: true
      }
    },
    visitor: ["decorators", "key", "value"],
    aliases: ["UserWhitespacable", "Property", "ObjectMember"],
    validate: !process.env.BABEL_TYPES_8_BREAKING ? void 0 : (function() {
      const pattern = (0, _utils.assertNodeType)("Identifier", "Pattern", "TSAsExpression", "TSSatisfiesExpression", "TSNonNullExpression", "TSTypeAssertion");
      const expression = (0, _utils.assertNodeType)("Expression");
      return function(parent, key, node2) {
        const validator = (0, _is.default)("ObjectPattern", parent) ? pattern : expression;
        validator(node2, "value", node2.value);
      };
    })()
  });
  defineType("RestElement", {
    visitor: ["argument", "typeAnnotation"],
    builder: ["argument"],
    aliases: ["FunctionParameter", "PatternLike", "LVal"],
    deprecatedAlias: "RestProperty",
    fields: Object.assign({}, patternLikeCommon(), {
      argument: {
        validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression", "RestElement", "AssignmentPattern") : (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
      }
    }),
    validate: process.env.BABEL_TYPES_8_BREAKING ? function(parent, key) {
      const match = /(\w+)\[(\d+)\]/.exec(key.toString());
      if (!match) throw new Error("Internal Babel error: malformed key.");
      const [, listKey, index] = match;
      if (parent[listKey].length > +index + 1) {
        throw new TypeError(`RestElement must be last element of ${listKey}`);
      }
    } : void 0
  });
  defineType("ReturnStatement", {
    visitor: ["argument"],
    aliases: ["Statement", "Terminatorless", "CompletionStatement"],
    fields: {
      argument: {
        validate: (0, _utils.assertNodeType)("Expression"),
        optional: true
      }
    }
  });
  defineType("SequenceExpression", {
    visitor: ["expressions"],
    fields: {
      expressions: (0, _utils.validateArrayOfType)("Expression")
    },
    aliases: ["Expression"]
  });
  defineType("ParenthesizedExpression", {
    visitor: ["expression"],
    aliases: ["Expression", "ExpressionWrapper"],
    fields: {
      expression: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    }
  });
  defineType("SwitchCase", {
    visitor: ["test", "consequent"],
    fields: {
      test: {
        validate: (0, _utils.assertNodeType)("Expression"),
        optional: true
      },
      consequent: (0, _utils.validateArrayOfType)("Statement")
    }
  });
  defineType("SwitchStatement", {
    visitor: ["discriminant", "cases"],
    aliases: ["Statement", "BlockParent", "Scopable"],
    fields: {
      discriminant: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      cases: (0, _utils.validateArrayOfType)("SwitchCase")
    }
  });
  defineType("ThisExpression", {
    aliases: ["Expression"]
  });
  defineType("ThrowStatement", {
    visitor: ["argument"],
    aliases: ["Statement", "Terminatorless", "CompletionStatement"],
    fields: {
      argument: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    }
  });
  defineType("TryStatement", {
    visitor: ["block", "handler", "finalizer"],
    aliases: ["Statement"],
    fields: {
      block: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertNodeType)("BlockStatement"), Object.assign(function(node2) {
          if (!node2.handler && !node2.finalizer) {
            throw new TypeError("TryStatement expects either a handler or finalizer, or both");
          }
        }, {
          oneOfNodeTypes: ["BlockStatement"]
        })) : (0, _utils.assertNodeType)("BlockStatement")
      },
      handler: {
        optional: true,
        validate: (0, _utils.assertNodeType)("CatchClause")
      },
      finalizer: {
        optional: true,
        validate: (0, _utils.assertNodeType)("BlockStatement")
      }
    }
  });
  defineType("UnaryExpression", {
    builder: ["operator", "argument", "prefix"],
    fields: {
      prefix: {
        default: true
      },
      argument: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      operator: {
        validate: (0, _utils.assertOneOf)(..._index.UNARY_OPERATORS)
      }
    },
    visitor: ["argument"],
    aliases: ["UnaryLike", "Expression"]
  });
  defineType("UpdateExpression", {
    builder: ["operator", "argument", "prefix"],
    fields: {
      prefix: {
        default: false
      },
      argument: {
        validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("Expression") : (0, _utils.assertNodeType)("Identifier", "MemberExpression")
      },
      operator: {
        validate: (0, _utils.assertOneOf)(..._index.UPDATE_OPERATORS)
      }
    },
    visitor: ["argument"],
    aliases: ["Expression"]
  });
  defineType("VariableDeclaration", {
    builder: ["kind", "declarations"],
    visitor: ["declarations"],
    aliases: ["Statement", "Declaration"],
    fields: {
      declare: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      kind: {
        validate: (0, _utils.assertOneOf)("var", "let", "const", "using", "await using")
      },
      declarations: (0, _utils.validateArrayOfType)("VariableDeclarator")
    },
    validate: process.env.BABEL_TYPES_8_BREAKING ? (() => {
      const withoutInit = (0, _utils.assertNodeType)("Identifier", "Placeholder");
      const constOrLetOrVar = (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern", "Placeholder");
      const usingOrAwaitUsing = (0, _utils.assertNodeType)("Identifier", "VoidPattern", "Placeholder");
      return function(parent, key, node2) {
        const {
          kind,
          declarations
        } = node2;
        const parentIsForX = (0, _is.default)("ForXStatement", parent, {
          left: node2
        });
        if (parentIsForX) {
          if (declarations.length !== 1) {
            throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${parent.type}`);
          }
        }
        for (const decl of declarations) {
          if (kind === "const" || kind === "let" || kind === "var") {
            if (!parentIsForX && !decl.init) {
              withoutInit(decl, "id", decl.id);
            } else {
              constOrLetOrVar(decl, "id", decl.id);
            }
          } else {
            usingOrAwaitUsing(decl, "id", decl.id);
          }
        }
      };
    })() : void 0
  });
  defineType("VariableDeclarator", {
    visitor: ["id", "init"],
    fields: {
      id: {
        validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("LVal", "VoidPattern") : (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern", "VoidPattern")
      },
      definite: {
        optional: true,
        validate: (0, _utils.assertValueType)("boolean")
      },
      init: {
        optional: true,
        validate: (0, _utils.assertNodeType)("Expression")
      }
    }
  });
  defineType("WhileStatement", {
    visitor: ["test", "body"],
    aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"],
    fields: {
      test: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      body: {
        validate: (0, _utils.assertNodeType)("Statement")
      }
    }
  });
  defineType("WithStatement", {
    visitor: ["object", "body"],
    aliases: ["Statement"],
    fields: {
      object: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      body: {
        validate: (0, _utils.assertNodeType)("Statement")
      }
    }
  });
  defineType("AssignmentPattern", {
    visitor: ["left", "right", "decorators"],
    builder: ["left", "right"],
    aliases: ["FunctionParameter", "Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, patternLikeCommon(), {
      left: {
        validate: (0, _utils.assertNodeType)("Identifier", "ObjectPattern", "ArrayPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
      },
      right: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      decorators: {
        validate: (0, _utils.arrayOfType)("Decorator"),
        optional: true
      }
    })
  });
  defineType("ArrayPattern", {
    visitor: ["elements", "typeAnnotation"],
    builder: ["elements"],
    aliases: ["FunctionParameter", "Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, patternLikeCommon(), {
      elements: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)("null", "PatternLike")))
      }
    })
  });
  defineType("ArrowFunctionExpression", {
    builder: ["params", "body", "async"],
    visitor: ["typeParameters", "params", "predicate", "returnType", "body"],
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
    fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {
      expression: {
        validate: (0, _utils.assertValueType)("boolean")
      },
      body: {
        validate: (0, _utils.assertNodeType)("BlockStatement", "Expression")
      },
      predicate: {
        validate: (0, _utils.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
        optional: true
      }
    })
  });
  defineType("ClassBody", {
    visitor: ["body"],
    fields: {
      body: (0, _utils.validateArrayOfType)("ClassMethod", "ClassPrivateMethod", "ClassProperty", "ClassPrivateProperty", "ClassAccessorProperty", "TSDeclareMethod", "TSIndexSignature", "StaticBlock")
    }
  });
  defineType("ClassExpression", {
    builder: ["id", "superClass", "body", "decorators"],
    visitor: ["decorators", "id", "typeParameters", "superClass", "superTypeParameters", "mixins", "implements", "body"],
    aliases: ["Scopable", "Class", "Expression"],
    fields: {
      id: {
        validate: (0, _utils.assertNodeType)("Identifier"),
        optional: true
      },
      typeParameters: {
        validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
        optional: true
      },
      body: {
        validate: (0, _utils.assertNodeType)("ClassBody")
      },
      superClass: {
        optional: true,
        validate: (0, _utils.assertNodeType)("Expression")
      },
      ["superTypeParameters"]: {
        validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: true
      },
      implements: {
        validate: (0, _utils.arrayOfType)("TSExpressionWithTypeArguments", "ClassImplements"),
        optional: true
      },
      decorators: {
        validate: (0, _utils.arrayOfType)("Decorator"),
        optional: true
      },
      mixins: {
        validate: (0, _utils.assertNodeType)("InterfaceExtends"),
        optional: true
      }
    }
  });
  defineType("ClassDeclaration", {
    inherits: "ClassExpression",
    aliases: ["Scopable", "Class", "Statement", "Declaration"],
    fields: {
      id: {
        validate: (0, _utils.assertNodeType)("Identifier"),
        optional: true
      },
      typeParameters: {
        validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
        optional: true
      },
      body: {
        validate: (0, _utils.assertNodeType)("ClassBody")
      },
      superClass: {
        optional: true,
        validate: (0, _utils.assertNodeType)("Expression")
      },
      ["superTypeParameters"]: {
        validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: true
      },
      implements: {
        validate: (0, _utils.arrayOfType)("TSExpressionWithTypeArguments", "ClassImplements"),
        optional: true
      },
      decorators: {
        validate: (0, _utils.arrayOfType)("Decorator"),
        optional: true
      },
      mixins: {
        validate: (0, _utils.assertNodeType)("InterfaceExtends"),
        optional: true
      },
      declare: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      abstract: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      }
    },
    validate: !process.env.BABEL_TYPES_8_BREAKING ? void 0 : (function() {
      const identifier2 = (0, _utils.assertNodeType)("Identifier");
      return function(parent, key, node2) {
        if (!(0, _is.default)("ExportDefaultDeclaration", parent)) {
          identifier2(node2, "id", node2.id);
        }
      };
    })()
  });
  const importAttributes = core.importAttributes = {
    attributes: {
      optional: true,
      validate: (0, _utils.arrayOfType)("ImportAttribute")
    },
    assertions: {
      deprecated: true,
      optional: true,
      validate: (0, _utils.arrayOfType)("ImportAttribute")
    }
  };
  defineType("ExportAllDeclaration", {
    builder: ["source"],
    visitor: ["source", "attributes", "assertions"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
    fields: Object.assign({
      source: {
        validate: (0, _utils.assertNodeType)("StringLiteral")
      },
      exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value"))
    }, importAttributes)
  });
  defineType("ExportDefaultDeclaration", {
    visitor: ["declaration"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
    fields: {
      declaration: (0, _utils.validateType)("TSDeclareFunction", "FunctionDeclaration", "ClassDeclaration", "Expression"),
      exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("value"))
    }
  });
  defineType("ExportNamedDeclaration", {
    builder: ["declaration", "specifiers", "source"],
    visitor: ["declaration", "specifiers", "source", "attributes", "assertions"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
    fields: Object.assign({
      declaration: {
        optional: true,
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertNodeType)("Declaration"), Object.assign(function(node2, key, val) {
          if (val && node2.specifiers.length) {
            throw new TypeError("Only declaration or specifiers is allowed on ExportNamedDeclaration");
          }
          if (val && node2.source) {
            throw new TypeError("Cannot export a declaration from a source");
          }
        }, {
          oneOfNodeTypes: ["Declaration"]
        })) : (0, _utils.assertNodeType)("Declaration")
      }
    }, importAttributes, {
      specifiers: {
        default: [],
        validate: (0, _utils.arrayOf)((function() {
          const sourced = (0, _utils.assertNodeType)("ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier");
          const sourceless = (0, _utils.assertNodeType)("ExportSpecifier");
          if (!process.env.BABEL_TYPES_8_BREAKING) return sourced;
          return Object.assign(function(node2, key, val) {
            const validator = node2.source ? sourced : sourceless;
            validator(node2, key, val);
          }, {
            oneOfNodeTypes: ["ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier"]
          });
        })())
      },
      source: {
        validate: (0, _utils.assertNodeType)("StringLiteral"),
        optional: true
      },
      exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value"))
    })
  });
  defineType("ExportSpecifier", {
    visitor: ["local", "exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, _utils.assertNodeType)("Identifier")
      },
      exported: {
        validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")
      },
      exportKind: {
        validate: (0, _utils.assertOneOf)("type", "value"),
        optional: true
      }
    }
  });
  defineType("ForOfStatement", {
    visitor: ["left", "right", "body"],
    builder: ["left", "right", "body", "await"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
    fields: {
      left: {
        validate: (function() {
          if (!process.env.BABEL_TYPES_8_BREAKING) {
            return (0, _utils.assertNodeType)("VariableDeclaration", "LVal");
          }
          const declaration = (0, _utils.assertNodeType)("VariableDeclaration");
          const lval = (0, _utils.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression");
          return Object.assign(function(node2, key, val) {
            if ((0, _is.default)("VariableDeclaration", val)) {
              declaration(node2, key, val);
            } else {
              lval(node2, key, val);
            }
          }, {
            oneOfNodeTypes: ["VariableDeclaration", "Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression"]
          });
        })()
      },
      right: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      body: {
        validate: (0, _utils.assertNodeType)("Statement")
      },
      await: {
        default: false
      }
    }
  });
  defineType("ImportDeclaration", {
    builder: ["specifiers", "source"],
    visitor: ["specifiers", "source", "attributes", "assertions"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration"],
    fields: Object.assign({}, importAttributes, {
      module: {
        optional: true,
        validate: (0, _utils.assertValueType)("boolean")
      },
      phase: {
        default: null,
        validate: (0, _utils.assertOneOf)("source", "defer")
      },
      specifiers: (0, _utils.validateArrayOfType)("ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier"),
      source: {
        validate: (0, _utils.assertNodeType)("StringLiteral")
      },
      importKind: {
        validate: (0, _utils.assertOneOf)("type", "typeof", "value"),
        optional: true
      }
    })
  });
  defineType("ImportDefaultSpecifier", {
    visitor: ["local"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, _utils.assertNodeType)("Identifier")
      }
    }
  });
  defineType("ImportNamespaceSpecifier", {
    visitor: ["local"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, _utils.assertNodeType)("Identifier")
      }
    }
  });
  defineType("ImportSpecifier", {
    visitor: ["imported", "local"],
    builder: ["local", "imported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, _utils.assertNodeType)("Identifier")
      },
      imported: {
        validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")
      },
      importKind: {
        validate: (0, _utils.assertOneOf)("type", "typeof", "value"),
        optional: true
      }
    }
  });
  defineType("ImportExpression", {
    visitor: ["source", "options"],
    aliases: ["Expression"],
    fields: {
      phase: {
        default: null,
        validate: (0, _utils.assertOneOf)("source", "defer")
      },
      source: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      options: {
        validate: (0, _utils.assertNodeType)("Expression"),
        optional: true
      }
    }
  });
  defineType("MetaProperty", {
    visitor: ["meta", "property"],
    aliases: ["Expression"],
    fields: {
      meta: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertNodeType)("Identifier"), Object.assign(function(node2, key, val) {
          let property;
          switch (val.name) {
            case "function":
              property = "sent";
              break;
            case "new":
              property = "target";
              break;
            case "import":
              property = "meta";
              break;
          }
          if (!(0, _is.default)("Identifier", node2.property, {
            name: property
          })) {
            throw new TypeError("Unrecognised MetaProperty");
          }
        }, {
          oneOfNodeTypes: ["Identifier"]
        })) : (0, _utils.assertNodeType)("Identifier")
      },
      property: {
        validate: (0, _utils.assertNodeType)("Identifier")
      }
    }
  });
  const classMethodOrPropertyCommon = () => ({
    abstract: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    },
    accessibility: {
      validate: (0, _utils.assertOneOf)("public", "private", "protected"),
      optional: true
    },
    static: {
      default: false
    },
    override: {
      default: false
    },
    computed: {
      default: false
    },
    optional: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    },
    key: {
      validate: (0, _utils.chain)((function() {
        const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral");
        const computed = (0, _utils.assertNodeType)("Expression");
        return function(node2, key, val) {
          const validator = node2.computed ? computed : normal;
          validator(node2, key, val);
        };
      })(), (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression"))
    }
  });
  core.classMethodOrPropertyCommon = classMethodOrPropertyCommon;
  const classMethodOrDeclareMethodCommon = () => Object.assign({}, functionCommon(), classMethodOrPropertyCommon(), {
    params: (0, _utils.validateArrayOfType)("FunctionParameter", "TSParameterProperty"),
    kind: {
      validate: (0, _utils.assertOneOf)("get", "set", "method", "constructor"),
      default: "method"
    },
    access: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), (0, _utils.assertOneOf)("public", "private", "protected")),
      optional: true
    },
    decorators: {
      validate: (0, _utils.arrayOfType)("Decorator"),
      optional: true
    }
  });
  core.classMethodOrDeclareMethodCommon = classMethodOrDeclareMethodCommon;
  defineType("ClassMethod", Object.assign({
    aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method"],
    builder: ["kind", "key", "params", "body", "computed", "static", "generator", "async"],
    visitor: ["decorators", "key", "typeParameters", "params", "returnType", "body"]
  }, classMethodOrPropertyUnionShapeCommon(), {
    fields: Object.assign({}, classMethodOrDeclareMethodCommon(), functionTypeAnnotationCommon(), {
      body: {
        validate: (0, _utils.assertNodeType)("BlockStatement")
      }
    })
  }));
  defineType("ObjectPattern", {
    visitor: ["decorators", "properties", "typeAnnotation"],
    builder: ["properties"],
    aliases: ["FunctionParameter", "Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, patternLikeCommon(), {
      properties: (0, _utils.validateArrayOfType)("RestElement", "ObjectProperty")
    })
  });
  defineType("SpreadElement", {
    visitor: ["argument"],
    aliases: ["UnaryLike"],
    deprecatedAlias: "SpreadProperty",
    fields: {
      argument: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    }
  });
  defineType("Super", {
    aliases: ["Expression"]
  });
  defineType("TaggedTemplateExpression", {
    visitor: ["tag", "typeParameters", "quasi"],
    builder: ["tag", "quasi"],
    aliases: ["Expression"],
    fields: {
      tag: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      quasi: {
        validate: (0, _utils.assertNodeType)("TemplateLiteral")
      },
      ["typeParameters"]: {
        validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: true
      }
    }
  });
  defineType("TemplateElement", {
    builder: ["value", "tail"],
    fields: {
      value: {
        validate: (0, _utils.chain)((0, _utils.assertShape)({
          raw: {
            validate: (0, _utils.assertValueType)("string")
          },
          cooked: {
            validate: (0, _utils.assertValueType)("string"),
            optional: true
          }
        }), function templateElementCookedValidator(node2) {
          const raw = node2.value.raw;
          let unterminatedCalled = false;
          const error = () => {
            throw new Error("Internal @babel/types error.");
          };
          const {
            str,
            firstInvalidLoc
          } = (0, _helperStringParser.readStringContents)("template", raw, 0, 0, 0, {
            unterminated() {
              unterminatedCalled = true;
            },
            strictNumericEscape: error,
            invalidEscapeSequence: error,
            numericSeparatorInEscapeSequence: error,
            unexpectedNumericSeparator: error,
            invalidDigit: error,
            invalidCodePoint: error
          });
          if (!unterminatedCalled) throw new Error("Invalid raw");
          node2.value.cooked = firstInvalidLoc ? null : str;
        })
      },
      tail: {
        default: false
      }
    }
  });
  defineType("TemplateLiteral", {
    visitor: ["quasis", "expressions"],
    aliases: ["Expression", "Literal"],
    fields: {
      quasis: (0, _utils.validateArrayOfType)("TemplateElement"),
      expressions: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "TSType")), function(node2, key, val) {
          if (node2.quasis.length !== val.length + 1) {
            throw new TypeError(`Number of ${node2.type} quasis should be exactly one more than the number of expressions.
Expected ${val.length + 1} quasis but got ${node2.quasis.length}`);
          }
        })
      }
    }
  });
  defineType("YieldExpression", {
    builder: ["argument", "delegate"],
    visitor: ["argument"],
    aliases: ["Expression", "Terminatorless"],
    fields: {
      delegate: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertValueType)("boolean"), Object.assign(function(node2, key, val) {
          if (val && !node2.argument) {
            throw new TypeError("Property delegate of YieldExpression cannot be true if there is no argument");
          }
        }, {
          type: "boolean"
        })) : (0, _utils.assertValueType)("boolean"),
        default: false
      },
      argument: {
        optional: true,
        validate: (0, _utils.assertNodeType)("Expression")
      }
    }
  });
  defineType("AwaitExpression", {
    builder: ["argument"],
    visitor: ["argument"],
    aliases: ["Expression", "Terminatorless"],
    fields: {
      argument: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    }
  });
  defineType("Import", {
    aliases: ["Expression"]
  });
  defineType("BigIntLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, _utils.assertValueType)("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  defineType("ExportNamespaceSpecifier", {
    visitor: ["exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      exported: {
        validate: (0, _utils.assertNodeType)("Identifier")
      }
    }
  });
  defineType("OptionalMemberExpression", {
    builder: ["object", "property", "computed", "optional"],
    visitor: ["object", "property"],
    aliases: ["Expression"],
    fields: {
      object: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      property: {
        validate: (function() {
          const normal = (0, _utils.assertNodeType)("Identifier");
          const computed = (0, _utils.assertNodeType)("Expression");
          const validator = Object.assign(function(node2, key, val) {
            const validator2 = node2.computed ? computed : normal;
            validator2(node2, key, val);
          }, {
            oneOfNodeTypes: ["Expression", "Identifier"]
          });
          return validator;
        })()
      },
      computed: {
        default: false
      },
      optional: {
        validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)("boolean") : (0, _utils.chain)((0, _utils.assertValueType)("boolean"), (0, _utils.assertOptionalChainStart)())
      }
    }
  });
  defineType("OptionalCallExpression", {
    visitor: ["callee", "typeParameters", "typeArguments", "arguments"],
    builder: ["callee", "arguments", "optional"],
    aliases: ["Expression"],
    fields: Object.assign({
      callee: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      arguments: (0, _utils.validateArrayOfType)("Expression", "SpreadElement", "ArgumentPlaceholder"),
      optional: {
        validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)("boolean") : (0, _utils.chain)((0, _utils.assertValueType)("boolean"), (0, _utils.assertOptionalChainStart)())
      },
      typeArguments: {
        validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),
        optional: true
      }
    }, {
      typeParameters: {
        validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),
        optional: true
      }
    })
  });
  defineType("ClassProperty", Object.assign({
    visitor: ["decorators", "variance", "key", "typeAnnotation", "value"],
    builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
    aliases: ["Property"]
  }, classMethodOrPropertyUnionShapeCommon(), {
    fields: Object.assign({}, classMethodOrPropertyCommon(), {
      value: {
        validate: (0, _utils.assertNodeType)("Expression"),
        optional: true
      },
      definite: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      typeAnnotation: {
        validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: true
      },
      decorators: {
        validate: (0, _utils.arrayOfType)("Decorator"),
        optional: true
      },
      readonly: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      declare: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      variance: {
        validate: (0, _utils.assertNodeType)("Variance"),
        optional: true
      }
    })
  }));
  defineType("ClassAccessorProperty", Object.assign({
    visitor: ["decorators", "key", "typeAnnotation", "value"],
    builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
    aliases: ["Property", "Accessor"]
  }, classMethodOrPropertyUnionShapeCommon(true), {
    fields: Object.assign({}, classMethodOrPropertyCommon(), {
      key: {
        validate: (0, _utils.chain)((function() {
          const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "PrivateName");
          const computed = (0, _utils.assertNodeType)("Expression");
          return function(node2, key, val) {
            const validator = node2.computed ? computed : normal;
            validator(node2, key, val);
          };
        })(), (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression", "PrivateName"))
      },
      value: {
        validate: (0, _utils.assertNodeType)("Expression"),
        optional: true
      },
      definite: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      typeAnnotation: {
        validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: true
      },
      decorators: {
        validate: (0, _utils.arrayOfType)("Decorator"),
        optional: true
      },
      readonly: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      declare: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      variance: {
        validate: (0, _utils.assertNodeType)("Variance"),
        optional: true
      }
    })
  }));
  defineType("ClassPrivateProperty", {
    visitor: ["decorators", "variance", "key", "typeAnnotation", "value"],
    builder: ["key", "value", "decorators", "static"],
    aliases: ["Property", "Private"],
    fields: {
      key: {
        validate: (0, _utils.assertNodeType)("PrivateName")
      },
      value: {
        validate: (0, _utils.assertNodeType)("Expression"),
        optional: true
      },
      typeAnnotation: {
        validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: true
      },
      decorators: {
        validate: (0, _utils.arrayOfType)("Decorator"),
        optional: true
      },
      static: {
        validate: (0, _utils.assertValueType)("boolean"),
        default: false
      },
      readonly: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      optional: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      definite: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      variance: {
        validate: (0, _utils.assertNodeType)("Variance"),
        optional: true
      }
    }
  });
  defineType("ClassPrivateMethod", {
    builder: ["kind", "key", "params", "body", "static"],
    visitor: ["decorators", "key", "typeParameters", "params", "returnType", "body"],
    aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method", "Private"],
    fields: Object.assign({}, classMethodOrDeclareMethodCommon(), functionTypeAnnotationCommon(), {
      kind: {
        validate: (0, _utils.assertOneOf)("get", "set", "method"),
        default: "method"
      },
      key: {
        validate: (0, _utils.assertNodeType)("PrivateName")
      },
      body: {
        validate: (0, _utils.assertNodeType)("BlockStatement")
      }
    })
  });
  defineType("PrivateName", {
    visitor: ["id"],
    aliases: ["Private"],
    fields: {
      id: {
        validate: (0, _utils.assertNodeType)("Identifier")
      }
    }
  });
  defineType("StaticBlock", {
    visitor: ["body"],
    fields: {
      body: (0, _utils.validateArrayOfType)("Statement")
    },
    aliases: ["Scopable", "BlockParent", "FunctionParent"]
  });
  defineType("ImportAttribute", {
    visitor: ["key", "value"],
    fields: {
      key: {
        validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")
      },
      value: {
        validate: (0, _utils.assertNodeType)("StringLiteral")
      }
    }
  });
  return core;
}
var flow$1 = {};
var hasRequiredFlow$1;
function requireFlow$1() {
  if (hasRequiredFlow$1) return flow$1;
  hasRequiredFlow$1 = 1;
  var _core = requireCore();
  var _utils = requireUtils();
  const defineType = (0, _utils.defineAliasedType)("Flow");
  const defineInterfaceishType = (name) => {
    const isDeclareClass = name === "DeclareClass";
    defineType(name, {
      builder: ["id", "typeParameters", "extends", "body"],
      visitor: ["id", "typeParameters", "extends", ...isDeclareClass ? ["mixins", "implements"] : [], "body"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: Object.assign({
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
        extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends"))
      }, isDeclareClass ? {
        mixins: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),
        implements: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ClassImplements"))
      } : {}, {
        body: (0, _utils.validateType)("ObjectTypeAnnotation")
      })
    });
  };
  defineType("AnyTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  defineType("ArrayTypeAnnotation", {
    visitor: ["elementType"],
    aliases: ["FlowType"],
    fields: {
      elementType: (0, _utils.validateType)("FlowType")
    }
  });
  defineType("BooleanTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  defineType("BooleanLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
  });
  defineType("NullLiteralTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  defineType("ClassImplements", {
    visitor: ["id", "typeParameters"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
    }
  });
  defineInterfaceishType("DeclareClass");
  defineType("DeclareFunction", {
    builder: ["id"],
    visitor: ["id", "predicate"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      predicate: (0, _utils.validateOptionalType)("DeclaredPredicate")
    }
  });
  defineInterfaceishType("DeclareInterface");
  defineType("DeclareModule", {
    builder: ["id", "body", "kind"],
    visitor: ["id", "body"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, _utils.validateType)("Identifier", "StringLiteral"),
      body: (0, _utils.validateType)("BlockStatement"),
      kind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("CommonJS", "ES"))
    }
  });
  defineType("DeclareModuleExports", {
    visitor: ["typeAnnotation"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      typeAnnotation: (0, _utils.validateType)("TypeAnnotation")
    }
  });
  defineType("DeclareTypeAlias", {
    visitor: ["id", "typeParameters", "right"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
      right: (0, _utils.validateType)("FlowType")
    }
  });
  defineType("DeclareOpaqueType", {
    visitor: ["id", "typeParameters", "supertype"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
      supertype: (0, _utils.validateOptionalType)("FlowType"),
      impltype: (0, _utils.validateOptionalType)("FlowType")
    }
  });
  defineType("DeclareVariable", {
    visitor: ["id"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, _utils.validateType)("Identifier")
    }
  });
  defineType("DeclareExportDeclaration", {
    visitor: ["declaration", "specifiers", "source", "attributes"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: Object.assign({
      declaration: (0, _utils.validateOptionalType)("Flow"),
      specifiers: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ExportSpecifier", "ExportNamespaceSpecifier")),
      source: (0, _utils.validateOptionalType)("StringLiteral"),
      default: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
    }, _core.importAttributes)
  });
  defineType("DeclareExportAllDeclaration", {
    visitor: ["source", "attributes"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: Object.assign({
      source: (0, _utils.validateType)("StringLiteral"),
      exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value"))
    }, _core.importAttributes)
  });
  defineType("DeclaredPredicate", {
    visitor: ["value"],
    aliases: ["FlowPredicate"],
    fields: {
      value: (0, _utils.validateType)("Flow")
    }
  });
  defineType("ExistsTypeAnnotation", {
    aliases: ["FlowType"]
  });
  defineType("FunctionTypeAnnotation", {
    builder: ["typeParameters", "params", "rest", "returnType"],
    visitor: ["typeParameters", "this", "params", "rest", "returnType"],
    aliases: ["FlowType"],
    fields: {
      typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
      params: (0, _utils.validateArrayOfType)("FunctionTypeParam"),
      rest: (0, _utils.validateOptionalType)("FunctionTypeParam"),
      this: (0, _utils.validateOptionalType)("FunctionTypeParam"),
      returnType: (0, _utils.validateType)("FlowType")
    }
  });
  defineType("FunctionTypeParam", {
    visitor: ["name", "typeAnnotation"],
    fields: {
      name: (0, _utils.validateOptionalType)("Identifier"),
      typeAnnotation: (0, _utils.validateType)("FlowType"),
      optional: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
    }
  });
  defineType("GenericTypeAnnotation", {
    visitor: ["id", "typeParameters"],
    aliases: ["FlowType"],
    fields: {
      id: (0, _utils.validateType)("Identifier", "QualifiedTypeIdentifier"),
      typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
    }
  });
  defineType("InferredPredicate", {
    aliases: ["FlowPredicate"]
  });
  defineType("InterfaceExtends", {
    visitor: ["id", "typeParameters"],
    fields: {
      id: (0, _utils.validateType)("Identifier", "QualifiedTypeIdentifier"),
      typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
    }
  });
  defineInterfaceishType("InterfaceDeclaration");
  defineType("InterfaceTypeAnnotation", {
    visitor: ["extends", "body"],
    aliases: ["FlowType"],
    fields: {
      extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),
      body: (0, _utils.validateType)("ObjectTypeAnnotation")
    }
  });
  defineType("IntersectionTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
    }
  });
  defineType("MixedTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  defineType("EmptyTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  defineType("NullableTypeAnnotation", {
    visitor: ["typeAnnotation"],
    aliases: ["FlowType"],
    fields: {
      typeAnnotation: (0, _utils.validateType)("FlowType")
    }
  });
  defineType("NumberLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: (0, _utils.validate)((0, _utils.assertValueType)("number"))
    }
  });
  defineType("NumberTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  defineType("ObjectTypeAnnotation", {
    visitor: ["properties", "indexers", "callProperties", "internalSlots"],
    aliases: ["FlowType"],
    builder: ["properties", "indexers", "callProperties", "internalSlots", "exact"],
    fields: {
      properties: (0, _utils.validate)((0, _utils.arrayOfType)("ObjectTypeProperty", "ObjectTypeSpreadProperty")),
      indexers: {
        validate: (0, _utils.arrayOfType)("ObjectTypeIndexer"),
        optional: true,
        default: []
      },
      callProperties: {
        validate: (0, _utils.arrayOfType)("ObjectTypeCallProperty"),
        optional: true,
        default: []
      },
      internalSlots: {
        validate: (0, _utils.arrayOfType)("ObjectTypeInternalSlot"),
        optional: true,
        default: []
      },
      exact: {
        validate: (0, _utils.assertValueType)("boolean"),
        default: false
      },
      inexact: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
    }
  });
  defineType("ObjectTypeInternalSlot", {
    visitor: ["id", "value"],
    builder: ["id", "value", "optional", "static", "method"],
    aliases: ["UserWhitespacable"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      value: (0, _utils.validateType)("FlowType"),
      optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
      static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
      method: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
  });
  defineType("ObjectTypeCallProperty", {
    visitor: ["value"],
    aliases: ["UserWhitespacable"],
    fields: {
      value: (0, _utils.validateType)("FlowType"),
      static: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
  });
  defineType("ObjectTypeIndexer", {
    visitor: ["variance", "id", "key", "value"],
    builder: ["id", "key", "value", "variance"],
    aliases: ["UserWhitespacable"],
    fields: {
      id: (0, _utils.validateOptionalType)("Identifier"),
      key: (0, _utils.validateType)("FlowType"),
      value: (0, _utils.validateType)("FlowType"),
      static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
      variance: (0, _utils.validateOptionalType)("Variance")
    }
  });
  defineType("ObjectTypeProperty", {
    visitor: ["key", "value", "variance"],
    aliases: ["UserWhitespacable"],
    fields: {
      key: (0, _utils.validateType)("Identifier", "StringLiteral"),
      value: (0, _utils.validateType)("FlowType"),
      kind: (0, _utils.validate)((0, _utils.assertOneOf)("init", "get", "set")),
      static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
      proto: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
      optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
      variance: (0, _utils.validateOptionalType)("Variance"),
      method: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
  });
  defineType("ObjectTypeSpreadProperty", {
    visitor: ["argument"],
    aliases: ["UserWhitespacable"],
    fields: {
      argument: (0, _utils.validateType)("FlowType")
    }
  });
  defineType("OpaqueType", {
    visitor: ["id", "typeParameters", "supertype", "impltype"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
      supertype: (0, _utils.validateOptionalType)("FlowType"),
      impltype: (0, _utils.validateType)("FlowType")
    }
  });
  defineType("QualifiedTypeIdentifier", {
    visitor: ["qualification", "id"],
    builder: ["id", "qualification"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      qualification: (0, _utils.validateType)("Identifier", "QualifiedTypeIdentifier")
    }
  });
  defineType("StringLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: (0, _utils.validate)((0, _utils.assertValueType)("string"))
    }
  });
  defineType("StringTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  defineType("SymbolTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  defineType("ThisTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  defineType("TupleTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
    }
  });
  defineType("TypeofTypeAnnotation", {
    visitor: ["argument"],
    aliases: ["FlowType"],
    fields: {
      argument: (0, _utils.validateType)("FlowType")
    }
  });
  defineType("TypeAlias", {
    visitor: ["id", "typeParameters", "right"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
      right: (0, _utils.validateType)("FlowType")
    }
  });
  defineType("TypeAnnotation", {
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, _utils.validateType)("FlowType")
    }
  });
  defineType("TypeCastExpression", {
    visitor: ["expression", "typeAnnotation"],
    aliases: ["ExpressionWrapper", "Expression"],
    fields: {
      expression: (0, _utils.validateType)("Expression"),
      typeAnnotation: (0, _utils.validateType)("TypeAnnotation")
    }
  });
  defineType("TypeParameter", {
    visitor: ["bound", "default", "variance"],
    fields: {
      name: (0, _utils.validate)((0, _utils.assertValueType)("string")),
      bound: (0, _utils.validateOptionalType)("TypeAnnotation"),
      default: (0, _utils.validateOptionalType)("FlowType"),
      variance: (0, _utils.validateOptionalType)("Variance")
    }
  });
  defineType("TypeParameterDeclaration", {
    visitor: ["params"],
    fields: {
      params: (0, _utils.validate)((0, _utils.arrayOfType)("TypeParameter"))
    }
  });
  defineType("TypeParameterInstantiation", {
    visitor: ["params"],
    fields: {
      params: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
    }
  });
  defineType("UnionTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
    }
  });
  defineType("Variance", {
    builder: ["kind"],
    fields: {
      kind: (0, _utils.validate)((0, _utils.assertOneOf)("minus", "plus"))
    }
  });
  defineType("VoidTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  defineType("EnumDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "body"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      body: (0, _utils.validateType)("EnumBooleanBody", "EnumNumberBody", "EnumStringBody", "EnumSymbolBody")
    }
  });
  defineType("EnumBooleanBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
      members: (0, _utils.validateArrayOfType)("EnumBooleanMember"),
      hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
  });
  defineType("EnumNumberBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
      members: (0, _utils.validateArrayOfType)("EnumNumberMember"),
      hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
  });
  defineType("EnumStringBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
      members: (0, _utils.validateArrayOfType)("EnumStringMember", "EnumDefaultedMember"),
      hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
  });
  defineType("EnumSymbolBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      members: (0, _utils.validateArrayOfType)("EnumDefaultedMember"),
      hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
  });
  defineType("EnumBooleanMember", {
    aliases: ["EnumMember"],
    builder: ["id"],
    visitor: ["id", "init"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      init: (0, _utils.validateType)("BooleanLiteral")
    }
  });
  defineType("EnumNumberMember", {
    aliases: ["EnumMember"],
    visitor: ["id", "init"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      init: (0, _utils.validateType)("NumericLiteral")
    }
  });
  defineType("EnumStringMember", {
    aliases: ["EnumMember"],
    visitor: ["id", "init"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      init: (0, _utils.validateType)("StringLiteral")
    }
  });
  defineType("EnumDefaultedMember", {
    aliases: ["EnumMember"],
    visitor: ["id"],
    fields: {
      id: (0, _utils.validateType)("Identifier")
    }
  });
  defineType("IndexedAccessType", {
    visitor: ["objectType", "indexType"],
    aliases: ["FlowType"],
    fields: {
      objectType: (0, _utils.validateType)("FlowType"),
      indexType: (0, _utils.validateType)("FlowType")
    }
  });
  defineType("OptionalIndexedAccessType", {
    visitor: ["objectType", "indexType"],
    aliases: ["FlowType"],
    fields: {
      objectType: (0, _utils.validateType)("FlowType"),
      indexType: (0, _utils.validateType)("FlowType"),
      optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
  });
  return flow$1;
}
var jsx$1 = {};
var hasRequiredJsx$1;
function requireJsx$1() {
  if (hasRequiredJsx$1) return jsx$1;
  hasRequiredJsx$1 = 1;
  var _utils = requireUtils();
  const defineType = (0, _utils.defineAliasedType)("JSX");
  defineType("JSXAttribute", {
    visitor: ["name", "value"],
    aliases: ["Immutable"],
    fields: {
      name: {
        validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXNamespacedName")
      },
      value: {
        optional: true,
        validate: (0, _utils.assertNodeType)("JSXElement", "JSXFragment", "StringLiteral", "JSXExpressionContainer")
      }
    }
  });
  defineType("JSXClosingElement", {
    visitor: ["name"],
    aliases: ["Immutable"],
    fields: {
      name: {
        validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
      }
    }
  });
  defineType("JSXElement", {
    builder: ["openingElement", "closingElement", "children", "selfClosing"],
    visitor: ["openingElement", "children", "closingElement"],
    aliases: ["Immutable", "Expression"],
    fields: Object.assign({
      openingElement: {
        validate: (0, _utils.assertNodeType)("JSXOpeningElement")
      },
      closingElement: {
        optional: true,
        validate: (0, _utils.assertNodeType)("JSXClosingElement")
      },
      children: (0, _utils.validateArrayOfType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")
    }, {
      selfClosing: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      }
    })
  });
  defineType("JSXEmptyExpression", {});
  defineType("JSXExpressionContainer", {
    visitor: ["expression"],
    aliases: ["Immutable"],
    fields: {
      expression: {
        validate: (0, _utils.assertNodeType)("Expression", "JSXEmptyExpression")
      }
    }
  });
  defineType("JSXSpreadChild", {
    visitor: ["expression"],
    aliases: ["Immutable"],
    fields: {
      expression: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    }
  });
  defineType("JSXIdentifier", {
    builder: ["name"],
    fields: {
      name: {
        validate: (0, _utils.assertValueType)("string")
      }
    }
  });
  defineType("JSXMemberExpression", {
    visitor: ["object", "property"],
    fields: {
      object: {
        validate: (0, _utils.assertNodeType)("JSXMemberExpression", "JSXIdentifier")
      },
      property: {
        validate: (0, _utils.assertNodeType)("JSXIdentifier")
      }
    }
  });
  defineType("JSXNamespacedName", {
    visitor: ["namespace", "name"],
    fields: {
      namespace: {
        validate: (0, _utils.assertNodeType)("JSXIdentifier")
      },
      name: {
        validate: (0, _utils.assertNodeType)("JSXIdentifier")
      }
    }
  });
  defineType("JSXOpeningElement", {
    builder: ["name", "attributes", "selfClosing"],
    visitor: ["name", "typeParameters", "typeArguments", "attributes"],
    aliases: ["Immutable"],
    fields: Object.assign({
      name: {
        validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
      },
      selfClosing: {
        default: false
      },
      attributes: (0, _utils.validateArrayOfType)("JSXAttribute", "JSXSpreadAttribute"),
      typeArguments: {
        validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),
        optional: true
      }
    }, {
      typeParameters: {
        validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),
        optional: true
      }
    })
  });
  defineType("JSXSpreadAttribute", {
    visitor: ["argument"],
    fields: {
      argument: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    }
  });
  defineType("JSXText", {
    aliases: ["Immutable"],
    builder: ["value"],
    fields: {
      value: {
        validate: (0, _utils.assertValueType)("string")
      }
    }
  });
  defineType("JSXFragment", {
    builder: ["openingFragment", "closingFragment", "children"],
    visitor: ["openingFragment", "children", "closingFragment"],
    aliases: ["Immutable", "Expression"],
    fields: {
      openingFragment: {
        validate: (0, _utils.assertNodeType)("JSXOpeningFragment")
      },
      closingFragment: {
        validate: (0, _utils.assertNodeType)("JSXClosingFragment")
      },
      children: (0, _utils.validateArrayOfType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")
    }
  });
  defineType("JSXOpeningFragment", {
    aliases: ["Immutable"]
  });
  defineType("JSXClosingFragment", {
    aliases: ["Immutable"]
  });
  return jsx$1;
}
var misc = {};
var placeholders = {};
var hasRequiredPlaceholders;
function requirePlaceholders() {
  if (hasRequiredPlaceholders) return placeholders;
  hasRequiredPlaceholders = 1;
  Object.defineProperty(placeholders, "__esModule", {
    value: true
  });
  placeholders.PLACEHOLDERS_FLIPPED_ALIAS = placeholders.PLACEHOLDERS_ALIAS = placeholders.PLACEHOLDERS = void 0;
  var _utils = requireUtils();
  const PLACEHOLDERS = placeholders.PLACEHOLDERS = ["Identifier", "StringLiteral", "Expression", "Statement", "Declaration", "BlockStatement", "ClassBody", "Pattern"];
  const PLACEHOLDERS_ALIAS = placeholders.PLACEHOLDERS_ALIAS = {
    Declaration: ["Statement"],
    Pattern: ["PatternLike", "LVal"]
  };
  for (const type of PLACEHOLDERS) {
    const alias = _utils.ALIAS_KEYS[type];
    if (alias != null && alias.length) PLACEHOLDERS_ALIAS[type] = alias;
  }
  const PLACEHOLDERS_FLIPPED_ALIAS = placeholders.PLACEHOLDERS_FLIPPED_ALIAS = {};
  Object.keys(PLACEHOLDERS_ALIAS).forEach((type) => {
    PLACEHOLDERS_ALIAS[type].forEach((alias) => {
      if (!hasOwnProperty.call(PLACEHOLDERS_FLIPPED_ALIAS, alias)) {
        PLACEHOLDERS_FLIPPED_ALIAS[alias] = [];
      }
      PLACEHOLDERS_FLIPPED_ALIAS[alias].push(type);
    });
  });
  return placeholders;
}
var hasRequiredMisc;
function requireMisc() {
  if (hasRequiredMisc) return misc;
  hasRequiredMisc = 1;
  var _utils = requireUtils();
  var _placeholders = requirePlaceholders();
  var _core = requireCore();
  const defineType = (0, _utils.defineAliasedType)("Miscellaneous");
  {
    defineType("Noop", {
      visitor: []
    });
  }
  defineType("Placeholder", {
    visitor: [],
    builder: ["expectedNode", "name"],
    fields: Object.assign({
      name: {
        validate: (0, _utils.assertNodeType)("Identifier")
      },
      expectedNode: {
        validate: (0, _utils.assertOneOf)(..._placeholders.PLACEHOLDERS)
      }
    }, (0, _core.patternLikeCommon)())
  });
  defineType("V8IntrinsicIdentifier", {
    builder: ["name"],
    fields: {
      name: {
        validate: (0, _utils.assertValueType)("string")
      }
    }
  });
  return misc;
}
var experimental = {};
var hasRequiredExperimental;
function requireExperimental() {
  if (hasRequiredExperimental) return experimental;
  hasRequiredExperimental = 1;
  var _utils = requireUtils();
  (0, _utils.default)("ArgumentPlaceholder", {});
  (0, _utils.default)("BindExpression", {
    visitor: ["object", "callee"],
    aliases: ["Expression"],
    fields: !process.env.BABEL_TYPES_8_BREAKING ? {
      object: {
        validate: Object.assign(() => {
        }, {
          oneOfNodeTypes: ["Expression"]
        })
      },
      callee: {
        validate: Object.assign(() => {
        }, {
          oneOfNodeTypes: ["Expression"]
        })
      }
    } : {
      object: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      callee: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    }
  });
  (0, _utils.default)("Decorator", {
    visitor: ["expression"],
    fields: {
      expression: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    }
  });
  (0, _utils.default)("DoExpression", {
    visitor: ["body"],
    builder: ["body", "async"],
    aliases: ["Expression"],
    fields: {
      body: {
        validate: (0, _utils.assertNodeType)("BlockStatement")
      },
      async: {
        validate: (0, _utils.assertValueType)("boolean"),
        default: false
      }
    }
  });
  (0, _utils.default)("ExportDefaultSpecifier", {
    visitor: ["exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      exported: {
        validate: (0, _utils.assertNodeType)("Identifier")
      }
    }
  });
  (0, _utils.default)("RecordExpression", {
    visitor: ["properties"],
    aliases: ["Expression"],
    fields: {
      properties: (0, _utils.validateArrayOfType)("ObjectProperty", "SpreadElement")
    }
  });
  (0, _utils.default)("TupleExpression", {
    fields: {
      elements: {
        validate: (0, _utils.arrayOfType)("Expression", "SpreadElement"),
        default: []
      }
    },
    visitor: ["elements"],
    aliases: ["Expression"]
  });
  {
    (0, _utils.default)("DecimalLiteral", {
      builder: ["value"],
      fields: {
        value: {
          validate: (0, _utils.assertValueType)("string")
        }
      },
      aliases: ["Expression", "Pureish", "Literal", "Immutable"]
    });
  }
  (0, _utils.default)("ModuleExpression", {
    visitor: ["body"],
    fields: {
      body: {
        validate: (0, _utils.assertNodeType)("Program")
      }
    },
    aliases: ["Expression"]
  });
  (0, _utils.default)("TopicReference", {
    aliases: ["Expression"]
  });
  (0, _utils.default)("PipelineTopicExpression", {
    builder: ["expression"],
    visitor: ["expression"],
    fields: {
      expression: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    },
    aliases: ["Expression"]
  });
  (0, _utils.default)("PipelineBareFunction", {
    builder: ["callee"],
    visitor: ["callee"],
    fields: {
      callee: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    },
    aliases: ["Expression"]
  });
  (0, _utils.default)("PipelinePrimaryTopicReference", {
    aliases: ["Expression"]
  });
  (0, _utils.default)("VoidPattern", {
    aliases: ["Pattern", "PatternLike", "FunctionParameter"]
  });
  return experimental;
}
var typescript$1 = {};
var hasRequiredTypescript$1;
function requireTypescript$1() {
  if (hasRequiredTypescript$1) return typescript$1;
  hasRequiredTypescript$1 = 1;
  var _utils = requireUtils();
  var _core = requireCore();
  var _is = requireIs();
  const defineType = (0, _utils.defineAliasedType)("TypeScript");
  const bool = (0, _utils.assertValueType)("boolean");
  const tSFunctionTypeAnnotationCommon = () => ({
    returnType: {
      validate: (0, _utils.assertNodeType)("TSTypeAnnotation", "Noop"),
      optional: true
    },
    typeParameters: {
      validate: (0, _utils.assertNodeType)("TSTypeParameterDeclaration", "Noop"),
      optional: true
    }
  });
  defineType("TSParameterProperty", {
    aliases: ["LVal"],
    visitor: ["parameter"],
    fields: {
      accessibility: {
        validate: (0, _utils.assertOneOf)("public", "private", "protected"),
        optional: true
      },
      readonly: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      parameter: {
        validate: (0, _utils.assertNodeType)("Identifier", "AssignmentPattern")
      },
      override: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      decorators: {
        validate: (0, _utils.arrayOfType)("Decorator"),
        optional: true
      }
    }
  });
  defineType("TSDeclareFunction", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "params", "returnType"],
    fields: Object.assign({}, (0, _core.functionDeclarationCommon)(), tSFunctionTypeAnnotationCommon())
  });
  defineType("TSDeclareMethod", Object.assign({
    visitor: ["decorators", "key", "typeParameters", "params", "returnType"]
  }, (0, _core.classMethodOrPropertyUnionShapeCommon)(), {
    fields: Object.assign({}, (0, _core.classMethodOrDeclareMethodCommon)(), tSFunctionTypeAnnotationCommon())
  }));
  defineType("TSQualifiedName", {
    aliases: ["TSEntityName"],
    visitor: ["left", "right"],
    fields: {
      left: (0, _utils.validateType)("TSEntityName"),
      right: (0, _utils.validateType)("Identifier")
    }
  });
  const signatureDeclarationCommon = () => ({
    typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
    ["parameters"]: (0, _utils.validateArrayOfType)("ArrayPattern", "Identifier", "ObjectPattern", "RestElement"),
    ["typeAnnotation"]: (0, _utils.validateOptionalType)("TSTypeAnnotation")
  });
  const callConstructSignatureDeclaration = {
    aliases: ["TSTypeElement"],
    visitor: ["typeParameters", "parameters", "typeAnnotation"],
    fields: signatureDeclarationCommon()
  };
  defineType("TSCallSignatureDeclaration", callConstructSignatureDeclaration);
  defineType("TSConstructSignatureDeclaration", callConstructSignatureDeclaration);
  const namedTypeElementCommon = () => ({
    key: (0, _utils.validateType)("Expression"),
    computed: {
      default: false
    },
    optional: (0, _utils.validateOptional)(bool)
  });
  defineType("TSPropertySignature", {
    aliases: ["TSTypeElement"],
    visitor: ["key", "typeAnnotation"],
    fields: Object.assign({}, namedTypeElementCommon(), {
      readonly: (0, _utils.validateOptional)(bool),
      typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation"),
      kind: {
        optional: true,
        validate: (0, _utils.assertOneOf)("get", "set")
      }
    })
  });
  defineType("TSMethodSignature", {
    aliases: ["TSTypeElement"],
    visitor: ["key", "typeParameters", "parameters", "typeAnnotation"],
    fields: Object.assign({}, signatureDeclarationCommon(), namedTypeElementCommon(), {
      kind: {
        validate: (0, _utils.assertOneOf)("method", "get", "set")
      }
    })
  });
  defineType("TSIndexSignature", {
    aliases: ["TSTypeElement"],
    visitor: ["parameters", "typeAnnotation"],
    fields: {
      readonly: (0, _utils.validateOptional)(bool),
      static: (0, _utils.validateOptional)(bool),
      parameters: (0, _utils.validateArrayOfType)("Identifier"),
      typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation")
    }
  });
  const tsKeywordTypes = ["TSAnyKeyword", "TSBooleanKeyword", "TSBigIntKeyword", "TSIntrinsicKeyword", "TSNeverKeyword", "TSNullKeyword", "TSNumberKeyword", "TSObjectKeyword", "TSStringKeyword", "TSSymbolKeyword", "TSUndefinedKeyword", "TSUnknownKeyword", "TSVoidKeyword"];
  for (const type of tsKeywordTypes) {
    defineType(type, {
      aliases: ["TSType", "TSBaseType"],
      visitor: [],
      fields: {}
    });
  }
  defineType("TSThisType", {
    aliases: ["TSType", "TSBaseType"],
    visitor: [],
    fields: {}
  });
  const fnOrCtrBase = {
    aliases: ["TSType"],
    visitor: ["typeParameters", "parameters", "typeAnnotation"]
  };
  defineType("TSFunctionType", Object.assign({}, fnOrCtrBase, {
    fields: signatureDeclarationCommon()
  }));
  defineType("TSConstructorType", Object.assign({}, fnOrCtrBase, {
    fields: Object.assign({}, signatureDeclarationCommon(), {
      abstract: (0, _utils.validateOptional)(bool)
    })
  }));
  defineType("TSTypeReference", {
    aliases: ["TSType"],
    visitor: ["typeName", "typeParameters"],
    fields: {
      typeName: (0, _utils.validateType)("TSEntityName"),
      ["typeParameters"]: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
    }
  });
  defineType("TSTypePredicate", {
    aliases: ["TSType"],
    visitor: ["parameterName", "typeAnnotation"],
    builder: ["parameterName", "typeAnnotation", "asserts"],
    fields: {
      parameterName: (0, _utils.validateType)("Identifier", "TSThisType"),
      typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation"),
      asserts: (0, _utils.validateOptional)(bool)
    }
  });
  defineType("TSTypeQuery", {
    aliases: ["TSType"],
    visitor: ["exprName", "typeParameters"],
    fields: {
      exprName: (0, _utils.validateType)("TSEntityName", "TSImportType"),
      ["typeParameters"]: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
    }
  });
  defineType("TSTypeLiteral", {
    aliases: ["TSType"],
    visitor: ["members"],
    fields: {
      members: (0, _utils.validateArrayOfType)("TSTypeElement")
    }
  });
  defineType("TSArrayType", {
    aliases: ["TSType"],
    visitor: ["elementType"],
    fields: {
      elementType: (0, _utils.validateType)("TSType")
    }
  });
  defineType("TSTupleType", {
    aliases: ["TSType"],
    visitor: ["elementTypes"],
    fields: {
      elementTypes: (0, _utils.validateArrayOfType)("TSType", "TSNamedTupleMember")
    }
  });
  defineType("TSOptionalType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, _utils.validateType)("TSType")
    }
  });
  defineType("TSRestType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, _utils.validateType)("TSType")
    }
  });
  defineType("TSNamedTupleMember", {
    visitor: ["label", "elementType"],
    builder: ["label", "elementType", "optional"],
    fields: {
      label: (0, _utils.validateType)("Identifier"),
      optional: {
        validate: bool,
        default: false
      },
      elementType: (0, _utils.validateType)("TSType")
    }
  });
  const unionOrIntersection = {
    aliases: ["TSType"],
    visitor: ["types"],
    fields: {
      types: (0, _utils.validateArrayOfType)("TSType")
    }
  };
  defineType("TSUnionType", unionOrIntersection);
  defineType("TSIntersectionType", unionOrIntersection);
  defineType("TSConditionalType", {
    aliases: ["TSType"],
    visitor: ["checkType", "extendsType", "trueType", "falseType"],
    fields: {
      checkType: (0, _utils.validateType)("TSType"),
      extendsType: (0, _utils.validateType)("TSType"),
      trueType: (0, _utils.validateType)("TSType"),
      falseType: (0, _utils.validateType)("TSType")
    }
  });
  defineType("TSInferType", {
    aliases: ["TSType"],
    visitor: ["typeParameter"],
    fields: {
      typeParameter: (0, _utils.validateType)("TSTypeParameter")
    }
  });
  defineType("TSParenthesizedType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, _utils.validateType)("TSType")
    }
  });
  defineType("TSTypeOperator", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    builder: ["typeAnnotation", "operator"],
    fields: {
      operator: {
        validate: (0, _utils.assertValueType)("string"),
        default: "keyof"
      },
      typeAnnotation: (0, _utils.validateType)("TSType")
    }
  });
  defineType("TSIndexedAccessType", {
    aliases: ["TSType"],
    visitor: ["objectType", "indexType"],
    fields: {
      objectType: (0, _utils.validateType)("TSType"),
      indexType: (0, _utils.validateType)("TSType")
    }
  });
  defineType("TSMappedType", {
    aliases: ["TSType"],
    visitor: ["typeParameter", "nameType", "typeAnnotation"],
    builder: ["typeParameter", "typeAnnotation", "nameType"],
    fields: Object.assign({}, {
      typeParameter: (0, _utils.validateType)("TSTypeParameter")
    }, {
      readonly: (0, _utils.validateOptional)((0, _utils.assertOneOf)(true, false, "+", "-")),
      optional: (0, _utils.validateOptional)((0, _utils.assertOneOf)(true, false, "+", "-")),
      typeAnnotation: (0, _utils.validateOptionalType)("TSType"),
      nameType: (0, _utils.validateOptionalType)("TSType")
    })
  });
  defineType("TSTemplateLiteralType", {
    aliases: ["TSType", "TSBaseType"],
    visitor: ["quasis", "types"],
    fields: {
      quasis: (0, _utils.validateArrayOfType)("TemplateElement"),
      types: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSType")), function(node2, key, val) {
          if (node2.quasis.length !== val.length + 1) {
            throw new TypeError(`Number of ${node2.type} quasis should be exactly one more than the number of types.
Expected ${val.length + 1} quasis but got ${node2.quasis.length}`);
          }
        })
      }
    }
  });
  defineType("TSLiteralType", {
    aliases: ["TSType", "TSBaseType"],
    visitor: ["literal"],
    fields: {
      literal: {
        validate: (function() {
          const unaryExpression = (0, _utils.assertNodeType)("NumericLiteral", "BigIntLiteral");
          const unaryOperator = (0, _utils.assertOneOf)("-");
          const literal2 = (0, _utils.assertNodeType)("NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral");
          const validator = function validator2(parent, key, node2) {
            if ((0, _is.default)("UnaryExpression", node2)) {
              unaryOperator(node2, "operator", node2.operator);
              unaryExpression(node2, "argument", node2.argument);
            } else {
              literal2(parent, key, node2);
            }
          };
          validator.oneOfNodeTypes = ["NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral", "UnaryExpression"];
          return validator;
        })()
      }
    }
  });
  {
    defineType("TSExpressionWithTypeArguments", {
      aliases: ["TSType"],
      visitor: ["expression", "typeParameters"],
      fields: {
        expression: (0, _utils.validateType)("TSEntityName"),
        typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
      }
    });
  }
  defineType("TSInterfaceDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "extends", "body"],
    fields: {
      declare: (0, _utils.validateOptional)(bool),
      id: (0, _utils.validateType)("Identifier"),
      typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
      extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("TSExpressionWithTypeArguments")),
      body: (0, _utils.validateType)("TSInterfaceBody")
    }
  });
  defineType("TSInterfaceBody", {
    visitor: ["body"],
    fields: {
      body: (0, _utils.validateArrayOfType)("TSTypeElement")
    }
  });
  defineType("TSTypeAliasDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "typeAnnotation"],
    fields: {
      declare: (0, _utils.validateOptional)(bool),
      id: (0, _utils.validateType)("Identifier"),
      typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
      typeAnnotation: (0, _utils.validateType)("TSType")
    }
  });
  defineType("TSInstantiationExpression", {
    aliases: ["Expression"],
    visitor: ["expression", "typeParameters"],
    fields: {
      expression: (0, _utils.validateType)("Expression"),
      ["typeParameters"]: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
    }
  });
  const TSTypeExpression = {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["expression", "typeAnnotation"],
    fields: {
      expression: (0, _utils.validateType)("Expression"),
      typeAnnotation: (0, _utils.validateType)("TSType")
    }
  };
  defineType("TSAsExpression", TSTypeExpression);
  defineType("TSSatisfiesExpression", TSTypeExpression);
  defineType("TSTypeAssertion", {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["typeAnnotation", "expression"],
    fields: {
      typeAnnotation: (0, _utils.validateType)("TSType"),
      expression: (0, _utils.validateType)("Expression")
    }
  });
  defineType("TSEnumBody", {
    visitor: ["members"],
    fields: {
      members: (0, _utils.validateArrayOfType)("TSEnumMember")
    }
  });
  {
    defineType("TSEnumDeclaration", {
      aliases: ["Statement", "Declaration"],
      visitor: ["id", "members"],
      fields: {
        declare: (0, _utils.validateOptional)(bool),
        const: (0, _utils.validateOptional)(bool),
        id: (0, _utils.validateType)("Identifier"),
        members: (0, _utils.validateArrayOfType)("TSEnumMember"),
        initializer: (0, _utils.validateOptionalType)("Expression"),
        body: (0, _utils.validateOptionalType)("TSEnumBody")
      }
    });
  }
  defineType("TSEnumMember", {
    visitor: ["id", "initializer"],
    fields: {
      id: (0, _utils.validateType)("Identifier", "StringLiteral"),
      initializer: (0, _utils.validateOptionalType)("Expression")
    }
  });
  defineType("TSModuleDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "body"],
    fields: Object.assign({
      kind: {
        validate: (0, _utils.assertOneOf)("global", "module", "namespace")
      },
      declare: (0, _utils.validateOptional)(bool)
    }, {
      global: (0, _utils.validateOptional)(bool)
    }, {
      id: (0, _utils.validateType)("Identifier", "StringLiteral"),
      body: (0, _utils.validateType)("TSModuleBlock", "TSModuleDeclaration")
    })
  });
  defineType("TSModuleBlock", {
    aliases: ["Scopable", "Block", "BlockParent", "FunctionParent"],
    visitor: ["body"],
    fields: {
      body: (0, _utils.validateArrayOfType)("Statement")
    }
  });
  defineType("TSImportType", {
    aliases: ["TSType"],
    builder: ["argument", "qualifier", "typeParameters"],
    visitor: ["argument", "options", "qualifier", "typeParameters"],
    fields: {
      argument: (0, _utils.validateType)("StringLiteral"),
      qualifier: (0, _utils.validateOptionalType)("TSEntityName"),
      ["typeParameters"]: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation"),
      options: {
        validate: (0, _utils.assertNodeType)("ObjectExpression"),
        optional: true
      }
    }
  });
  defineType("TSImportEqualsDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "moduleReference"],
    fields: Object.assign({}, {
      isExport: (0, _utils.validate)(bool)
    }, {
      id: (0, _utils.validateType)("Identifier"),
      moduleReference: (0, _utils.validateType)("TSEntityName", "TSExternalModuleReference"),
      importKind: {
        validate: (0, _utils.assertOneOf)("type", "value"),
        optional: true
      }
    })
  });
  defineType("TSExternalModuleReference", {
    visitor: ["expression"],
    fields: {
      expression: (0, _utils.validateType)("StringLiteral")
    }
  });
  defineType("TSNonNullExpression", {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["expression"],
    fields: {
      expression: (0, _utils.validateType)("Expression")
    }
  });
  defineType("TSExportAssignment", {
    aliases: ["Statement"],
    visitor: ["expression"],
    fields: {
      expression: (0, _utils.validateType)("Expression")
    }
  });
  defineType("TSNamespaceExportDeclaration", {
    aliases: ["Statement"],
    visitor: ["id"],
    fields: {
      id: (0, _utils.validateType)("Identifier")
    }
  });
  defineType("TSTypeAnnotation", {
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: {
        validate: (0, _utils.assertNodeType)("TSType")
      }
    }
  });
  defineType("TSTypeParameterInstantiation", {
    visitor: ["params"],
    fields: {
      params: (0, _utils.validateArrayOfType)("TSType")
    }
  });
  defineType("TSTypeParameterDeclaration", {
    visitor: ["params"],
    fields: {
      params: (0, _utils.validateArrayOfType)("TSTypeParameter")
    }
  });
  defineType("TSTypeParameter", {
    builder: ["constraint", "default", "name"],
    visitor: ["constraint", "default"],
    fields: {
      name: {
        validate: (0, _utils.assertValueType)("string")
      },
      in: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      out: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      const: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      constraint: {
        validate: (0, _utils.assertNodeType)("TSType"),
        optional: true
      },
      default: {
        validate: (0, _utils.assertNodeType)("TSType"),
        optional: true
      }
    }
  });
  return typescript$1;
}
var deprecatedAliases = {};
var hasRequiredDeprecatedAliases;
function requireDeprecatedAliases() {
  if (hasRequiredDeprecatedAliases) return deprecatedAliases;
  hasRequiredDeprecatedAliases = 1;
  Object.defineProperty(deprecatedAliases, "__esModule", {
    value: true
  });
  deprecatedAliases.DEPRECATED_ALIASES = void 0;
  deprecatedAliases.DEPRECATED_ALIASES = {
    ModuleDeclaration: "ImportOrExportDeclaration"
  };
  return deprecatedAliases;
}
var hasRequiredDefinitions;
function requireDefinitions() {
  if (hasRequiredDefinitions) return definitions;
  hasRequiredDefinitions = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", {
      value: true
    });
    Object.defineProperty(exports$1, "ALIAS_KEYS", {
      enumerable: true,
      get: function() {
        return _utils.ALIAS_KEYS;
      }
    });
    Object.defineProperty(exports$1, "BUILDER_KEYS", {
      enumerable: true,
      get: function() {
        return _utils.BUILDER_KEYS;
      }
    });
    Object.defineProperty(exports$1, "DEPRECATED_ALIASES", {
      enumerable: true,
      get: function() {
        return _deprecatedAliases.DEPRECATED_ALIASES;
      }
    });
    Object.defineProperty(exports$1, "DEPRECATED_KEYS", {
      enumerable: true,
      get: function() {
        return _utils.DEPRECATED_KEYS;
      }
    });
    Object.defineProperty(exports$1, "FLIPPED_ALIAS_KEYS", {
      enumerable: true,
      get: function() {
        return _utils.FLIPPED_ALIAS_KEYS;
      }
    });
    Object.defineProperty(exports$1, "NODE_FIELDS", {
      enumerable: true,
      get: function() {
        return _utils.NODE_FIELDS;
      }
    });
    Object.defineProperty(exports$1, "NODE_PARENT_VALIDATIONS", {
      enumerable: true,
      get: function() {
        return _utils.NODE_PARENT_VALIDATIONS;
      }
    });
    Object.defineProperty(exports$1, "NODE_UNION_SHAPES__PRIVATE", {
      enumerable: true,
      get: function() {
        return _utils.NODE_UNION_SHAPES__PRIVATE;
      }
    });
    Object.defineProperty(exports$1, "PLACEHOLDERS", {
      enumerable: true,
      get: function() {
        return _placeholders.PLACEHOLDERS;
      }
    });
    Object.defineProperty(exports$1, "PLACEHOLDERS_ALIAS", {
      enumerable: true,
      get: function() {
        return _placeholders.PLACEHOLDERS_ALIAS;
      }
    });
    Object.defineProperty(exports$1, "PLACEHOLDERS_FLIPPED_ALIAS", {
      enumerable: true,
      get: function() {
        return _placeholders.PLACEHOLDERS_FLIPPED_ALIAS;
      }
    });
    exports$1.TYPES = void 0;
    Object.defineProperty(exports$1, "VISITOR_KEYS", {
      enumerable: true,
      get: function() {
        return _utils.VISITOR_KEYS;
      }
    });
    requireCore();
    requireFlow$1();
    requireJsx$1();
    requireMisc();
    requireExperimental();
    requireTypescript$1();
    var _utils = requireUtils();
    var _placeholders = requirePlaceholders();
    var _deprecatedAliases = requireDeprecatedAliases();
    Object.keys(_deprecatedAliases.DEPRECATED_ALIASES).forEach((deprecatedAlias) => {
      _utils.FLIPPED_ALIAS_KEYS[deprecatedAlias] = _utils.FLIPPED_ALIAS_KEYS[_deprecatedAliases.DEPRECATED_ALIASES[deprecatedAlias]];
    });
    for (const {
      types: types2,
      set
    } of _utils.allExpandedTypes) {
      for (const type of types2) {
        const aliases = _utils.FLIPPED_ALIAS_KEYS[type];
        if (aliases) {
          aliases.forEach(set.add, set);
        } else {
          set.add(type);
        }
      }
    }
    exports$1.TYPES = [].concat(Object.keys(_utils.VISITOR_KEYS), Object.keys(_utils.FLIPPED_ALIAS_KEYS), Object.keys(_utils.DEPRECATED_KEYS));
  })(definitions);
  return definitions;
}
var hasRequiredValidate;
function requireValidate() {
  if (hasRequiredValidate) return validate;
  hasRequiredValidate = 1;
  Object.defineProperty(validate, "__esModule", {
    value: true
  });
  validate.default = validate$1;
  validate.validateChild = validateChild;
  validate.validateField = validateField;
  validate.validateInternal = validateInternal;
  var _index = requireDefinitions();
  function validate$1(node2, key, val) {
    if (!node2) return;
    const fields = _index.NODE_FIELDS[node2.type];
    if (!fields) return;
    const field = fields[key];
    validateField(node2, key, val, field);
    validateChild(node2, key, val);
  }
  function validateInternal(field, node2, key, val, maybeNode) {
    if (!(field != null && field.validate)) return;
    if (field.optional && val == null) return;
    field.validate(node2, key, val);
    if (maybeNode) {
      var _NODE_PARENT_VALIDATI;
      const type = val.type;
      if (type == null) return;
      (_NODE_PARENT_VALIDATI = _index.NODE_PARENT_VALIDATIONS[type]) == null || _NODE_PARENT_VALIDATI.call(_index.NODE_PARENT_VALIDATIONS, node2, key, val);
    }
  }
  function validateField(node2, key, val, field) {
    if (!(field != null && field.validate)) return;
    if (field.optional && val == null) return;
    field.validate(node2, key, val);
  }
  function validateChild(node2, key, val) {
    var _NODE_PARENT_VALIDATI2;
    const type = val == null ? void 0 : val.type;
    if (type == null) return;
    (_NODE_PARENT_VALIDATI2 = _index.NODE_PARENT_VALIDATIONS[type]) == null || _NODE_PARENT_VALIDATI2.call(_index.NODE_PARENT_VALIDATIONS, node2, key, val);
  }
  return validate;
}
var hasRequiredLowercase;
function requireLowercase() {
  if (hasRequiredLowercase) return lowercase;
  hasRequiredLowercase = 1;
  Object.defineProperty(lowercase, "__esModule", {
    value: true
  });
  lowercase.anyTypeAnnotation = anyTypeAnnotation;
  lowercase.argumentPlaceholder = argumentPlaceholder;
  lowercase.arrayExpression = arrayExpression;
  lowercase.arrayPattern = arrayPattern;
  lowercase.arrayTypeAnnotation = arrayTypeAnnotation;
  lowercase.arrowFunctionExpression = arrowFunctionExpression;
  lowercase.assignmentExpression = assignmentExpression;
  lowercase.assignmentPattern = assignmentPattern;
  lowercase.awaitExpression = awaitExpression;
  lowercase.bigIntLiteral = bigIntLiteral;
  lowercase.binaryExpression = binaryExpression;
  lowercase.bindExpression = bindExpression;
  lowercase.blockStatement = blockStatement;
  lowercase.booleanLiteral = booleanLiteral;
  lowercase.booleanLiteralTypeAnnotation = booleanLiteralTypeAnnotation;
  lowercase.booleanTypeAnnotation = booleanTypeAnnotation;
  lowercase.breakStatement = breakStatement;
  lowercase.callExpression = callExpression;
  lowercase.catchClause = catchClause;
  lowercase.classAccessorProperty = classAccessorProperty;
  lowercase.classBody = classBody;
  lowercase.classDeclaration = classDeclaration;
  lowercase.classExpression = classExpression;
  lowercase.classImplements = classImplements;
  lowercase.classMethod = classMethod;
  lowercase.classPrivateMethod = classPrivateMethod;
  lowercase.classPrivateProperty = classPrivateProperty;
  lowercase.classProperty = classProperty;
  lowercase.conditionalExpression = conditionalExpression;
  lowercase.continueStatement = continueStatement;
  lowercase.debuggerStatement = debuggerStatement;
  lowercase.decimalLiteral = decimalLiteral;
  lowercase.declareClass = declareClass;
  lowercase.declareExportAllDeclaration = declareExportAllDeclaration;
  lowercase.declareExportDeclaration = declareExportDeclaration;
  lowercase.declareFunction = declareFunction;
  lowercase.declareInterface = declareInterface;
  lowercase.declareModule = declareModule;
  lowercase.declareModuleExports = declareModuleExports;
  lowercase.declareOpaqueType = declareOpaqueType;
  lowercase.declareTypeAlias = declareTypeAlias;
  lowercase.declareVariable = declareVariable;
  lowercase.declaredPredicate = declaredPredicate;
  lowercase.decorator = decorator;
  lowercase.directive = directive;
  lowercase.directiveLiteral = directiveLiteral;
  lowercase.doExpression = doExpression;
  lowercase.doWhileStatement = doWhileStatement;
  lowercase.emptyStatement = emptyStatement;
  lowercase.emptyTypeAnnotation = emptyTypeAnnotation;
  lowercase.enumBooleanBody = enumBooleanBody;
  lowercase.enumBooleanMember = enumBooleanMember;
  lowercase.enumDeclaration = enumDeclaration;
  lowercase.enumDefaultedMember = enumDefaultedMember;
  lowercase.enumNumberBody = enumNumberBody;
  lowercase.enumNumberMember = enumNumberMember;
  lowercase.enumStringBody = enumStringBody;
  lowercase.enumStringMember = enumStringMember;
  lowercase.enumSymbolBody = enumSymbolBody;
  lowercase.existsTypeAnnotation = existsTypeAnnotation;
  lowercase.exportAllDeclaration = exportAllDeclaration;
  lowercase.exportDefaultDeclaration = exportDefaultDeclaration;
  lowercase.exportDefaultSpecifier = exportDefaultSpecifier;
  lowercase.exportNamedDeclaration = exportNamedDeclaration;
  lowercase.exportNamespaceSpecifier = exportNamespaceSpecifier;
  lowercase.exportSpecifier = exportSpecifier;
  lowercase.expressionStatement = expressionStatement;
  lowercase.file = file;
  lowercase.forInStatement = forInStatement;
  lowercase.forOfStatement = forOfStatement;
  lowercase.forStatement = forStatement;
  lowercase.functionDeclaration = functionDeclaration;
  lowercase.functionExpression = functionExpression;
  lowercase.functionTypeAnnotation = functionTypeAnnotation;
  lowercase.functionTypeParam = functionTypeParam;
  lowercase.genericTypeAnnotation = genericTypeAnnotation;
  lowercase.identifier = identifier2;
  lowercase.ifStatement = ifStatement;
  lowercase.import = _import;
  lowercase.importAttribute = importAttribute;
  lowercase.importDeclaration = importDeclaration;
  lowercase.importDefaultSpecifier = importDefaultSpecifier;
  lowercase.importExpression = importExpression;
  lowercase.importNamespaceSpecifier = importNamespaceSpecifier;
  lowercase.importSpecifier = importSpecifier;
  lowercase.indexedAccessType = indexedAccessType;
  lowercase.inferredPredicate = inferredPredicate;
  lowercase.interfaceDeclaration = interfaceDeclaration;
  lowercase.interfaceExtends = interfaceExtends;
  lowercase.interfaceTypeAnnotation = interfaceTypeAnnotation;
  lowercase.interpreterDirective = interpreterDirective;
  lowercase.intersectionTypeAnnotation = intersectionTypeAnnotation;
  lowercase.jSXAttribute = lowercase.jsxAttribute = jsxAttribute;
  lowercase.jSXClosingElement = lowercase.jsxClosingElement = jsxClosingElement;
  lowercase.jSXClosingFragment = lowercase.jsxClosingFragment = jsxClosingFragment;
  lowercase.jSXElement = lowercase.jsxElement = jsxElement;
  lowercase.jSXEmptyExpression = lowercase.jsxEmptyExpression = jsxEmptyExpression;
  lowercase.jSXExpressionContainer = lowercase.jsxExpressionContainer = jsxExpressionContainer;
  lowercase.jSXFragment = lowercase.jsxFragment = jsxFragment;
  lowercase.jSXIdentifier = lowercase.jsxIdentifier = jsxIdentifier;
  lowercase.jSXMemberExpression = lowercase.jsxMemberExpression = jsxMemberExpression;
  lowercase.jSXNamespacedName = lowercase.jsxNamespacedName = jsxNamespacedName;
  lowercase.jSXOpeningElement = lowercase.jsxOpeningElement = jsxOpeningElement;
  lowercase.jSXOpeningFragment = lowercase.jsxOpeningFragment = jsxOpeningFragment;
  lowercase.jSXSpreadAttribute = lowercase.jsxSpreadAttribute = jsxSpreadAttribute;
  lowercase.jSXSpreadChild = lowercase.jsxSpreadChild = jsxSpreadChild;
  lowercase.jSXText = lowercase.jsxText = jsxText;
  lowercase.labeledStatement = labeledStatement;
  lowercase.logicalExpression = logicalExpression;
  lowercase.memberExpression = memberExpression;
  lowercase.metaProperty = metaProperty;
  lowercase.mixedTypeAnnotation = mixedTypeAnnotation;
  lowercase.moduleExpression = moduleExpression;
  lowercase.newExpression = newExpression;
  lowercase.noop = noop;
  lowercase.nullLiteral = nullLiteral;
  lowercase.nullLiteralTypeAnnotation = nullLiteralTypeAnnotation;
  lowercase.nullableTypeAnnotation = nullableTypeAnnotation;
  lowercase.numberLiteral = NumberLiteral;
  lowercase.numberLiteralTypeAnnotation = numberLiteralTypeAnnotation;
  lowercase.numberTypeAnnotation = numberTypeAnnotation;
  lowercase.numericLiteral = numericLiteral;
  lowercase.objectExpression = objectExpression;
  lowercase.objectMethod = objectMethod;
  lowercase.objectPattern = objectPattern;
  lowercase.objectProperty = objectProperty;
  lowercase.objectTypeAnnotation = objectTypeAnnotation;
  lowercase.objectTypeCallProperty = objectTypeCallProperty;
  lowercase.objectTypeIndexer = objectTypeIndexer;
  lowercase.objectTypeInternalSlot = objectTypeInternalSlot;
  lowercase.objectTypeProperty = objectTypeProperty;
  lowercase.objectTypeSpreadProperty = objectTypeSpreadProperty;
  lowercase.opaqueType = opaqueType;
  lowercase.optionalCallExpression = optionalCallExpression;
  lowercase.optionalIndexedAccessType = optionalIndexedAccessType;
  lowercase.optionalMemberExpression = optionalMemberExpression;
  lowercase.parenthesizedExpression = parenthesizedExpression;
  lowercase.pipelineBareFunction = pipelineBareFunction;
  lowercase.pipelinePrimaryTopicReference = pipelinePrimaryTopicReference;
  lowercase.pipelineTopicExpression = pipelineTopicExpression;
  lowercase.placeholder = placeholder;
  lowercase.privateName = privateName;
  lowercase.program = program;
  lowercase.qualifiedTypeIdentifier = qualifiedTypeIdentifier;
  lowercase.recordExpression = recordExpression;
  lowercase.regExpLiteral = regExpLiteral;
  lowercase.regexLiteral = RegexLiteral;
  lowercase.restElement = restElement;
  lowercase.restProperty = RestProperty;
  lowercase.returnStatement = returnStatement;
  lowercase.sequenceExpression = sequenceExpression;
  lowercase.spreadElement = spreadElement;
  lowercase.spreadProperty = SpreadProperty;
  lowercase.staticBlock = staticBlock;
  lowercase.stringLiteral = stringLiteral;
  lowercase.stringLiteralTypeAnnotation = stringLiteralTypeAnnotation;
  lowercase.stringTypeAnnotation = stringTypeAnnotation;
  lowercase.super = _super;
  lowercase.switchCase = switchCase;
  lowercase.switchStatement = switchStatement;
  lowercase.symbolTypeAnnotation = symbolTypeAnnotation;
  lowercase.taggedTemplateExpression = taggedTemplateExpression;
  lowercase.templateElement = templateElement;
  lowercase.templateLiteral = templateLiteral;
  lowercase.thisExpression = thisExpression;
  lowercase.thisTypeAnnotation = thisTypeAnnotation;
  lowercase.throwStatement = throwStatement;
  lowercase.topicReference = topicReference;
  lowercase.tryStatement = tryStatement;
  lowercase.tSAnyKeyword = lowercase.tsAnyKeyword = tsAnyKeyword;
  lowercase.tSArrayType = lowercase.tsArrayType = tsArrayType;
  lowercase.tSAsExpression = lowercase.tsAsExpression = tsAsExpression;
  lowercase.tSBigIntKeyword = lowercase.tsBigIntKeyword = tsBigIntKeyword;
  lowercase.tSBooleanKeyword = lowercase.tsBooleanKeyword = tsBooleanKeyword;
  lowercase.tSCallSignatureDeclaration = lowercase.tsCallSignatureDeclaration = tsCallSignatureDeclaration;
  lowercase.tSConditionalType = lowercase.tsConditionalType = tsConditionalType;
  lowercase.tSConstructSignatureDeclaration = lowercase.tsConstructSignatureDeclaration = tsConstructSignatureDeclaration;
  lowercase.tSConstructorType = lowercase.tsConstructorType = tsConstructorType;
  lowercase.tSDeclareFunction = lowercase.tsDeclareFunction = tsDeclareFunction;
  lowercase.tSDeclareMethod = lowercase.tsDeclareMethod = tsDeclareMethod;
  lowercase.tSEnumBody = lowercase.tsEnumBody = tsEnumBody;
  lowercase.tSEnumDeclaration = lowercase.tsEnumDeclaration = tsEnumDeclaration;
  lowercase.tSEnumMember = lowercase.tsEnumMember = tsEnumMember;
  lowercase.tSExportAssignment = lowercase.tsExportAssignment = tsExportAssignment;
  lowercase.tSExpressionWithTypeArguments = lowercase.tsExpressionWithTypeArguments = tsExpressionWithTypeArguments;
  lowercase.tSExternalModuleReference = lowercase.tsExternalModuleReference = tsExternalModuleReference;
  lowercase.tSFunctionType = lowercase.tsFunctionType = tsFunctionType;
  lowercase.tSImportEqualsDeclaration = lowercase.tsImportEqualsDeclaration = tsImportEqualsDeclaration;
  lowercase.tSImportType = lowercase.tsImportType = tsImportType;
  lowercase.tSIndexSignature = lowercase.tsIndexSignature = tsIndexSignature;
  lowercase.tSIndexedAccessType = lowercase.tsIndexedAccessType = tsIndexedAccessType;
  lowercase.tSInferType = lowercase.tsInferType = tsInferType;
  lowercase.tSInstantiationExpression = lowercase.tsInstantiationExpression = tsInstantiationExpression;
  lowercase.tSInterfaceBody = lowercase.tsInterfaceBody = tsInterfaceBody;
  lowercase.tSInterfaceDeclaration = lowercase.tsInterfaceDeclaration = tsInterfaceDeclaration;
  lowercase.tSIntersectionType = lowercase.tsIntersectionType = tsIntersectionType;
  lowercase.tSIntrinsicKeyword = lowercase.tsIntrinsicKeyword = tsIntrinsicKeyword;
  lowercase.tSLiteralType = lowercase.tsLiteralType = tsLiteralType;
  lowercase.tSMappedType = lowercase.tsMappedType = tsMappedType;
  lowercase.tSMethodSignature = lowercase.tsMethodSignature = tsMethodSignature;
  lowercase.tSModuleBlock = lowercase.tsModuleBlock = tsModuleBlock;
  lowercase.tSModuleDeclaration = lowercase.tsModuleDeclaration = tsModuleDeclaration;
  lowercase.tSNamedTupleMember = lowercase.tsNamedTupleMember = tsNamedTupleMember;
  lowercase.tSNamespaceExportDeclaration = lowercase.tsNamespaceExportDeclaration = tsNamespaceExportDeclaration;
  lowercase.tSNeverKeyword = lowercase.tsNeverKeyword = tsNeverKeyword;
  lowercase.tSNonNullExpression = lowercase.tsNonNullExpression = tsNonNullExpression;
  lowercase.tSNullKeyword = lowercase.tsNullKeyword = tsNullKeyword;
  lowercase.tSNumberKeyword = lowercase.tsNumberKeyword = tsNumberKeyword;
  lowercase.tSObjectKeyword = lowercase.tsObjectKeyword = tsObjectKeyword;
  lowercase.tSOptionalType = lowercase.tsOptionalType = tsOptionalType;
  lowercase.tSParameterProperty = lowercase.tsParameterProperty = tsParameterProperty;
  lowercase.tSParenthesizedType = lowercase.tsParenthesizedType = tsParenthesizedType;
  lowercase.tSPropertySignature = lowercase.tsPropertySignature = tsPropertySignature;
  lowercase.tSQualifiedName = lowercase.tsQualifiedName = tsQualifiedName;
  lowercase.tSRestType = lowercase.tsRestType = tsRestType;
  lowercase.tSSatisfiesExpression = lowercase.tsSatisfiesExpression = tsSatisfiesExpression;
  lowercase.tSStringKeyword = lowercase.tsStringKeyword = tsStringKeyword;
  lowercase.tSSymbolKeyword = lowercase.tsSymbolKeyword = tsSymbolKeyword;
  lowercase.tSTemplateLiteralType = lowercase.tsTemplateLiteralType = tsTemplateLiteralType;
  lowercase.tSThisType = lowercase.tsThisType = tsThisType;
  lowercase.tSTupleType = lowercase.tsTupleType = tsTupleType;
  lowercase.tSTypeAliasDeclaration = lowercase.tsTypeAliasDeclaration = tsTypeAliasDeclaration;
  lowercase.tSTypeAnnotation = lowercase.tsTypeAnnotation = tsTypeAnnotation;
  lowercase.tSTypeAssertion = lowercase.tsTypeAssertion = tsTypeAssertion;
  lowercase.tSTypeLiteral = lowercase.tsTypeLiteral = tsTypeLiteral;
  lowercase.tSTypeOperator = lowercase.tsTypeOperator = tsTypeOperator;
  lowercase.tSTypeParameter = lowercase.tsTypeParameter = tsTypeParameter;
  lowercase.tSTypeParameterDeclaration = lowercase.tsTypeParameterDeclaration = tsTypeParameterDeclaration;
  lowercase.tSTypeParameterInstantiation = lowercase.tsTypeParameterInstantiation = tsTypeParameterInstantiation;
  lowercase.tSTypePredicate = lowercase.tsTypePredicate = tsTypePredicate;
  lowercase.tSTypeQuery = lowercase.tsTypeQuery = tsTypeQuery;
  lowercase.tSTypeReference = lowercase.tsTypeReference = tsTypeReference;
  lowercase.tSUndefinedKeyword = lowercase.tsUndefinedKeyword = tsUndefinedKeyword;
  lowercase.tSUnionType = lowercase.tsUnionType = tsUnionType;
  lowercase.tSUnknownKeyword = lowercase.tsUnknownKeyword = tsUnknownKeyword;
  lowercase.tSVoidKeyword = lowercase.tsVoidKeyword = tsVoidKeyword;
  lowercase.tupleExpression = tupleExpression;
  lowercase.tupleTypeAnnotation = tupleTypeAnnotation;
  lowercase.typeAlias = typeAlias;
  lowercase.typeAnnotation = typeAnnotation;
  lowercase.typeCastExpression = typeCastExpression;
  lowercase.typeParameter = typeParameter;
  lowercase.typeParameterDeclaration = typeParameterDeclaration;
  lowercase.typeParameterInstantiation = typeParameterInstantiation;
  lowercase.typeofTypeAnnotation = typeofTypeAnnotation;
  lowercase.unaryExpression = unaryExpression;
  lowercase.unionTypeAnnotation = unionTypeAnnotation;
  lowercase.updateExpression = updateExpression;
  lowercase.v8IntrinsicIdentifier = v8IntrinsicIdentifier;
  lowercase.variableDeclaration = variableDeclaration;
  lowercase.variableDeclarator = variableDeclarator;
  lowercase.variance = variance;
  lowercase.voidPattern = voidPattern;
  lowercase.voidTypeAnnotation = voidTypeAnnotation;
  lowercase.whileStatement = whileStatement;
  lowercase.withStatement = withStatement;
  lowercase.yieldExpression = yieldExpression;
  var _validate = requireValidate();
  var _deprecationWarning = requireDeprecationWarning();
  var utils2 = requireUtils();
  const {
    validateInternal: validate2
  } = _validate;
  const {
    NODE_FIELDS
  } = utils2;
  function bigIntLiteral(value) {
    if (typeof value === "bigint") {
      value = value.toString();
    }
    const node2 = {
      type: "BigIntLiteral",
      value
    };
    const defs = NODE_FIELDS.BigIntLiteral;
    validate2(defs.value, node2, "value", value);
    return node2;
  }
  function arrayExpression(elements = []) {
    const node2 = {
      type: "ArrayExpression",
      elements
    };
    const defs = NODE_FIELDS.ArrayExpression;
    validate2(defs.elements, node2, "elements", elements, 1);
    return node2;
  }
  function assignmentExpression(operator, left, right) {
    const node2 = {
      type: "AssignmentExpression",
      operator,
      left,
      right
    };
    const defs = NODE_FIELDS.AssignmentExpression;
    validate2(defs.operator, node2, "operator", operator);
    validate2(defs.left, node2, "left", left, 1);
    validate2(defs.right, node2, "right", right, 1);
    return node2;
  }
  function binaryExpression(operator, left, right) {
    const node2 = {
      type: "BinaryExpression",
      operator,
      left,
      right
    };
    const defs = NODE_FIELDS.BinaryExpression;
    validate2(defs.operator, node2, "operator", operator);
    validate2(defs.left, node2, "left", left, 1);
    validate2(defs.right, node2, "right", right, 1);
    return node2;
  }
  function interpreterDirective(value) {
    const node2 = {
      type: "InterpreterDirective",
      value
    };
    const defs = NODE_FIELDS.InterpreterDirective;
    validate2(defs.value, node2, "value", value);
    return node2;
  }
  function directive(value) {
    const node2 = {
      type: "Directive",
      value
    };
    const defs = NODE_FIELDS.Directive;
    validate2(defs.value, node2, "value", value, 1);
    return node2;
  }
  function directiveLiteral(value) {
    const node2 = {
      type: "DirectiveLiteral",
      value
    };
    const defs = NODE_FIELDS.DirectiveLiteral;
    validate2(defs.value, node2, "value", value);
    return node2;
  }
  function blockStatement(body, directives = []) {
    const node2 = {
      type: "BlockStatement",
      body,
      directives
    };
    const defs = NODE_FIELDS.BlockStatement;
    validate2(defs.body, node2, "body", body, 1);
    validate2(defs.directives, node2, "directives", directives, 1);
    return node2;
  }
  function breakStatement(label = null) {
    const node2 = {
      type: "BreakStatement",
      label
    };
    const defs = NODE_FIELDS.BreakStatement;
    validate2(defs.label, node2, "label", label, 1);
    return node2;
  }
  function callExpression(callee, _arguments) {
    const node2 = {
      type: "CallExpression",
      callee,
      arguments: _arguments
    };
    const defs = NODE_FIELDS.CallExpression;
    validate2(defs.callee, node2, "callee", callee, 1);
    validate2(defs.arguments, node2, "arguments", _arguments, 1);
    return node2;
  }
  function catchClause(param = null, body) {
    const node2 = {
      type: "CatchClause",
      param,
      body
    };
    const defs = NODE_FIELDS.CatchClause;
    validate2(defs.param, node2, "param", param, 1);
    validate2(defs.body, node2, "body", body, 1);
    return node2;
  }
  function conditionalExpression(test, consequent, alternate) {
    const node2 = {
      type: "ConditionalExpression",
      test,
      consequent,
      alternate
    };
    const defs = NODE_FIELDS.ConditionalExpression;
    validate2(defs.test, node2, "test", test, 1);
    validate2(defs.consequent, node2, "consequent", consequent, 1);
    validate2(defs.alternate, node2, "alternate", alternate, 1);
    return node2;
  }
  function continueStatement(label = null) {
    const node2 = {
      type: "ContinueStatement",
      label
    };
    const defs = NODE_FIELDS.ContinueStatement;
    validate2(defs.label, node2, "label", label, 1);
    return node2;
  }
  function debuggerStatement() {
    return {
      type: "DebuggerStatement"
    };
  }
  function doWhileStatement(test, body) {
    const node2 = {
      type: "DoWhileStatement",
      test,
      body
    };
    const defs = NODE_FIELDS.DoWhileStatement;
    validate2(defs.test, node2, "test", test, 1);
    validate2(defs.body, node2, "body", body, 1);
    return node2;
  }
  function emptyStatement() {
    return {
      type: "EmptyStatement"
    };
  }
  function expressionStatement(expression) {
    const node2 = {
      type: "ExpressionStatement",
      expression
    };
    const defs = NODE_FIELDS.ExpressionStatement;
    validate2(defs.expression, node2, "expression", expression, 1);
    return node2;
  }
  function file(program2, comments2 = null, tokens = null) {
    const node2 = {
      type: "File",
      program: program2,
      comments: comments2,
      tokens
    };
    const defs = NODE_FIELDS.File;
    validate2(defs.program, node2, "program", program2, 1);
    validate2(defs.comments, node2, "comments", comments2, 1);
    validate2(defs.tokens, node2, "tokens", tokens);
    return node2;
  }
  function forInStatement(left, right, body) {
    const node2 = {
      type: "ForInStatement",
      left,
      right,
      body
    };
    const defs = NODE_FIELDS.ForInStatement;
    validate2(defs.left, node2, "left", left, 1);
    validate2(defs.right, node2, "right", right, 1);
    validate2(defs.body, node2, "body", body, 1);
    return node2;
  }
  function forStatement(init = null, test = null, update = null, body) {
    const node2 = {
      type: "ForStatement",
      init,
      test,
      update,
      body
    };
    const defs = NODE_FIELDS.ForStatement;
    validate2(defs.init, node2, "init", init, 1);
    validate2(defs.test, node2, "test", test, 1);
    validate2(defs.update, node2, "update", update, 1);
    validate2(defs.body, node2, "body", body, 1);
    return node2;
  }
  function functionDeclaration(id = null, params, body, generator = false, async = false) {
    const node2 = {
      type: "FunctionDeclaration",
      id,
      params,
      body,
      generator,
      async
    };
    const defs = NODE_FIELDS.FunctionDeclaration;
    validate2(defs.id, node2, "id", id, 1);
    validate2(defs.params, node2, "params", params, 1);
    validate2(defs.body, node2, "body", body, 1);
    validate2(defs.generator, node2, "generator", generator);
    validate2(defs.async, node2, "async", async);
    return node2;
  }
  function functionExpression(id = null, params, body, generator = false, async = false) {
    const node2 = {
      type: "FunctionExpression",
      id,
      params,
      body,
      generator,
      async
    };
    const defs = NODE_FIELDS.FunctionExpression;
    validate2(defs.id, node2, "id", id, 1);
    validate2(defs.params, node2, "params", params, 1);
    validate2(defs.body, node2, "body", body, 1);
    validate2(defs.generator, node2, "generator", generator);
    validate2(defs.async, node2, "async", async);
    return node2;
  }
  function identifier2(name) {
    const node2 = {
      type: "Identifier",
      name
    };
    const defs = NODE_FIELDS.Identifier;
    validate2(defs.name, node2, "name", name);
    return node2;
  }
  function ifStatement(test, consequent, alternate = null) {
    const node2 = {
      type: "IfStatement",
      test,
      consequent,
      alternate
    };
    const defs = NODE_FIELDS.IfStatement;
    validate2(defs.test, node2, "test", test, 1);
    validate2(defs.consequent, node2, "consequent", consequent, 1);
    validate2(defs.alternate, node2, "alternate", alternate, 1);
    return node2;
  }
  function labeledStatement(label, body) {
    const node2 = {
      type: "LabeledStatement",
      label,
      body
    };
    const defs = NODE_FIELDS.LabeledStatement;
    validate2(defs.label, node2, "label", label, 1);
    validate2(defs.body, node2, "body", body, 1);
    return node2;
  }
  function stringLiteral(value) {
    const node2 = {
      type: "StringLiteral",
      value
    };
    const defs = NODE_FIELDS.StringLiteral;
    validate2(defs.value, node2, "value", value);
    return node2;
  }
  function numericLiteral(value) {
    const node2 = {
      type: "NumericLiteral",
      value
    };
    const defs = NODE_FIELDS.NumericLiteral;
    validate2(defs.value, node2, "value", value);
    return node2;
  }
  function nullLiteral() {
    return {
      type: "NullLiteral"
    };
  }
  function booleanLiteral(value) {
    const node2 = {
      type: "BooleanLiteral",
      value
    };
    const defs = NODE_FIELDS.BooleanLiteral;
    validate2(defs.value, node2, "value", value);
    return node2;
  }
  function regExpLiteral(pattern, flags = "") {
    const node2 = {
      type: "RegExpLiteral",
      pattern,
      flags
    };
    const defs = NODE_FIELDS.RegExpLiteral;
    validate2(defs.pattern, node2, "pattern", pattern);
    validate2(defs.flags, node2, "flags", flags);
    return node2;
  }
  function logicalExpression(operator, left, right) {
    const node2 = {
      type: "LogicalExpression",
      operator,
      left,
      right
    };
    const defs = NODE_FIELDS.LogicalExpression;
    validate2(defs.operator, node2, "operator", operator);
    validate2(defs.left, node2, "left", left, 1);
    validate2(defs.right, node2, "right", right, 1);
    return node2;
  }
  function memberExpression(object, property, computed = false, optional = null) {
    const node2 = {
      type: "MemberExpression",
      object,
      property,
      computed,
      optional
    };
    const defs = NODE_FIELDS.MemberExpression;
    validate2(defs.object, node2, "object", object, 1);
    validate2(defs.property, node2, "property", property, 1);
    validate2(defs.computed, node2, "computed", computed);
    validate2(defs.optional, node2, "optional", optional);
    return node2;
  }
  function newExpression(callee, _arguments) {
    const node2 = {
      type: "NewExpression",
      callee,
      arguments: _arguments
    };
    const defs = NODE_FIELDS.NewExpression;
    validate2(defs.callee, node2, "callee", callee, 1);
    validate2(defs.arguments, node2, "arguments", _arguments, 1);
    return node2;
  }
  function program(body, directives = [], sourceType = "script", interpreter = null) {
    const node2 = {
      type: "Program",
      body,
      directives,
      sourceType,
      interpreter
    };
    const defs = NODE_FIELDS.Program;
    validate2(defs.body, node2, "body", body, 1);
    validate2(defs.directives, node2, "directives", directives, 1);
    validate2(defs.sourceType, node2, "sourceType", sourceType);
    validate2(defs.interpreter, node2, "interpreter", interpreter, 1);
    return node2;
  }
  function objectExpression(properties) {
    const node2 = {
      type: "ObjectExpression",
      properties
    };
    const defs = NODE_FIELDS.ObjectExpression;
    validate2(defs.properties, node2, "properties", properties, 1);
    return node2;
  }
  function objectMethod(kind = "method", key, params, body, computed = false, generator = false, async = false) {
    const node2 = {
      type: "ObjectMethod",
      kind,
      key,
      params,
      body,
      computed,
      generator,
      async
    };
    const defs = NODE_FIELDS.ObjectMethod;
    validate2(defs.kind, node2, "kind", kind);
    validate2(defs.key, node2, "key", key, 1);
    validate2(defs.params, node2, "params", params, 1);
    validate2(defs.body, node2, "body", body, 1);
    validate2(defs.computed, node2, "computed", computed);
    validate2(defs.generator, node2, "generator", generator);
    validate2(defs.async, node2, "async", async);
    return node2;
  }
  function objectProperty(key, value, computed = false, shorthand = false, decorators = null) {
    const node2 = {
      type: "ObjectProperty",
      key,
      value,
      computed,
      shorthand,
      decorators
    };
    const defs = NODE_FIELDS.ObjectProperty;
    validate2(defs.key, node2, "key", key, 1);
    validate2(defs.value, node2, "value", value, 1);
    validate2(defs.computed, node2, "computed", computed);
    validate2(defs.shorthand, node2, "shorthand", shorthand);
    validate2(defs.decorators, node2, "decorators", decorators, 1);
    return node2;
  }
  function restElement(argument) {
    const node2 = {
      type: "RestElement",
      argument
    };
    const defs = NODE_FIELDS.RestElement;
    validate2(defs.argument, node2, "argument", argument, 1);
    return node2;
  }
  function returnStatement(argument = null) {
    const node2 = {
      type: "ReturnStatement",
      argument
    };
    const defs = NODE_FIELDS.ReturnStatement;
    validate2(defs.argument, node2, "argument", argument, 1);
    return node2;
  }
  function sequenceExpression(expressions2) {
    const node2 = {
      type: "SequenceExpression",
      expressions: expressions2
    };
    const defs = NODE_FIELDS.SequenceExpression;
    validate2(defs.expressions, node2, "expressions", expressions2, 1);
    return node2;
  }
  function parenthesizedExpression(expression) {
    const node2 = {
      type: "ParenthesizedExpression",
      expression
    };
    const defs = NODE_FIELDS.ParenthesizedExpression;
    validate2(defs.expression, node2, "expression", expression, 1);
    return node2;
  }
  function switchCase(test = null, consequent) {
    const node2 = {
      type: "SwitchCase",
      test,
      consequent
    };
    const defs = NODE_FIELDS.SwitchCase;
    validate2(defs.test, node2, "test", test, 1);
    validate2(defs.consequent, node2, "consequent", consequent, 1);
    return node2;
  }
  function switchStatement(discriminant, cases) {
    const node2 = {
      type: "SwitchStatement",
      discriminant,
      cases
    };
    const defs = NODE_FIELDS.SwitchStatement;
    validate2(defs.discriminant, node2, "discriminant", discriminant, 1);
    validate2(defs.cases, node2, "cases", cases, 1);
    return node2;
  }
  function thisExpression() {
    return {
      type: "ThisExpression"
    };
  }
  function throwStatement(argument) {
    const node2 = {
      type: "ThrowStatement",
      argument
    };
    const defs = NODE_FIELDS.ThrowStatement;
    validate2(defs.argument, node2, "argument", argument, 1);
    return node2;
  }
  function tryStatement(block, handler = null, finalizer = null) {
    const node2 = {
      type: "TryStatement",
      block,
      handler,
      finalizer
    };
    const defs = NODE_FIELDS.TryStatement;
    validate2(defs.block, node2, "block", block, 1);
    validate2(defs.handler, node2, "handler", handler, 1);
    validate2(defs.finalizer, node2, "finalizer", finalizer, 1);
    return node2;
  }
  function unaryExpression(operator, argument, prefix = true) {
    const node2 = {
      type: "UnaryExpression",
      operator,
      argument,
      prefix
    };
    const defs = NODE_FIELDS.UnaryExpression;
    validate2(defs.operator, node2, "operator", operator);
    validate2(defs.argument, node2, "argument", argument, 1);
    validate2(defs.prefix, node2, "prefix", prefix);
    return node2;
  }
  function updateExpression(operator, argument, prefix = false) {
    const node2 = {
      type: "UpdateExpression",
      operator,
      argument,
      prefix
    };
    const defs = NODE_FIELDS.UpdateExpression;
    validate2(defs.operator, node2, "operator", operator);
    validate2(defs.argument, node2, "argument", argument, 1);
    validate2(defs.prefix, node2, "prefix", prefix);
    return node2;
  }
  function variableDeclaration(kind, declarations) {
    const node2 = {
      type: "VariableDeclaration",
      kind,
      declarations
    };
    const defs = NODE_FIELDS.VariableDeclaration;
    validate2(defs.kind, node2, "kind", kind);
    validate2(defs.declarations, node2, "declarations", declarations, 1);
    return node2;
  }
  function variableDeclarator(id, init = null) {
    const node2 = {
      type: "VariableDeclarator",
      id,
      init
    };
    const defs = NODE_FIELDS.VariableDeclarator;
    validate2(defs.id, node2, "id", id, 1);
    validate2(defs.init, node2, "init", init, 1);
    return node2;
  }
  function whileStatement(test, body) {
    const node2 = {
      type: "WhileStatement",
      test,
      body
    };
    const defs = NODE_FIELDS.WhileStatement;
    validate2(defs.test, node2, "test", test, 1);
    validate2(defs.body, node2, "body", body, 1);
    return node2;
  }
  function withStatement(object, body) {
    const node2 = {
      type: "WithStatement",
      object,
      body
    };
    const defs = NODE_FIELDS.WithStatement;
    validate2(defs.object, node2, "object", object, 1);
    validate2(defs.body, node2, "body", body, 1);
    return node2;
  }
  function assignmentPattern(left, right) {
    const node2 = {
      type: "AssignmentPattern",
      left,
      right
    };
    const defs = NODE_FIELDS.AssignmentPattern;
    validate2(defs.left, node2, "left", left, 1);
    validate2(defs.right, node2, "right", right, 1);
    return node2;
  }
  function arrayPattern(elements) {
    const node2 = {
      type: "ArrayPattern",
      elements
    };
    const defs = NODE_FIELDS.ArrayPattern;
    validate2(defs.elements, node2, "elements", elements, 1);
    return node2;
  }
  function arrowFunctionExpression(params, body, async = false) {
    const node2 = {
      type: "ArrowFunctionExpression",
      params,
      body,
      async,
      expression: null
    };
    const defs = NODE_FIELDS.ArrowFunctionExpression;
    validate2(defs.params, node2, "params", params, 1);
    validate2(defs.body, node2, "body", body, 1);
    validate2(defs.async, node2, "async", async);
    return node2;
  }
  function classBody(body) {
    const node2 = {
      type: "ClassBody",
      body
    };
    const defs = NODE_FIELDS.ClassBody;
    validate2(defs.body, node2, "body", body, 1);
    return node2;
  }
  function classExpression(id = null, superClass = null, body, decorators = null) {
    const node2 = {
      type: "ClassExpression",
      id,
      superClass,
      body,
      decorators
    };
    const defs = NODE_FIELDS.ClassExpression;
    validate2(defs.id, node2, "id", id, 1);
    validate2(defs.superClass, node2, "superClass", superClass, 1);
    validate2(defs.body, node2, "body", body, 1);
    validate2(defs.decorators, node2, "decorators", decorators, 1);
    return node2;
  }
  function classDeclaration(id = null, superClass = null, body, decorators = null) {
    const node2 = {
      type: "ClassDeclaration",
      id,
      superClass,
      body,
      decorators
    };
    const defs = NODE_FIELDS.ClassDeclaration;
    validate2(defs.id, node2, "id", id, 1);
    validate2(defs.superClass, node2, "superClass", superClass, 1);
    validate2(defs.body, node2, "body", body, 1);
    validate2(defs.decorators, node2, "decorators", decorators, 1);
    return node2;
  }
  function exportAllDeclaration(source) {
    const node2 = {
      type: "ExportAllDeclaration",
      source
    };
    const defs = NODE_FIELDS.ExportAllDeclaration;
    validate2(defs.source, node2, "source", source, 1);
    return node2;
  }
  function exportDefaultDeclaration(declaration) {
    const node2 = {
      type: "ExportDefaultDeclaration",
      declaration
    };
    const defs = NODE_FIELDS.ExportDefaultDeclaration;
    validate2(defs.declaration, node2, "declaration", declaration, 1);
    return node2;
  }
  function exportNamedDeclaration(declaration = null, specifiers = [], source = null) {
    const node2 = {
      type: "ExportNamedDeclaration",
      declaration,
      specifiers,
      source
    };
    const defs = NODE_FIELDS.ExportNamedDeclaration;
    validate2(defs.declaration, node2, "declaration", declaration, 1);
    validate2(defs.specifiers, node2, "specifiers", specifiers, 1);
    validate2(defs.source, node2, "source", source, 1);
    return node2;
  }
  function exportSpecifier(local, exported) {
    const node2 = {
      type: "ExportSpecifier",
      local,
      exported
    };
    const defs = NODE_FIELDS.ExportSpecifier;
    validate2(defs.local, node2, "local", local, 1);
    validate2(defs.exported, node2, "exported", exported, 1);
    return node2;
  }
  function forOfStatement(left, right, body, _await = false) {
    const node2 = {
      type: "ForOfStatement",
      left,
      right,
      body,
      await: _await
    };
    const defs = NODE_FIELDS.ForOfStatement;
    validate2(defs.left, node2, "left", left, 1);
    validate2(defs.right, node2, "right", right, 1);
    validate2(defs.body, node2, "body", body, 1);
    validate2(defs.await, node2, "await", _await);
    return node2;
  }
  function importDeclaration(specifiers, source) {
    const node2 = {
      type: "ImportDeclaration",
      specifiers,
      source
    };
    const defs = NODE_FIELDS.ImportDeclaration;
    validate2(defs.specifiers, node2, "specifiers", specifiers, 1);
    validate2(defs.source, node2, "source", source, 1);
    return node2;
  }
  function importDefaultSpecifier(local) {
    const node2 = {
      type: "ImportDefaultSpecifier",
      local
    };
    const defs = NODE_FIELDS.ImportDefaultSpecifier;
    validate2(defs.local, node2, "local", local, 1);
    return node2;
  }
  function importNamespaceSpecifier(local) {
    const node2 = {
      type: "ImportNamespaceSpecifier",
      local
    };
    const defs = NODE_FIELDS.ImportNamespaceSpecifier;
    validate2(defs.local, node2, "local", local, 1);
    return node2;
  }
  function importSpecifier(local, imported) {
    const node2 = {
      type: "ImportSpecifier",
      local,
      imported
    };
    const defs = NODE_FIELDS.ImportSpecifier;
    validate2(defs.local, node2, "local", local, 1);
    validate2(defs.imported, node2, "imported", imported, 1);
    return node2;
  }
  function importExpression(source, options2 = null) {
    const node2 = {
      type: "ImportExpression",
      source,
      options: options2
    };
    const defs = NODE_FIELDS.ImportExpression;
    validate2(defs.source, node2, "source", source, 1);
    validate2(defs.options, node2, "options", options2, 1);
    return node2;
  }
  function metaProperty(meta, property) {
    const node2 = {
      type: "MetaProperty",
      meta,
      property
    };
    const defs = NODE_FIELDS.MetaProperty;
    validate2(defs.meta, node2, "meta", meta, 1);
    validate2(defs.property, node2, "property", property, 1);
    return node2;
  }
  function classMethod(kind = "method", key, params, body, computed = false, _static = false, generator = false, async = false) {
    const node2 = {
      type: "ClassMethod",
      kind,
      key,
      params,
      body,
      computed,
      static: _static,
      generator,
      async
    };
    const defs = NODE_FIELDS.ClassMethod;
    validate2(defs.kind, node2, "kind", kind);
    validate2(defs.key, node2, "key", key, 1);
    validate2(defs.params, node2, "params", params, 1);
    validate2(defs.body, node2, "body", body, 1);
    validate2(defs.computed, node2, "computed", computed);
    validate2(defs.static, node2, "static", _static);
    validate2(defs.generator, node2, "generator", generator);
    validate2(defs.async, node2, "async", async);
    return node2;
  }
  function objectPattern(properties) {
    const node2 = {
      type: "ObjectPattern",
      properties
    };
    const defs = NODE_FIELDS.ObjectPattern;
    validate2(defs.properties, node2, "properties", properties, 1);
    return node2;
  }
  function spreadElement(argument) {
    const node2 = {
      type: "SpreadElement",
      argument
    };
    const defs = NODE_FIELDS.SpreadElement;
    validate2(defs.argument, node2, "argument", argument, 1);
    return node2;
  }
  function _super() {
    return {
      type: "Super"
    };
  }
  function taggedTemplateExpression(tag, quasi) {
    const node2 = {
      type: "TaggedTemplateExpression",
      tag,
      quasi
    };
    const defs = NODE_FIELDS.TaggedTemplateExpression;
    validate2(defs.tag, node2, "tag", tag, 1);
    validate2(defs.quasi, node2, "quasi", quasi, 1);
    return node2;
  }
  function templateElement(value, tail = false) {
    const node2 = {
      type: "TemplateElement",
      value,
      tail
    };
    const defs = NODE_FIELDS.TemplateElement;
    validate2(defs.value, node2, "value", value);
    validate2(defs.tail, node2, "tail", tail);
    return node2;
  }
  function templateLiteral(quasis, expressions2) {
    const node2 = {
      type: "TemplateLiteral",
      quasis,
      expressions: expressions2
    };
    const defs = NODE_FIELDS.TemplateLiteral;
    validate2(defs.quasis, node2, "quasis", quasis, 1);
    validate2(defs.expressions, node2, "expressions", expressions2, 1);
    return node2;
  }
  function yieldExpression(argument = null, delegate = false) {
    const node2 = {
      type: "YieldExpression",
      argument,
      delegate
    };
    const defs = NODE_FIELDS.YieldExpression;
    validate2(defs.argument, node2, "argument", argument, 1);
    validate2(defs.delegate, node2, "delegate", delegate);
    return node2;
  }
  function awaitExpression(argument) {
    const node2 = {
      type: "AwaitExpression",
      argument
    };
    const defs = NODE_FIELDS.AwaitExpression;
    validate2(defs.argument, node2, "argument", argument, 1);
    return node2;
  }
  function _import() {
    return {
      type: "Import"
    };
  }
  function exportNamespaceSpecifier(exported) {
    const node2 = {
      type: "ExportNamespaceSpecifier",
      exported
    };
    const defs = NODE_FIELDS.ExportNamespaceSpecifier;
    validate2(defs.exported, node2, "exported", exported, 1);
    return node2;
  }
  function optionalMemberExpression(object, property, computed = false, optional) {
    const node2 = {
      type: "OptionalMemberExpression",
      object,
      property,
      computed,
      optional
    };
    const defs = NODE_FIELDS.OptionalMemberExpression;
    validate2(defs.object, node2, "object", object, 1);
    validate2(defs.property, node2, "property", property, 1);
    validate2(defs.computed, node2, "computed", computed);
    validate2(defs.optional, node2, "optional", optional);
    return node2;
  }
  function optionalCallExpression(callee, _arguments, optional) {
    const node2 = {
      type: "OptionalCallExpression",
      callee,
      arguments: _arguments,
      optional
    };
    const defs = NODE_FIELDS.OptionalCallExpression;
    validate2(defs.callee, node2, "callee", callee, 1);
    validate2(defs.arguments, node2, "arguments", _arguments, 1);
    validate2(defs.optional, node2, "optional", optional);
    return node2;
  }
  function classProperty(key, value = null, typeAnnotation2 = null, decorators = null, computed = false, _static = false) {
    const node2 = {
      type: "ClassProperty",
      key,
      value,
      typeAnnotation: typeAnnotation2,
      decorators,
      computed,
      static: _static
    };
    const defs = NODE_FIELDS.ClassProperty;
    validate2(defs.key, node2, "key", key, 1);
    validate2(defs.value, node2, "value", value, 1);
    validate2(defs.typeAnnotation, node2, "typeAnnotation", typeAnnotation2, 1);
    validate2(defs.decorators, node2, "decorators", decorators, 1);
    validate2(defs.computed, node2, "computed", computed);
    validate2(defs.static, node2, "static", _static);
    return node2;
  }
  function classAccessorProperty(key, value = null, typeAnnotation2 = null, decorators = null, computed = false, _static = false) {
    const node2 = {
      type: "ClassAccessorProperty",
      key,
      value,
      typeAnnotation: typeAnnotation2,
      decorators,
      computed,
      static: _static
    };
    const defs = NODE_FIELDS.ClassAccessorProperty;
    validate2(defs.key, node2, "key", key, 1);
    validate2(defs.value, node2, "value", value, 1);
    validate2(defs.typeAnnotation, node2, "typeAnnotation", typeAnnotation2, 1);
    validate2(defs.decorators, node2, "decorators", decorators, 1);
    validate2(defs.computed, node2, "computed", computed);
    validate2(defs.static, node2, "static", _static);
    return node2;
  }
  function classPrivateProperty(key, value = null, decorators = null, _static = false) {
    const node2 = {
      type: "ClassPrivateProperty",
      key,
      value,
      decorators,
      static: _static
    };
    const defs = NODE_FIELDS.ClassPrivateProperty;
    validate2(defs.key, node2, "key", key, 1);
    validate2(defs.value, node2, "value", value, 1);
    validate2(defs.decorators, node2, "decorators", decorators, 1);
    validate2(defs.static, node2, "static", _static);
    return node2;
  }
  function classPrivateMethod(kind = "method", key, params, body, _static = false) {
    const node2 = {
      type: "ClassPrivateMethod",
      kind,
      key,
      params,
      body,
      static: _static
    };
    const defs = NODE_FIELDS.ClassPrivateMethod;
    validate2(defs.kind, node2, "kind", kind);
    validate2(defs.key, node2, "key", key, 1);
    validate2(defs.params, node2, "params", params, 1);
    validate2(defs.body, node2, "body", body, 1);
    validate2(defs.static, node2, "static", _static);
    return node2;
  }
  function privateName(id) {
    const node2 = {
      type: "PrivateName",
      id
    };
    const defs = NODE_FIELDS.PrivateName;
    validate2(defs.id, node2, "id", id, 1);
    return node2;
  }
  function staticBlock(body) {
    const node2 = {
      type: "StaticBlock",
      body
    };
    const defs = NODE_FIELDS.StaticBlock;
    validate2(defs.body, node2, "body", body, 1);
    return node2;
  }
  function importAttribute(key, value) {
    const node2 = {
      type: "ImportAttribute",
      key,
      value
    };
    const defs = NODE_FIELDS.ImportAttribute;
    validate2(defs.key, node2, "key", key, 1);
    validate2(defs.value, node2, "value", value, 1);
    return node2;
  }
  function anyTypeAnnotation() {
    return {
      type: "AnyTypeAnnotation"
    };
  }
  function arrayTypeAnnotation(elementType) {
    const node2 = {
      type: "ArrayTypeAnnotation",
      elementType
    };
    const defs = NODE_FIELDS.ArrayTypeAnnotation;
    validate2(defs.elementType, node2, "elementType", elementType, 1);
    return node2;
  }
  function booleanTypeAnnotation() {
    return {
      type: "BooleanTypeAnnotation"
    };
  }
  function booleanLiteralTypeAnnotation(value) {
    const node2 = {
      type: "BooleanLiteralTypeAnnotation",
      value
    };
    const defs = NODE_FIELDS.BooleanLiteralTypeAnnotation;
    validate2(defs.value, node2, "value", value);
    return node2;
  }
  function nullLiteralTypeAnnotation() {
    return {
      type: "NullLiteralTypeAnnotation"
    };
  }
  function classImplements(id, typeParameters = null) {
    const node2 = {
      type: "ClassImplements",
      id,
      typeParameters
    };
    const defs = NODE_FIELDS.ClassImplements;
    validate2(defs.id, node2, "id", id, 1);
    validate2(defs.typeParameters, node2, "typeParameters", typeParameters, 1);
    return node2;
  }
  function declareClass(id, typeParameters = null, _extends = null, body) {
    const node2 = {
      type: "DeclareClass",
      id,
      typeParameters,
      extends: _extends,
      body
    };
    const defs = NODE_FIELDS.DeclareClass;
    validate2(defs.id, node2, "id", id, 1);
    validate2(defs.typeParameters, node2, "typeParameters", typeParameters, 1);
    validate2(defs.extends, node2, "extends", _extends, 1);
    validate2(defs.body, node2, "body", body, 1);
    return node2;
  }
  function declareFunction(id) {
    const node2 = {
      type: "DeclareFunction",
      id
    };
    const defs = NODE_FIELDS.DeclareFunction;
    validate2(defs.id, node2, "id", id, 1);
    return node2;
  }
  function declareInterface(id, typeParameters = null, _extends = null, body) {
    const node2 = {
      type: "DeclareInterface",
      id,
      typeParameters,
      extends: _extends,
      body
    };
    const defs = NODE_FIELDS.DeclareInterface;
    validate2(defs.id, node2, "id", id, 1);
    validate2(defs.typeParameters, node2, "typeParameters", typeParameters, 1);
    validate2(defs.extends, node2, "extends", _extends, 1);
    validate2(defs.body, node2, "body", body, 1);
    return node2;
  }
  function declareModule(id, body, kind = null) {
    const node2 = {
      type: "DeclareModule",
      id,
      body,
      kind
    };
    const defs = NODE_FIELDS.DeclareModule;
    validate2(defs.id, node2, "id", id, 1);
    validate2(defs.body, node2, "body", body, 1);
    validate2(defs.kind, node2, "kind", kind);
    return node2;
  }
  function declareModuleExports(typeAnnotation2) {
    const node2 = {
      type: "DeclareModuleExports",
      typeAnnotation: typeAnnotation2
    };
    const defs = NODE_FIELDS.DeclareModuleExports;
    validate2(defs.typeAnnotation, node2, "typeAnnotation", typeAnnotation2, 1);
    return node2;
  }
  function declareTypeAlias(id, typeParameters = null, right) {
    const node2 = {
      type: "DeclareTypeAlias",
      id,
      typeParameters,
      right
    };
    const defs = NODE_FIELDS.DeclareTypeAlias;
    validate2(defs.id, node2, "id", id, 1);
    validate2(defs.typeParameters, node2, "typeParameters", typeParameters, 1);
    validate2(defs.right, node2, "right", right, 1);
    return node2;
  }
  function declareOpaqueType(id, typeParameters = null, supertype = null) {
    const node2 = {
      type: "DeclareOpaqueType",
      id,
      typeParameters,
      supertype
    };
    const defs = NODE_FIELDS.DeclareOpaqueType;
    validate2(defs.id, node2, "id", id, 1);
    validate2(defs.typeParameters, node2, "typeParameters", typeParameters, 1);
    validate2(defs.supertype, node2, "supertype", supertype, 1);
    return node2;
  }
  function declareVariable(id) {
    const node2 = {
      type: "DeclareVariable",
      id
    };
    const defs = NODE_FIELDS.DeclareVariable;
    validate2(defs.id, node2, "id", id, 1);
    return node2;
  }
  function declareExportDeclaration(declaration = null, specifiers = null, source = null, attributes = null) {
    const node2 = {
      type: "DeclareExportDeclaration",
      declaration,
      specifiers,
      source,
      attributes
    };
    const defs = NODE_FIELDS.DeclareExportDeclaration;
    validate2(defs.declaration, node2, "declaration", declaration, 1);
    validate2(defs.specifiers, node2, "specifiers", specifiers, 1);
    validate2(defs.source, node2, "source", source, 1);
    validate2(defs.attributes, node2, "attributes", attributes, 1);
    return node2;
  }
  function declareExportAllDeclaration(source, attributes = null) {
    const node2 = {
      type: "DeclareExportAllDeclaration",
      source,
      attributes
    };
    const defs = NODE_FIELDS.DeclareExportAllDeclaration;
    validate2(defs.source, node2, "source", source, 1);
    validate2(defs.attributes, node2, "attributes", attributes, 1);
    return node2;
  }
  function declaredPredicate(value) {
    const node2 = {
      type: "DeclaredPredicate",
      value
    };
    const defs = NODE_FIELDS.DeclaredPredicate;
    validate2(defs.value, node2, "value", value, 1);
    return node2;
  }
  function existsTypeAnnotation() {
    return {
      type: "ExistsTypeAnnotation"
    };
  }
  function functionTypeAnnotation(typeParameters = null, params, rest = null, returnType) {
    const node2 = {
      type: "FunctionTypeAnnotation",
      typeParameters,
      params,
      rest,
      returnType
    };
    const defs = NODE_FIELDS.FunctionTypeAnnotation;
    validate2(defs.typeParameters, node2, "typeParameters", typeParameters, 1);
    validate2(defs.params, node2, "params", params, 1);
    validate2(defs.rest, node2, "rest", rest, 1);
    validate2(defs.returnType, node2, "returnType", returnType, 1);
    return node2;
  }
  function functionTypeParam(name = null, typeAnnotation2) {
    const node2 = {
      type: "FunctionTypeParam",
      name,
      typeAnnotation: typeAnnotation2
    };
    const defs = NODE_FIELDS.FunctionTypeParam;
    validate2(defs.name, node2, "name", name, 1);
    validate2(defs.typeAnnotation, node2, "typeAnnotation", typeAnnotation2, 1);
    return node2;
  }
  function genericTypeAnnotation(id, typeParameters = null) {
    const node2 = {
      type: "GenericTypeAnnotation",
      id,
      typeParameters
    };
    const defs = NODE_FIELDS.GenericTypeAnnotation;
    validate2(defs.id, node2, "id", id, 1);
    validate2(defs.typeParameters, node2, "typeParameters", typeParameters, 1);
    return node2;
  }
  function inferredPredicate() {
    return {
      type: "InferredPredicate"
    };
  }
  function interfaceExtends(id, typeParameters = null) {
    const node2 = {
      type: "InterfaceExtends",
      id,
      typeParameters
    };
    const defs = NODE_FIELDS.InterfaceExtends;
    validate2(defs.id, node2, "id", id, 1);
    validate2(defs.typeParameters, node2, "typeParameters", typeParameters, 1);
    return node2;
  }
  function interfaceDeclaration(id, typeParameters = null, _extends = null, body) {
    const node2 = {
      type: "InterfaceDeclaration",
      id,
      typeParameters,
      extends: _extends,
      body
    };
    const defs = NODE_FIELDS.InterfaceDeclaration;
    validate2(defs.id, node2, "id", id, 1);
    validate2(defs.typeParameters, node2, "typeParameters", typeParameters, 1);
    validate2(defs.extends, node2, "extends", _extends, 1);
    validate2(defs.body, node2, "body", body, 1);
    return node2;
  }
  function interfaceTypeAnnotation(_extends = null, body) {
    const node2 = {
      type: "InterfaceTypeAnnotation",
      extends: _extends,
      body
    };
    const defs = NODE_FIELDS.InterfaceTypeAnnotation;
    validate2(defs.extends, node2, "extends", _extends, 1);
    validate2(defs.body, node2, "body", body, 1);
    return node2;
  }
  function intersectionTypeAnnotation(types2) {
    const node2 = {
      type: "IntersectionTypeAnnotation",
      types: types2
    };
    const defs = NODE_FIELDS.IntersectionTypeAnnotation;
    validate2(defs.types, node2, "types", types2, 1);
    return node2;
  }
  function mixedTypeAnnotation() {
    return {
      type: "MixedTypeAnnotation"
    };
  }
  function emptyTypeAnnotation() {
    return {
      type: "EmptyTypeAnnotation"
    };
  }
  function nullableTypeAnnotation(typeAnnotation2) {
    const node2 = {
      type: "NullableTypeAnnotation",
      typeAnnotation: typeAnnotation2
    };
    const defs = NODE_FIELDS.NullableTypeAnnotation;
    validate2(defs.typeAnnotation, node2, "typeAnnotation", typeAnnotation2, 1);
    return node2;
  }
  function numberLiteralTypeAnnotation(value) {
    const node2 = {
      type: "NumberLiteralTypeAnnotation",
      value
    };
    const defs = NODE_FIELDS.NumberLiteralTypeAnnotation;
    validate2(defs.value, node2, "value", value);
    return node2;
  }
  function numberTypeAnnotation() {
    return {
      type: "NumberTypeAnnotation"
    };
  }
  function objectTypeAnnotation(properties, indexers = [], callProperties = [], internalSlots = [], exact = false) {
    const node2 = {
      type: "ObjectTypeAnnotation",
      properties,
      indexers,
      callProperties,
      internalSlots,
      exact
    };
    const defs = NODE_FIELDS.ObjectTypeAnnotation;
    validate2(defs.properties, node2, "properties", properties, 1);
    validate2(defs.indexers, node2, "indexers", indexers, 1);
    validate2(defs.callProperties, node2, "callProperties", callProperties, 1);
    validate2(defs.internalSlots, node2, "internalSlots", internalSlots, 1);
    validate2(defs.exact, node2, "exact", exact);
    return node2;
  }
  function objectTypeInternalSlot(id, value, optional, _static, method) {
    const node2 = {
      type: "ObjectTypeInternalSlot",
      id,
      value,
      optional,
      static: _static,
      method
    };
    const defs = NODE_FIELDS.ObjectTypeInternalSlot;
    validate2(defs.id, node2, "id", id, 1);
    validate2(defs.value, node2, "value", value, 1);
    validate2(defs.optional, node2, "optional", optional);
    validate2(defs.static, node2, "static", _static);
    validate2(defs.method, node2, "method", method);
    return node2;
  }
  function objectTypeCallProperty(value) {
    const node2 = {
      type: "ObjectTypeCallProperty",
      value,
      static: null
    };
    const defs = NODE_FIELDS.ObjectTypeCallProperty;
    validate2(defs.value, node2, "value", value, 1);
    return node2;
  }
  function objectTypeIndexer(id = null, key, value, variance2 = null) {
    const node2 = {
      type: "ObjectTypeIndexer",
      id,
      key,
      value,
      variance: variance2,
      static: null
    };
    const defs = NODE_FIELDS.ObjectTypeIndexer;
    validate2(defs.id, node2, "id", id, 1);
    validate2(defs.key, node2, "key", key, 1);
    validate2(defs.value, node2, "value", value, 1);
    validate2(defs.variance, node2, "variance", variance2, 1);
    return node2;
  }
  function objectTypeProperty(key, value, variance2 = null) {
    const node2 = {
      type: "ObjectTypeProperty",
      key,
      value,
      variance: variance2,
      kind: null,
      method: null,
      optional: null,
      proto: null,
      static: null
    };
    const defs = NODE_FIELDS.ObjectTypeProperty;
    validate2(defs.key, node2, "key", key, 1);
    validate2(defs.value, node2, "value", value, 1);
    validate2(defs.variance, node2, "variance", variance2, 1);
    return node2;
  }
  function objectTypeSpreadProperty(argument) {
    const node2 = {
      type: "ObjectTypeSpreadProperty",
      argument
    };
    const defs = NODE_FIELDS.ObjectTypeSpreadProperty;
    validate2(defs.argument, node2, "argument", argument, 1);
    return node2;
  }
  function opaqueType(id, typeParameters = null, supertype = null, impltype) {
    const node2 = {
      type: "OpaqueType",
      id,
      typeParameters,
      supertype,
      impltype
    };
    const defs = NODE_FIELDS.OpaqueType;
    validate2(defs.id, node2, "id", id, 1);
    validate2(defs.typeParameters, node2, "typeParameters", typeParameters, 1);
    validate2(defs.supertype, node2, "supertype", supertype, 1);
    validate2(defs.impltype, node2, "impltype", impltype, 1);
    return node2;
  }
  function qualifiedTypeIdentifier(id, qualification) {
    const node2 = {
      type: "QualifiedTypeIdentifier",
      id,
      qualification
    };
    const defs = NODE_FIELDS.QualifiedTypeIdentifier;
    validate2(defs.id, node2, "id", id, 1);
    validate2(defs.qualification, node2, "qualification", qualification, 1);
    return node2;
  }
  function stringLiteralTypeAnnotation(value) {
    const node2 = {
      type: "StringLiteralTypeAnnotation",
      value
    };
    const defs = NODE_FIELDS.StringLiteralTypeAnnotation;
    validate2(defs.value, node2, "value", value);
    return node2;
  }
  function stringTypeAnnotation() {
    return {
      type: "StringTypeAnnotation"
    };
  }
  function symbolTypeAnnotation() {
    return {
      type: "SymbolTypeAnnotation"
    };
  }
  function thisTypeAnnotation() {
    return {
      type: "ThisTypeAnnotation"
    };
  }
  function tupleTypeAnnotation(types2) {
    const node2 = {
      type: "TupleTypeAnnotation",
      types: types2
    };
    const defs = NODE_FIELDS.TupleTypeAnnotation;
    validate2(defs.types, node2, "types", types2, 1);
    return node2;
  }
  function typeofTypeAnnotation(argument) {
    const node2 = {
      type: "TypeofTypeAnnotation",
      argument
    };
    const defs = NODE_FIELDS.TypeofTypeAnnotation;
    validate2(defs.argument, node2, "argument", argument, 1);
    return node2;
  }
  function typeAlias(id, typeParameters = null, right) {
    const node2 = {
      type: "TypeAlias",
      id,
      typeParameters,
      right
    };
    const defs = NODE_FIELDS.TypeAlias;
    validate2(defs.id, node2, "id", id, 1);
    validate2(defs.typeParameters, node2, "typeParameters", typeParameters, 1);
    validate2(defs.right, node2, "right", right, 1);
    return node2;
  }
  function typeAnnotation(typeAnnotation2) {
    const node2 = {
      type: "TypeAnnotation",
      typeAnnotation: typeAnnotation2
    };
    const defs = NODE_FIELDS.TypeAnnotation;
    validate2(defs.typeAnnotation, node2, "typeAnnotation", typeAnnotation2, 1);
    return node2;
  }
  function typeCastExpression(expression, typeAnnotation2) {
    const node2 = {
      type: "TypeCastExpression",
      expression,
      typeAnnotation: typeAnnotation2
    };
    const defs = NODE_FIELDS.TypeCastExpression;
    validate2(defs.expression, node2, "expression", expression, 1);
    validate2(defs.typeAnnotation, node2, "typeAnnotation", typeAnnotation2, 1);
    return node2;
  }
  function typeParameter(bound = null, _default = null, variance2 = null) {
    const node2 = {
      type: "TypeParameter",
      bound,
      default: _default,
      variance: variance2,
      name: null
    };
    const defs = NODE_FIELDS.TypeParameter;
    validate2(defs.bound, node2, "bound", bound, 1);
    validate2(defs.default, node2, "default", _default, 1);
    validate2(defs.variance, node2, "variance", variance2, 1);
    return node2;
  }
  function typeParameterDeclaration(params) {
    const node2 = {
      type: "TypeParameterDeclaration",
      params
    };
    const defs = NODE_FIELDS.TypeParameterDeclaration;
    validate2(defs.params, node2, "params", params, 1);
    return node2;
  }
  function typeParameterInstantiation(params) {
    const node2 = {
      type: "TypeParameterInstantiation",
      params
    };
    const defs = NODE_FIELDS.TypeParameterInstantiation;
    validate2(defs.params, node2, "params", params, 1);
    return node2;
  }
  function unionTypeAnnotation(types2) {
    const node2 = {
      type: "UnionTypeAnnotation",
      types: types2
    };
    const defs = NODE_FIELDS.UnionTypeAnnotation;
    validate2(defs.types, node2, "types", types2, 1);
    return node2;
  }
  function variance(kind) {
    const node2 = {
      type: "Variance",
      kind
    };
    const defs = NODE_FIELDS.Variance;
    validate2(defs.kind, node2, "kind", kind);
    return node2;
  }
  function voidTypeAnnotation() {
    return {
      type: "VoidTypeAnnotation"
    };
  }
  function enumDeclaration(id, body) {
    const node2 = {
      type: "EnumDeclaration",
      id,
      body
    };
    const defs = NODE_FIELDS.EnumDeclaration;
    validate2(defs.id, node2, "id", id, 1);
    validate2(defs.body, node2, "body", body, 1);
    return node2;
  }
  function enumBooleanBody(members) {
    const node2 = {
      type: "EnumBooleanBody",
      members,
      explicitType: null,
      hasUnknownMembers: null
    };
    const defs = NODE_FIELDS.EnumBooleanBody;
    validate2(defs.members, node2, "members", members, 1);
    return node2;
  }
  function enumNumberBody(members) {
    const node2 = {
      type: "EnumNumberBody",
      members,
      explicitType: null,
      hasUnknownMembers: null
    };
    const defs = NODE_FIELDS.EnumNumberBody;
    validate2(defs.members, node2, "members", members, 1);
    return node2;
  }
  function enumStringBody(members) {
    const node2 = {
      type: "EnumStringBody",
      members,
      explicitType: null,
      hasUnknownMembers: null
    };
    const defs = NODE_FIELDS.EnumStringBody;
    validate2(defs.members, node2, "members", members, 1);
    return node2;
  }
  function enumSymbolBody(members) {
    const node2 = {
      type: "EnumSymbolBody",
      members,
      hasUnknownMembers: null
    };
    const defs = NODE_FIELDS.EnumSymbolBody;
    validate2(defs.members, node2, "members", members, 1);
    return node2;
  }
  function enumBooleanMember(id) {
    const node2 = {
      type: "EnumBooleanMember",
      id,
      init: null
    };
    const defs = NODE_FIELDS.EnumBooleanMember;
    validate2(defs.id, node2, "id", id, 1);
    return node2;
  }
  function enumNumberMember(id, init) {
    const node2 = {
      type: "EnumNumberMember",
      id,
      init
    };
    const defs = NODE_FIELDS.EnumNumberMember;
    validate2(defs.id, node2, "id", id, 1);
    validate2(defs.init, node2, "init", init, 1);
    return node2;
  }
  function enumStringMember(id, init) {
    const node2 = {
      type: "EnumStringMember",
      id,
      init
    };
    const defs = NODE_FIELDS.EnumStringMember;
    validate2(defs.id, node2, "id", id, 1);
    validate2(defs.init, node2, "init", init, 1);
    return node2;
  }
  function enumDefaultedMember(id) {
    const node2 = {
      type: "EnumDefaultedMember",
      id
    };
    const defs = NODE_FIELDS.EnumDefaultedMember;
    validate2(defs.id, node2, "id", id, 1);
    return node2;
  }
  function indexedAccessType(objectType, indexType) {
    const node2 = {
      type: "IndexedAccessType",
      objectType,
      indexType
    };
    const defs = NODE_FIELDS.IndexedAccessType;
    validate2(defs.objectType, node2, "objectType", objectType, 1);
    validate2(defs.indexType, node2, "indexType", indexType, 1);
    return node2;
  }
  function optionalIndexedAccessType(objectType, indexType) {
    const node2 = {
      type: "OptionalIndexedAccessType",
      objectType,
      indexType,
      optional: null
    };
    const defs = NODE_FIELDS.OptionalIndexedAccessType;
    validate2(defs.objectType, node2, "objectType", objectType, 1);
    validate2(defs.indexType, node2, "indexType", indexType, 1);
    return node2;
  }
  function jsxAttribute(name, value = null) {
    const node2 = {
      type: "JSXAttribute",
      name,
      value
    };
    const defs = NODE_FIELDS.JSXAttribute;
    validate2(defs.name, node2, "name", name, 1);
    validate2(defs.value, node2, "value", value, 1);
    return node2;
  }
  function jsxClosingElement(name) {
    const node2 = {
      type: "JSXClosingElement",
      name
    };
    const defs = NODE_FIELDS.JSXClosingElement;
    validate2(defs.name, node2, "name", name, 1);
    return node2;
  }
  function jsxElement(openingElement, closingElement = null, children, selfClosing = null) {
    const node2 = {
      type: "JSXElement",
      openingElement,
      closingElement,
      children,
      selfClosing
    };
    const defs = NODE_FIELDS.JSXElement;
    validate2(defs.openingElement, node2, "openingElement", openingElement, 1);
    validate2(defs.closingElement, node2, "closingElement", closingElement, 1);
    validate2(defs.children, node2, "children", children, 1);
    validate2(defs.selfClosing, node2, "selfClosing", selfClosing);
    return node2;
  }
  function jsxEmptyExpression() {
    return {
      type: "JSXEmptyExpression"
    };
  }
  function jsxExpressionContainer(expression) {
    const node2 = {
      type: "JSXExpressionContainer",
      expression
    };
    const defs = NODE_FIELDS.JSXExpressionContainer;
    validate2(defs.expression, node2, "expression", expression, 1);
    return node2;
  }
  function jsxSpreadChild(expression) {
    const node2 = {
      type: "JSXSpreadChild",
      expression
    };
    const defs = NODE_FIELDS.JSXSpreadChild;
    validate2(defs.expression, node2, "expression", expression, 1);
    return node2;
  }
  function jsxIdentifier(name) {
    const node2 = {
      type: "JSXIdentifier",
      name
    };
    const defs = NODE_FIELDS.JSXIdentifier;
    validate2(defs.name, node2, "name", name);
    return node2;
  }
  function jsxMemberExpression(object, property) {
    const node2 = {
      type: "JSXMemberExpression",
      object,
      property
    };
    const defs = NODE_FIELDS.JSXMemberExpression;
    validate2(defs.object, node2, "object", object, 1);
    validate2(defs.property, node2, "property", property, 1);
    return node2;
  }
  function jsxNamespacedName(namespace, name) {
    const node2 = {
      type: "JSXNamespacedName",
      namespace,
      name
    };
    const defs = NODE_FIELDS.JSXNamespacedName;
    validate2(defs.namespace, node2, "namespace", namespace, 1);
    validate2(defs.name, node2, "name", name, 1);
    return node2;
  }
  function jsxOpeningElement(name, attributes, selfClosing = false) {
    const node2 = {
      type: "JSXOpeningElement",
      name,
      attributes,
      selfClosing
    };
    const defs = NODE_FIELDS.JSXOpeningElement;
    validate2(defs.name, node2, "name", name, 1);
    validate2(defs.attributes, node2, "attributes", attributes, 1);
    validate2(defs.selfClosing, node2, "selfClosing", selfClosing);
    return node2;
  }
  function jsxSpreadAttribute(argument) {
    const node2 = {
      type: "JSXSpreadAttribute",
      argument
    };
    const defs = NODE_FIELDS.JSXSpreadAttribute;
    validate2(defs.argument, node2, "argument", argument, 1);
    return node2;
  }
  function jsxText(value) {
    const node2 = {
      type: "JSXText",
      value
    };
    const defs = NODE_FIELDS.JSXText;
    validate2(defs.value, node2, "value", value);
    return node2;
  }
  function jsxFragment(openingFragment, closingFragment, children) {
    const node2 = {
      type: "JSXFragment",
      openingFragment,
      closingFragment,
      children
    };
    const defs = NODE_FIELDS.JSXFragment;
    validate2(defs.openingFragment, node2, "openingFragment", openingFragment, 1);
    validate2(defs.closingFragment, node2, "closingFragment", closingFragment, 1);
    validate2(defs.children, node2, "children", children, 1);
    return node2;
  }
  function jsxOpeningFragment() {
    return {
      type: "JSXOpeningFragment"
    };
  }
  function jsxClosingFragment() {
    return {
      type: "JSXClosingFragment"
    };
  }
  function noop() {
    return {
      type: "Noop"
    };
  }
  function placeholder(expectedNode, name) {
    const node2 = {
      type: "Placeholder",
      expectedNode,
      name
    };
    const defs = NODE_FIELDS.Placeholder;
    validate2(defs.expectedNode, node2, "expectedNode", expectedNode);
    validate2(defs.name, node2, "name", name, 1);
    return node2;
  }
  function v8IntrinsicIdentifier(name) {
    const node2 = {
      type: "V8IntrinsicIdentifier",
      name
    };
    const defs = NODE_FIELDS.V8IntrinsicIdentifier;
    validate2(defs.name, node2, "name", name);
    return node2;
  }
  function argumentPlaceholder() {
    return {
      type: "ArgumentPlaceholder"
    };
  }
  function bindExpression(object, callee) {
    const node2 = {
      type: "BindExpression",
      object,
      callee
    };
    const defs = NODE_FIELDS.BindExpression;
    validate2(defs.object, node2, "object", object, 1);
    validate2(defs.callee, node2, "callee", callee, 1);
    return node2;
  }
  function decorator(expression) {
    const node2 = {
      type: "Decorator",
      expression
    };
    const defs = NODE_FIELDS.Decorator;
    validate2(defs.expression, node2, "expression", expression, 1);
    return node2;
  }
  function doExpression(body, async = false) {
    const node2 = {
      type: "DoExpression",
      body,
      async
    };
    const defs = NODE_FIELDS.DoExpression;
    validate2(defs.body, node2, "body", body, 1);
    validate2(defs.async, node2, "async", async);
    return node2;
  }
  function exportDefaultSpecifier(exported) {
    const node2 = {
      type: "ExportDefaultSpecifier",
      exported
    };
    const defs = NODE_FIELDS.ExportDefaultSpecifier;
    validate2(defs.exported, node2, "exported", exported, 1);
    return node2;
  }
  function recordExpression(properties) {
    const node2 = {
      type: "RecordExpression",
      properties
    };
    const defs = NODE_FIELDS.RecordExpression;
    validate2(defs.properties, node2, "properties", properties, 1);
    return node2;
  }
  function tupleExpression(elements = []) {
    const node2 = {
      type: "TupleExpression",
      elements
    };
    const defs = NODE_FIELDS.TupleExpression;
    validate2(defs.elements, node2, "elements", elements, 1);
    return node2;
  }
  function decimalLiteral(value) {
    const node2 = {
      type: "DecimalLiteral",
      value
    };
    const defs = NODE_FIELDS.DecimalLiteral;
    validate2(defs.value, node2, "value", value);
    return node2;
  }
  function moduleExpression(body) {
    const node2 = {
      type: "ModuleExpression",
      body
    };
    const defs = NODE_FIELDS.ModuleExpression;
    validate2(defs.body, node2, "body", body, 1);
    return node2;
  }
  function topicReference() {
    return {
      type: "TopicReference"
    };
  }
  function pipelineTopicExpression(expression) {
    const node2 = {
      type: "PipelineTopicExpression",
      expression
    };
    const defs = NODE_FIELDS.PipelineTopicExpression;
    validate2(defs.expression, node2, "expression", expression, 1);
    return node2;
  }
  function pipelineBareFunction(callee) {
    const node2 = {
      type: "PipelineBareFunction",
      callee
    };
    const defs = NODE_FIELDS.PipelineBareFunction;
    validate2(defs.callee, node2, "callee", callee, 1);
    return node2;
  }
  function pipelinePrimaryTopicReference() {
    return {
      type: "PipelinePrimaryTopicReference"
    };
  }
  function voidPattern() {
    return {
      type: "VoidPattern"
    };
  }
  function tsParameterProperty(parameter) {
    const node2 = {
      type: "TSParameterProperty",
      parameter
    };
    const defs = NODE_FIELDS.TSParameterProperty;
    validate2(defs.parameter, node2, "parameter", parameter, 1);
    return node2;
  }
  function tsDeclareFunction(id = null, typeParameters = null, params, returnType = null) {
    const node2 = {
      type: "TSDeclareFunction",
      id,
      typeParameters,
      params,
      returnType
    };
    const defs = NODE_FIELDS.TSDeclareFunction;
    validate2(defs.id, node2, "id", id, 1);
    validate2(defs.typeParameters, node2, "typeParameters", typeParameters, 1);
    validate2(defs.params, node2, "params", params, 1);
    validate2(defs.returnType, node2, "returnType", returnType, 1);
    return node2;
  }
  function tsDeclareMethod(decorators = null, key, typeParameters = null, params, returnType = null) {
    const node2 = {
      type: "TSDeclareMethod",
      decorators,
      key,
      typeParameters,
      params,
      returnType
    };
    const defs = NODE_FIELDS.TSDeclareMethod;
    validate2(defs.decorators, node2, "decorators", decorators, 1);
    validate2(defs.key, node2, "key", key, 1);
    validate2(defs.typeParameters, node2, "typeParameters", typeParameters, 1);
    validate2(defs.params, node2, "params", params, 1);
    validate2(defs.returnType, node2, "returnType", returnType, 1);
    return node2;
  }
  function tsQualifiedName(left, right) {
    const node2 = {
      type: "TSQualifiedName",
      left,
      right
    };
    const defs = NODE_FIELDS.TSQualifiedName;
    validate2(defs.left, node2, "left", left, 1);
    validate2(defs.right, node2, "right", right, 1);
    return node2;
  }
  function tsCallSignatureDeclaration(typeParameters = null, parameters, typeAnnotation2 = null) {
    const node2 = {
      type: "TSCallSignatureDeclaration",
      typeParameters,
      parameters,
      typeAnnotation: typeAnnotation2
    };
    const defs = NODE_FIELDS.TSCallSignatureDeclaration;
    validate2(defs.typeParameters, node2, "typeParameters", typeParameters, 1);
    validate2(defs.parameters, node2, "parameters", parameters, 1);
    validate2(defs.typeAnnotation, node2, "typeAnnotation", typeAnnotation2, 1);
    return node2;
  }
  function tsConstructSignatureDeclaration(typeParameters = null, parameters, typeAnnotation2 = null) {
    const node2 = {
      type: "TSConstructSignatureDeclaration",
      typeParameters,
      parameters,
      typeAnnotation: typeAnnotation2
    };
    const defs = NODE_FIELDS.TSConstructSignatureDeclaration;
    validate2(defs.typeParameters, node2, "typeParameters", typeParameters, 1);
    validate2(defs.parameters, node2, "parameters", parameters, 1);
    validate2(defs.typeAnnotation, node2, "typeAnnotation", typeAnnotation2, 1);
    return node2;
  }
  function tsPropertySignature(key, typeAnnotation2 = null) {
    const node2 = {
      type: "TSPropertySignature",
      key,
      typeAnnotation: typeAnnotation2
    };
    const defs = NODE_FIELDS.TSPropertySignature;
    validate2(defs.key, node2, "key", key, 1);
    validate2(defs.typeAnnotation, node2, "typeAnnotation", typeAnnotation2, 1);
    return node2;
  }
  function tsMethodSignature(key, typeParameters = null, parameters, typeAnnotation2 = null) {
    const node2 = {
      type: "TSMethodSignature",
      key,
      typeParameters,
      parameters,
      typeAnnotation: typeAnnotation2,
      kind: null
    };
    const defs = NODE_FIELDS.TSMethodSignature;
    validate2(defs.key, node2, "key", key, 1);
    validate2(defs.typeParameters, node2, "typeParameters", typeParameters, 1);
    validate2(defs.parameters, node2, "parameters", parameters, 1);
    validate2(defs.typeAnnotation, node2, "typeAnnotation", typeAnnotation2, 1);
    return node2;
  }
  function tsIndexSignature(parameters, typeAnnotation2 = null) {
    const node2 = {
      type: "TSIndexSignature",
      parameters,
      typeAnnotation: typeAnnotation2
    };
    const defs = NODE_FIELDS.TSIndexSignature;
    validate2(defs.parameters, node2, "parameters", parameters, 1);
    validate2(defs.typeAnnotation, node2, "typeAnnotation", typeAnnotation2, 1);
    return node2;
  }
  function tsAnyKeyword() {
    return {
      type: "TSAnyKeyword"
    };
  }
  function tsBooleanKeyword() {
    return {
      type: "TSBooleanKeyword"
    };
  }
  function tsBigIntKeyword() {
    return {
      type: "TSBigIntKeyword"
    };
  }
  function tsIntrinsicKeyword() {
    return {
      type: "TSIntrinsicKeyword"
    };
  }
  function tsNeverKeyword() {
    return {
      type: "TSNeverKeyword"
    };
  }
  function tsNullKeyword() {
    return {
      type: "TSNullKeyword"
    };
  }
  function tsNumberKeyword() {
    return {
      type: "TSNumberKeyword"
    };
  }
  function tsObjectKeyword() {
    return {
      type: "TSObjectKeyword"
    };
  }
  function tsStringKeyword() {
    return {
      type: "TSStringKeyword"
    };
  }
  function tsSymbolKeyword() {
    return {
      type: "TSSymbolKeyword"
    };
  }
  function tsUndefinedKeyword() {
    return {
      type: "TSUndefinedKeyword"
    };
  }
  function tsUnknownKeyword() {
    return {
      type: "TSUnknownKeyword"
    };
  }
  function tsVoidKeyword() {
    return {
      type: "TSVoidKeyword"
    };
  }
  function tsThisType() {
    return {
      type: "TSThisType"
    };
  }
  function tsFunctionType(typeParameters = null, parameters, typeAnnotation2 = null) {
    const node2 = {
      type: "TSFunctionType",
      typeParameters,
      parameters,
      typeAnnotation: typeAnnotation2
    };
    const defs = NODE_FIELDS.TSFunctionType;
    validate2(defs.typeParameters, node2, "typeParameters", typeParameters, 1);
    validate2(defs.parameters, node2, "parameters", parameters, 1);
    validate2(defs.typeAnnotation, node2, "typeAnnotation", typeAnnotation2, 1);
    return node2;
  }
  function tsConstructorType(typeParameters = null, parameters, typeAnnotation2 = null) {
    const node2 = {
      type: "TSConstructorType",
      typeParameters,
      parameters,
      typeAnnotation: typeAnnotation2
    };
    const defs = NODE_FIELDS.TSConstructorType;
    validate2(defs.typeParameters, node2, "typeParameters", typeParameters, 1);
    validate2(defs.parameters, node2, "parameters", parameters, 1);
    validate2(defs.typeAnnotation, node2, "typeAnnotation", typeAnnotation2, 1);
    return node2;
  }
  function tsTypeReference(typeName, typeParameters = null) {
    const node2 = {
      type: "TSTypeReference",
      typeName,
      typeParameters
    };
    const defs = NODE_FIELDS.TSTypeReference;
    validate2(defs.typeName, node2, "typeName", typeName, 1);
    validate2(defs.typeParameters, node2, "typeParameters", typeParameters, 1);
    return node2;
  }
  function tsTypePredicate(parameterName, typeAnnotation2 = null, asserts = null) {
    const node2 = {
      type: "TSTypePredicate",
      parameterName,
      typeAnnotation: typeAnnotation2,
      asserts
    };
    const defs = NODE_FIELDS.TSTypePredicate;
    validate2(defs.parameterName, node2, "parameterName", parameterName, 1);
    validate2(defs.typeAnnotation, node2, "typeAnnotation", typeAnnotation2, 1);
    validate2(defs.asserts, node2, "asserts", asserts);
    return node2;
  }
  function tsTypeQuery(exprName, typeParameters = null) {
    const node2 = {
      type: "TSTypeQuery",
      exprName,
      typeParameters
    };
    const defs = NODE_FIELDS.TSTypeQuery;
    validate2(defs.exprName, node2, "exprName", exprName, 1);
    validate2(defs.typeParameters, node2, "typeParameters", typeParameters, 1);
    return node2;
  }
  function tsTypeLiteral(members) {
    const node2 = {
      type: "TSTypeLiteral",
      members
    };
    const defs = NODE_FIELDS.TSTypeLiteral;
    validate2(defs.members, node2, "members", members, 1);
    return node2;
  }
  function tsArrayType(elementType) {
    const node2 = {
      type: "TSArrayType",
      elementType
    };
    const defs = NODE_FIELDS.TSArrayType;
    validate2(defs.elementType, node2, "elementType", elementType, 1);
    return node2;
  }
  function tsTupleType(elementTypes) {
    const node2 = {
      type: "TSTupleType",
      elementTypes
    };
    const defs = NODE_FIELDS.TSTupleType;
    validate2(defs.elementTypes, node2, "elementTypes", elementTypes, 1);
    return node2;
  }
  function tsOptionalType(typeAnnotation2) {
    const node2 = {
      type: "TSOptionalType",
      typeAnnotation: typeAnnotation2
    };
    const defs = NODE_FIELDS.TSOptionalType;
    validate2(defs.typeAnnotation, node2, "typeAnnotation", typeAnnotation2, 1);
    return node2;
  }
  function tsRestType(typeAnnotation2) {
    const node2 = {
      type: "TSRestType",
      typeAnnotation: typeAnnotation2
    };
    const defs = NODE_FIELDS.TSRestType;
    validate2(defs.typeAnnotation, node2, "typeAnnotation", typeAnnotation2, 1);
    return node2;
  }
  function tsNamedTupleMember(label, elementType, optional = false) {
    const node2 = {
      type: "TSNamedTupleMember",
      label,
      elementType,
      optional
    };
    const defs = NODE_FIELDS.TSNamedTupleMember;
    validate2(defs.label, node2, "label", label, 1);
    validate2(defs.elementType, node2, "elementType", elementType, 1);
    validate2(defs.optional, node2, "optional", optional);
    return node2;
  }
  function tsUnionType(types2) {
    const node2 = {
      type: "TSUnionType",
      types: types2
    };
    const defs = NODE_FIELDS.TSUnionType;
    validate2(defs.types, node2, "types", types2, 1);
    return node2;
  }
  function tsIntersectionType(types2) {
    const node2 = {
      type: "TSIntersectionType",
      types: types2
    };
    const defs = NODE_FIELDS.TSIntersectionType;
    validate2(defs.types, node2, "types", types2, 1);
    return node2;
  }
  function tsConditionalType(checkType, extendsType, trueType, falseType) {
    const node2 = {
      type: "TSConditionalType",
      checkType,
      extendsType,
      trueType,
      falseType
    };
    const defs = NODE_FIELDS.TSConditionalType;
    validate2(defs.checkType, node2, "checkType", checkType, 1);
    validate2(defs.extendsType, node2, "extendsType", extendsType, 1);
    validate2(defs.trueType, node2, "trueType", trueType, 1);
    validate2(defs.falseType, node2, "falseType", falseType, 1);
    return node2;
  }
  function tsInferType(typeParameter2) {
    const node2 = {
      type: "TSInferType",
      typeParameter: typeParameter2
    };
    const defs = NODE_FIELDS.TSInferType;
    validate2(defs.typeParameter, node2, "typeParameter", typeParameter2, 1);
    return node2;
  }
  function tsParenthesizedType(typeAnnotation2) {
    const node2 = {
      type: "TSParenthesizedType",
      typeAnnotation: typeAnnotation2
    };
    const defs = NODE_FIELDS.TSParenthesizedType;
    validate2(defs.typeAnnotation, node2, "typeAnnotation", typeAnnotation2, 1);
    return node2;
  }
  function tsTypeOperator(typeAnnotation2, operator = "keyof") {
    const node2 = {
      type: "TSTypeOperator",
      typeAnnotation: typeAnnotation2,
      operator
    };
    const defs = NODE_FIELDS.TSTypeOperator;
    validate2(defs.typeAnnotation, node2, "typeAnnotation", typeAnnotation2, 1);
    validate2(defs.operator, node2, "operator", operator);
    return node2;
  }
  function tsIndexedAccessType(objectType, indexType) {
    const node2 = {
      type: "TSIndexedAccessType",
      objectType,
      indexType
    };
    const defs = NODE_FIELDS.TSIndexedAccessType;
    validate2(defs.objectType, node2, "objectType", objectType, 1);
    validate2(defs.indexType, node2, "indexType", indexType, 1);
    return node2;
  }
  function tsMappedType(typeParameter2, typeAnnotation2 = null, nameType = null) {
    const node2 = {
      type: "TSMappedType",
      typeParameter: typeParameter2,
      typeAnnotation: typeAnnotation2,
      nameType
    };
    const defs = NODE_FIELDS.TSMappedType;
    validate2(defs.typeParameter, node2, "typeParameter", typeParameter2, 1);
    validate2(defs.typeAnnotation, node2, "typeAnnotation", typeAnnotation2, 1);
    validate2(defs.nameType, node2, "nameType", nameType, 1);
    return node2;
  }
  function tsTemplateLiteralType(quasis, types2) {
    const node2 = {
      type: "TSTemplateLiteralType",
      quasis,
      types: types2
    };
    const defs = NODE_FIELDS.TSTemplateLiteralType;
    validate2(defs.quasis, node2, "quasis", quasis, 1);
    validate2(defs.types, node2, "types", types2, 1);
    return node2;
  }
  function tsLiteralType(literal2) {
    const node2 = {
      type: "TSLiteralType",
      literal: literal2
    };
    const defs = NODE_FIELDS.TSLiteralType;
    validate2(defs.literal, node2, "literal", literal2, 1);
    return node2;
  }
  function tsExpressionWithTypeArguments(expression, typeParameters = null) {
    const node2 = {
      type: "TSExpressionWithTypeArguments",
      expression,
      typeParameters
    };
    const defs = NODE_FIELDS.TSExpressionWithTypeArguments;
    validate2(defs.expression, node2, "expression", expression, 1);
    validate2(defs.typeParameters, node2, "typeParameters", typeParameters, 1);
    return node2;
  }
  function tsInterfaceDeclaration(id, typeParameters = null, _extends = null, body) {
    const node2 = {
      type: "TSInterfaceDeclaration",
      id,
      typeParameters,
      extends: _extends,
      body
    };
    const defs = NODE_FIELDS.TSInterfaceDeclaration;
    validate2(defs.id, node2, "id", id, 1);
    validate2(defs.typeParameters, node2, "typeParameters", typeParameters, 1);
    validate2(defs.extends, node2, "extends", _extends, 1);
    validate2(defs.body, node2, "body", body, 1);
    return node2;
  }
  function tsInterfaceBody(body) {
    const node2 = {
      type: "TSInterfaceBody",
      body
    };
    const defs = NODE_FIELDS.TSInterfaceBody;
    validate2(defs.body, node2, "body", body, 1);
    return node2;
  }
  function tsTypeAliasDeclaration(id, typeParameters = null, typeAnnotation2) {
    const node2 = {
      type: "TSTypeAliasDeclaration",
      id,
      typeParameters,
      typeAnnotation: typeAnnotation2
    };
    const defs = NODE_FIELDS.TSTypeAliasDeclaration;
    validate2(defs.id, node2, "id", id, 1);
    validate2(defs.typeParameters, node2, "typeParameters", typeParameters, 1);
    validate2(defs.typeAnnotation, node2, "typeAnnotation", typeAnnotation2, 1);
    return node2;
  }
  function tsInstantiationExpression(expression, typeParameters = null) {
    const node2 = {
      type: "TSInstantiationExpression",
      expression,
      typeParameters
    };
    const defs = NODE_FIELDS.TSInstantiationExpression;
    validate2(defs.expression, node2, "expression", expression, 1);
    validate2(defs.typeParameters, node2, "typeParameters", typeParameters, 1);
    return node2;
  }
  function tsAsExpression(expression, typeAnnotation2) {
    const node2 = {
      type: "TSAsExpression",
      expression,
      typeAnnotation: typeAnnotation2
    };
    const defs = NODE_FIELDS.TSAsExpression;
    validate2(defs.expression, node2, "expression", expression, 1);
    validate2(defs.typeAnnotation, node2, "typeAnnotation", typeAnnotation2, 1);
    return node2;
  }
  function tsSatisfiesExpression(expression, typeAnnotation2) {
    const node2 = {
      type: "TSSatisfiesExpression",
      expression,
      typeAnnotation: typeAnnotation2
    };
    const defs = NODE_FIELDS.TSSatisfiesExpression;
    validate2(defs.expression, node2, "expression", expression, 1);
    validate2(defs.typeAnnotation, node2, "typeAnnotation", typeAnnotation2, 1);
    return node2;
  }
  function tsTypeAssertion(typeAnnotation2, expression) {
    const node2 = {
      type: "TSTypeAssertion",
      typeAnnotation: typeAnnotation2,
      expression
    };
    const defs = NODE_FIELDS.TSTypeAssertion;
    validate2(defs.typeAnnotation, node2, "typeAnnotation", typeAnnotation2, 1);
    validate2(defs.expression, node2, "expression", expression, 1);
    return node2;
  }
  function tsEnumBody(members) {
    const node2 = {
      type: "TSEnumBody",
      members
    };
    const defs = NODE_FIELDS.TSEnumBody;
    validate2(defs.members, node2, "members", members, 1);
    return node2;
  }
  function tsEnumDeclaration(id, members) {
    const node2 = {
      type: "TSEnumDeclaration",
      id,
      members
    };
    const defs = NODE_FIELDS.TSEnumDeclaration;
    validate2(defs.id, node2, "id", id, 1);
    validate2(defs.members, node2, "members", members, 1);
    return node2;
  }
  function tsEnumMember(id, initializer = null) {
    const node2 = {
      type: "TSEnumMember",
      id,
      initializer
    };
    const defs = NODE_FIELDS.TSEnumMember;
    validate2(defs.id, node2, "id", id, 1);
    validate2(defs.initializer, node2, "initializer", initializer, 1);
    return node2;
  }
  function tsModuleDeclaration(id, body) {
    const node2 = {
      type: "TSModuleDeclaration",
      id,
      body,
      kind: null
    };
    const defs = NODE_FIELDS.TSModuleDeclaration;
    validate2(defs.id, node2, "id", id, 1);
    validate2(defs.body, node2, "body", body, 1);
    return node2;
  }
  function tsModuleBlock(body) {
    const node2 = {
      type: "TSModuleBlock",
      body
    };
    const defs = NODE_FIELDS.TSModuleBlock;
    validate2(defs.body, node2, "body", body, 1);
    return node2;
  }
  function tsImportType(argument, qualifier = null, typeParameters = null) {
    const node2 = {
      type: "TSImportType",
      argument,
      qualifier,
      typeParameters
    };
    const defs = NODE_FIELDS.TSImportType;
    validate2(defs.argument, node2, "argument", argument, 1);
    validate2(defs.qualifier, node2, "qualifier", qualifier, 1);
    validate2(defs.typeParameters, node2, "typeParameters", typeParameters, 1);
    return node2;
  }
  function tsImportEqualsDeclaration(id, moduleReference) {
    const node2 = {
      type: "TSImportEqualsDeclaration",
      id,
      moduleReference,
      isExport: null
    };
    const defs = NODE_FIELDS.TSImportEqualsDeclaration;
    validate2(defs.id, node2, "id", id, 1);
    validate2(defs.moduleReference, node2, "moduleReference", moduleReference, 1);
    return node2;
  }
  function tsExternalModuleReference(expression) {
    const node2 = {
      type: "TSExternalModuleReference",
      expression
    };
    const defs = NODE_FIELDS.TSExternalModuleReference;
    validate2(defs.expression, node2, "expression", expression, 1);
    return node2;
  }
  function tsNonNullExpression(expression) {
    const node2 = {
      type: "TSNonNullExpression",
      expression
    };
    const defs = NODE_FIELDS.TSNonNullExpression;
    validate2(defs.expression, node2, "expression", expression, 1);
    return node2;
  }
  function tsExportAssignment(expression) {
    const node2 = {
      type: "TSExportAssignment",
      expression
    };
    const defs = NODE_FIELDS.TSExportAssignment;
    validate2(defs.expression, node2, "expression", expression, 1);
    return node2;
  }
  function tsNamespaceExportDeclaration(id) {
    const node2 = {
      type: "TSNamespaceExportDeclaration",
      id
    };
    const defs = NODE_FIELDS.TSNamespaceExportDeclaration;
    validate2(defs.id, node2, "id", id, 1);
    return node2;
  }
  function tsTypeAnnotation(typeAnnotation2) {
    const node2 = {
      type: "TSTypeAnnotation",
      typeAnnotation: typeAnnotation2
    };
    const defs = NODE_FIELDS.TSTypeAnnotation;
    validate2(defs.typeAnnotation, node2, "typeAnnotation", typeAnnotation2, 1);
    return node2;
  }
  function tsTypeParameterInstantiation(params) {
    const node2 = {
      type: "TSTypeParameterInstantiation",
      params
    };
    const defs = NODE_FIELDS.TSTypeParameterInstantiation;
    validate2(defs.params, node2, "params", params, 1);
    return node2;
  }
  function tsTypeParameterDeclaration(params) {
    const node2 = {
      type: "TSTypeParameterDeclaration",
      params
    };
    const defs = NODE_FIELDS.TSTypeParameterDeclaration;
    validate2(defs.params, node2, "params", params, 1);
    return node2;
  }
  function tsTypeParameter(constraint = null, _default = null, name) {
    const node2 = {
      type: "TSTypeParameter",
      constraint,
      default: _default,
      name
    };
    const defs = NODE_FIELDS.TSTypeParameter;
    validate2(defs.constraint, node2, "constraint", constraint, 1);
    validate2(defs.default, node2, "default", _default, 1);
    validate2(defs.name, node2, "name", name);
    return node2;
  }
  function NumberLiteral(value) {
    (0, _deprecationWarning.default)("NumberLiteral", "NumericLiteral", "The node type ");
    return numericLiteral(value);
  }
  function RegexLiteral(pattern, flags = "") {
    (0, _deprecationWarning.default)("RegexLiteral", "RegExpLiteral", "The node type ");
    return regExpLiteral(pattern, flags);
  }
  function RestProperty(argument) {
    (0, _deprecationWarning.default)("RestProperty", "RestElement", "The node type ");
    return restElement(argument);
  }
  function SpreadProperty(argument) {
    (0, _deprecationWarning.default)("SpreadProperty", "SpreadElement", "The node type ");
    return spreadElement(argument);
  }
  return lowercase;
}
var uppercase = {};
var hasRequiredUppercase;
function requireUppercase() {
  if (hasRequiredUppercase) return uppercase;
  hasRequiredUppercase = 1;
  Object.defineProperty(uppercase, "__esModule", {
    value: true
  });
  uppercase.JSXIdentifier = uppercase.JSXFragment = uppercase.JSXExpressionContainer = uppercase.JSXEmptyExpression = uppercase.JSXElement = uppercase.JSXClosingFragment = uppercase.JSXClosingElement = uppercase.JSXAttribute = uppercase.IntersectionTypeAnnotation = uppercase.InterpreterDirective = uppercase.InterfaceTypeAnnotation = uppercase.InterfaceExtends = uppercase.InterfaceDeclaration = uppercase.InferredPredicate = uppercase.IndexedAccessType = uppercase.ImportSpecifier = uppercase.ImportNamespaceSpecifier = uppercase.ImportExpression = uppercase.ImportDefaultSpecifier = uppercase.ImportDeclaration = uppercase.ImportAttribute = uppercase.Import = uppercase.IfStatement = uppercase.Identifier = uppercase.GenericTypeAnnotation = uppercase.FunctionTypeParam = uppercase.FunctionTypeAnnotation = uppercase.FunctionExpression = uppercase.FunctionDeclaration = uppercase.ForStatement = uppercase.ForOfStatement = uppercase.ForInStatement = uppercase.File = uppercase.ExpressionStatement = uppercase.ExportSpecifier = uppercase.ExportNamespaceSpecifier = uppercase.ExportNamedDeclaration = uppercase.ExportDefaultSpecifier = uppercase.ExportDefaultDeclaration = uppercase.ExportAllDeclaration = uppercase.ExistsTypeAnnotation = uppercase.EnumSymbolBody = uppercase.EnumStringMember = uppercase.EnumStringBody = uppercase.EnumNumberMember = uppercase.EnumNumberBody = uppercase.EnumDefaultedMember = uppercase.EnumDeclaration = uppercase.EnumBooleanMember = uppercase.EnumBooleanBody = uppercase.EmptyTypeAnnotation = uppercase.EmptyStatement = uppercase.DoWhileStatement = uppercase.DoExpression = uppercase.DirectiveLiteral = uppercase.Directive = uppercase.Decorator = uppercase.DeclaredPredicate = uppercase.DeclareVariable = uppercase.DeclareTypeAlias = uppercase.DeclareOpaqueType = uppercase.DeclareModuleExports = uppercase.DeclareModule = uppercase.DeclareInterface = uppercase.DeclareFunction = uppercase.DeclareExportDeclaration = uppercase.DeclareExportAllDeclaration = uppercase.DeclareClass = uppercase.DecimalLiteral = uppercase.DebuggerStatement = uppercase.ContinueStatement = uppercase.ConditionalExpression = uppercase.ClassProperty = uppercase.ClassPrivateProperty = uppercase.ClassPrivateMethod = uppercase.ClassMethod = uppercase.ClassImplements = uppercase.ClassExpression = uppercase.ClassDeclaration = uppercase.ClassBody = uppercase.ClassAccessorProperty = uppercase.CatchClause = uppercase.CallExpression = uppercase.BreakStatement = uppercase.BooleanTypeAnnotation = uppercase.BooleanLiteralTypeAnnotation = uppercase.BooleanLiteral = uppercase.BlockStatement = uppercase.BindExpression = uppercase.BinaryExpression = uppercase.BigIntLiteral = uppercase.AwaitExpression = uppercase.AssignmentPattern = uppercase.AssignmentExpression = uppercase.ArrowFunctionExpression = uppercase.ArrayTypeAnnotation = uppercase.ArrayPattern = uppercase.ArrayExpression = uppercase.ArgumentPlaceholder = uppercase.AnyTypeAnnotation = void 0;
  uppercase.TSNumberKeyword = uppercase.TSNullKeyword = uppercase.TSNonNullExpression = uppercase.TSNeverKeyword = uppercase.TSNamespaceExportDeclaration = uppercase.TSNamedTupleMember = uppercase.TSModuleDeclaration = uppercase.TSModuleBlock = uppercase.TSMethodSignature = uppercase.TSMappedType = uppercase.TSLiteralType = uppercase.TSIntrinsicKeyword = uppercase.TSIntersectionType = uppercase.TSInterfaceDeclaration = uppercase.TSInterfaceBody = uppercase.TSInstantiationExpression = uppercase.TSInferType = uppercase.TSIndexedAccessType = uppercase.TSIndexSignature = uppercase.TSImportType = uppercase.TSImportEqualsDeclaration = uppercase.TSFunctionType = uppercase.TSExternalModuleReference = uppercase.TSExpressionWithTypeArguments = uppercase.TSExportAssignment = uppercase.TSEnumMember = uppercase.TSEnumDeclaration = uppercase.TSEnumBody = uppercase.TSDeclareMethod = uppercase.TSDeclareFunction = uppercase.TSConstructorType = uppercase.TSConstructSignatureDeclaration = uppercase.TSConditionalType = uppercase.TSCallSignatureDeclaration = uppercase.TSBooleanKeyword = uppercase.TSBigIntKeyword = uppercase.TSAsExpression = uppercase.TSArrayType = uppercase.TSAnyKeyword = uppercase.SymbolTypeAnnotation = uppercase.SwitchStatement = uppercase.SwitchCase = uppercase.Super = uppercase.StringTypeAnnotation = uppercase.StringLiteralTypeAnnotation = uppercase.StringLiteral = uppercase.StaticBlock = uppercase.SpreadProperty = uppercase.SpreadElement = uppercase.SequenceExpression = uppercase.ReturnStatement = uppercase.RestProperty = uppercase.RestElement = uppercase.RegexLiteral = uppercase.RegExpLiteral = uppercase.RecordExpression = uppercase.QualifiedTypeIdentifier = uppercase.Program = uppercase.PrivateName = uppercase.Placeholder = uppercase.PipelineTopicExpression = uppercase.PipelinePrimaryTopicReference = uppercase.PipelineBareFunction = uppercase.ParenthesizedExpression = uppercase.OptionalMemberExpression = uppercase.OptionalIndexedAccessType = uppercase.OptionalCallExpression = uppercase.OpaqueType = uppercase.ObjectTypeSpreadProperty = uppercase.ObjectTypeProperty = uppercase.ObjectTypeInternalSlot = uppercase.ObjectTypeIndexer = uppercase.ObjectTypeCallProperty = uppercase.ObjectTypeAnnotation = uppercase.ObjectProperty = uppercase.ObjectPattern = uppercase.ObjectMethod = uppercase.ObjectExpression = uppercase.NumericLiteral = uppercase.NumberTypeAnnotation = uppercase.NumberLiteralTypeAnnotation = uppercase.NumberLiteral = uppercase.NullableTypeAnnotation = uppercase.NullLiteralTypeAnnotation = uppercase.NullLiteral = uppercase.Noop = uppercase.NewExpression = uppercase.ModuleExpression = uppercase.MixedTypeAnnotation = uppercase.MetaProperty = uppercase.MemberExpression = uppercase.LogicalExpression = uppercase.LabeledStatement = uppercase.JSXText = uppercase.JSXSpreadChild = uppercase.JSXSpreadAttribute = uppercase.JSXOpeningFragment = uppercase.JSXOpeningElement = uppercase.JSXNamespacedName = uppercase.JSXMemberExpression = void 0;
  uppercase.YieldExpression = uppercase.WithStatement = uppercase.WhileStatement = uppercase.VoidTypeAnnotation = uppercase.VoidPattern = uppercase.Variance = uppercase.VariableDeclarator = uppercase.VariableDeclaration = uppercase.V8IntrinsicIdentifier = uppercase.UpdateExpression = uppercase.UnionTypeAnnotation = uppercase.UnaryExpression = uppercase.TypeofTypeAnnotation = uppercase.TypeParameterInstantiation = uppercase.TypeParameterDeclaration = uppercase.TypeParameter = uppercase.TypeCastExpression = uppercase.TypeAnnotation = uppercase.TypeAlias = uppercase.TupleTypeAnnotation = uppercase.TupleExpression = uppercase.TryStatement = uppercase.TopicReference = uppercase.ThrowStatement = uppercase.ThisTypeAnnotation = uppercase.ThisExpression = uppercase.TemplateLiteral = uppercase.TemplateElement = uppercase.TaggedTemplateExpression = uppercase.TSVoidKeyword = uppercase.TSUnknownKeyword = uppercase.TSUnionType = uppercase.TSUndefinedKeyword = uppercase.TSTypeReference = uppercase.TSTypeQuery = uppercase.TSTypePredicate = uppercase.TSTypeParameterInstantiation = uppercase.TSTypeParameterDeclaration = uppercase.TSTypeParameter = uppercase.TSTypeOperator = uppercase.TSTypeLiteral = uppercase.TSTypeAssertion = uppercase.TSTypeAnnotation = uppercase.TSTypeAliasDeclaration = uppercase.TSTupleType = uppercase.TSThisType = uppercase.TSTemplateLiteralType = uppercase.TSSymbolKeyword = uppercase.TSStringKeyword = uppercase.TSSatisfiesExpression = uppercase.TSRestType = uppercase.TSQualifiedName = uppercase.TSPropertySignature = uppercase.TSParenthesizedType = uppercase.TSParameterProperty = uppercase.TSOptionalType = uppercase.TSObjectKeyword = void 0;
  var b = requireLowercase();
  requireDeprecationWarning();
  function alias(lowercase2) {
    {
      return b[lowercase2];
    }
  }
  uppercase.ArrayExpression = alias("arrayExpression");
  uppercase.AssignmentExpression = alias("assignmentExpression");
  uppercase.BinaryExpression = alias("binaryExpression");
  uppercase.InterpreterDirective = alias("interpreterDirective");
  uppercase.Directive = alias("directive");
  uppercase.DirectiveLiteral = alias("directiveLiteral");
  uppercase.BlockStatement = alias("blockStatement");
  uppercase.BreakStatement = alias("breakStatement");
  uppercase.CallExpression = alias("callExpression");
  uppercase.CatchClause = alias("catchClause");
  uppercase.ConditionalExpression = alias("conditionalExpression");
  uppercase.ContinueStatement = alias("continueStatement");
  uppercase.DebuggerStatement = alias("debuggerStatement");
  uppercase.DoWhileStatement = alias("doWhileStatement");
  uppercase.EmptyStatement = alias("emptyStatement");
  uppercase.ExpressionStatement = alias("expressionStatement");
  uppercase.File = alias("file");
  uppercase.ForInStatement = alias("forInStatement");
  uppercase.ForStatement = alias("forStatement");
  uppercase.FunctionDeclaration = alias("functionDeclaration");
  uppercase.FunctionExpression = alias("functionExpression");
  uppercase.Identifier = alias("identifier");
  uppercase.IfStatement = alias("ifStatement");
  uppercase.LabeledStatement = alias("labeledStatement");
  uppercase.StringLiteral = alias("stringLiteral");
  uppercase.NumericLiteral = alias("numericLiteral");
  uppercase.NullLiteral = alias("nullLiteral");
  uppercase.BooleanLiteral = alias("booleanLiteral");
  uppercase.RegExpLiteral = alias("regExpLiteral");
  uppercase.LogicalExpression = alias("logicalExpression");
  uppercase.MemberExpression = alias("memberExpression");
  uppercase.NewExpression = alias("newExpression");
  uppercase.Program = alias("program");
  uppercase.ObjectExpression = alias("objectExpression");
  uppercase.ObjectMethod = alias("objectMethod");
  uppercase.ObjectProperty = alias("objectProperty");
  uppercase.RestElement = alias("restElement");
  uppercase.ReturnStatement = alias("returnStatement");
  uppercase.SequenceExpression = alias("sequenceExpression");
  uppercase.ParenthesizedExpression = alias("parenthesizedExpression");
  uppercase.SwitchCase = alias("switchCase");
  uppercase.SwitchStatement = alias("switchStatement");
  uppercase.ThisExpression = alias("thisExpression");
  uppercase.ThrowStatement = alias("throwStatement");
  uppercase.TryStatement = alias("tryStatement");
  uppercase.UnaryExpression = alias("unaryExpression");
  uppercase.UpdateExpression = alias("updateExpression");
  uppercase.VariableDeclaration = alias("variableDeclaration");
  uppercase.VariableDeclarator = alias("variableDeclarator");
  uppercase.WhileStatement = alias("whileStatement");
  uppercase.WithStatement = alias("withStatement");
  uppercase.AssignmentPattern = alias("assignmentPattern");
  uppercase.ArrayPattern = alias("arrayPattern");
  uppercase.ArrowFunctionExpression = alias("arrowFunctionExpression");
  uppercase.ClassBody = alias("classBody");
  uppercase.ClassExpression = alias("classExpression");
  uppercase.ClassDeclaration = alias("classDeclaration");
  uppercase.ExportAllDeclaration = alias("exportAllDeclaration");
  uppercase.ExportDefaultDeclaration = alias("exportDefaultDeclaration");
  uppercase.ExportNamedDeclaration = alias("exportNamedDeclaration");
  uppercase.ExportSpecifier = alias("exportSpecifier");
  uppercase.ForOfStatement = alias("forOfStatement");
  uppercase.ImportDeclaration = alias("importDeclaration");
  uppercase.ImportDefaultSpecifier = alias("importDefaultSpecifier");
  uppercase.ImportNamespaceSpecifier = alias("importNamespaceSpecifier");
  uppercase.ImportSpecifier = alias("importSpecifier");
  uppercase.ImportExpression = alias("importExpression");
  uppercase.MetaProperty = alias("metaProperty");
  uppercase.ClassMethod = alias("classMethod");
  uppercase.ObjectPattern = alias("objectPattern");
  uppercase.SpreadElement = alias("spreadElement");
  uppercase.Super = alias("super");
  uppercase.TaggedTemplateExpression = alias("taggedTemplateExpression");
  uppercase.TemplateElement = alias("templateElement");
  uppercase.TemplateLiteral = alias("templateLiteral");
  uppercase.YieldExpression = alias("yieldExpression");
  uppercase.AwaitExpression = alias("awaitExpression");
  uppercase.Import = alias("import");
  uppercase.BigIntLiteral = alias("bigIntLiteral");
  uppercase.ExportNamespaceSpecifier = alias("exportNamespaceSpecifier");
  uppercase.OptionalMemberExpression = alias("optionalMemberExpression");
  uppercase.OptionalCallExpression = alias("optionalCallExpression");
  uppercase.ClassProperty = alias("classProperty");
  uppercase.ClassAccessorProperty = alias("classAccessorProperty");
  uppercase.ClassPrivateProperty = alias("classPrivateProperty");
  uppercase.ClassPrivateMethod = alias("classPrivateMethod");
  uppercase.PrivateName = alias("privateName");
  uppercase.StaticBlock = alias("staticBlock");
  uppercase.ImportAttribute = alias("importAttribute");
  uppercase.AnyTypeAnnotation = alias("anyTypeAnnotation");
  uppercase.ArrayTypeAnnotation = alias("arrayTypeAnnotation");
  uppercase.BooleanTypeAnnotation = alias("booleanTypeAnnotation");
  uppercase.BooleanLiteralTypeAnnotation = alias("booleanLiteralTypeAnnotation");
  uppercase.NullLiteralTypeAnnotation = alias("nullLiteralTypeAnnotation");
  uppercase.ClassImplements = alias("classImplements");
  uppercase.DeclareClass = alias("declareClass");
  uppercase.DeclareFunction = alias("declareFunction");
  uppercase.DeclareInterface = alias("declareInterface");
  uppercase.DeclareModule = alias("declareModule");
  uppercase.DeclareModuleExports = alias("declareModuleExports");
  uppercase.DeclareTypeAlias = alias("declareTypeAlias");
  uppercase.DeclareOpaqueType = alias("declareOpaqueType");
  uppercase.DeclareVariable = alias("declareVariable");
  uppercase.DeclareExportDeclaration = alias("declareExportDeclaration");
  uppercase.DeclareExportAllDeclaration = alias("declareExportAllDeclaration");
  uppercase.DeclaredPredicate = alias("declaredPredicate");
  uppercase.ExistsTypeAnnotation = alias("existsTypeAnnotation");
  uppercase.FunctionTypeAnnotation = alias("functionTypeAnnotation");
  uppercase.FunctionTypeParam = alias("functionTypeParam");
  uppercase.GenericTypeAnnotation = alias("genericTypeAnnotation");
  uppercase.InferredPredicate = alias("inferredPredicate");
  uppercase.InterfaceExtends = alias("interfaceExtends");
  uppercase.InterfaceDeclaration = alias("interfaceDeclaration");
  uppercase.InterfaceTypeAnnotation = alias("interfaceTypeAnnotation");
  uppercase.IntersectionTypeAnnotation = alias("intersectionTypeAnnotation");
  uppercase.MixedTypeAnnotation = alias("mixedTypeAnnotation");
  uppercase.EmptyTypeAnnotation = alias("emptyTypeAnnotation");
  uppercase.NullableTypeAnnotation = alias("nullableTypeAnnotation");
  uppercase.NumberLiteralTypeAnnotation = alias("numberLiteralTypeAnnotation");
  uppercase.NumberTypeAnnotation = alias("numberTypeAnnotation");
  uppercase.ObjectTypeAnnotation = alias("objectTypeAnnotation");
  uppercase.ObjectTypeInternalSlot = alias("objectTypeInternalSlot");
  uppercase.ObjectTypeCallProperty = alias("objectTypeCallProperty");
  uppercase.ObjectTypeIndexer = alias("objectTypeIndexer");
  uppercase.ObjectTypeProperty = alias("objectTypeProperty");
  uppercase.ObjectTypeSpreadProperty = alias("objectTypeSpreadProperty");
  uppercase.OpaqueType = alias("opaqueType");
  uppercase.QualifiedTypeIdentifier = alias("qualifiedTypeIdentifier");
  uppercase.StringLiteralTypeAnnotation = alias("stringLiteralTypeAnnotation");
  uppercase.StringTypeAnnotation = alias("stringTypeAnnotation");
  uppercase.SymbolTypeAnnotation = alias("symbolTypeAnnotation");
  uppercase.ThisTypeAnnotation = alias("thisTypeAnnotation");
  uppercase.TupleTypeAnnotation = alias("tupleTypeAnnotation");
  uppercase.TypeofTypeAnnotation = alias("typeofTypeAnnotation");
  uppercase.TypeAlias = alias("typeAlias");
  uppercase.TypeAnnotation = alias("typeAnnotation");
  uppercase.TypeCastExpression = alias("typeCastExpression");
  uppercase.TypeParameter = alias("typeParameter");
  uppercase.TypeParameterDeclaration = alias("typeParameterDeclaration");
  uppercase.TypeParameterInstantiation = alias("typeParameterInstantiation");
  uppercase.UnionTypeAnnotation = alias("unionTypeAnnotation");
  uppercase.Variance = alias("variance");
  uppercase.VoidTypeAnnotation = alias("voidTypeAnnotation");
  uppercase.EnumDeclaration = alias("enumDeclaration");
  uppercase.EnumBooleanBody = alias("enumBooleanBody");
  uppercase.EnumNumberBody = alias("enumNumberBody");
  uppercase.EnumStringBody = alias("enumStringBody");
  uppercase.EnumSymbolBody = alias("enumSymbolBody");
  uppercase.EnumBooleanMember = alias("enumBooleanMember");
  uppercase.EnumNumberMember = alias("enumNumberMember");
  uppercase.EnumStringMember = alias("enumStringMember");
  uppercase.EnumDefaultedMember = alias("enumDefaultedMember");
  uppercase.IndexedAccessType = alias("indexedAccessType");
  uppercase.OptionalIndexedAccessType = alias("optionalIndexedAccessType");
  uppercase.JSXAttribute = alias("jsxAttribute");
  uppercase.JSXClosingElement = alias("jsxClosingElement");
  uppercase.JSXElement = alias("jsxElement");
  uppercase.JSXEmptyExpression = alias("jsxEmptyExpression");
  uppercase.JSXExpressionContainer = alias("jsxExpressionContainer");
  uppercase.JSXSpreadChild = alias("jsxSpreadChild");
  uppercase.JSXIdentifier = alias("jsxIdentifier");
  uppercase.JSXMemberExpression = alias("jsxMemberExpression");
  uppercase.JSXNamespacedName = alias("jsxNamespacedName");
  uppercase.JSXOpeningElement = alias("jsxOpeningElement");
  uppercase.JSXSpreadAttribute = alias("jsxSpreadAttribute");
  uppercase.JSXText = alias("jsxText");
  uppercase.JSXFragment = alias("jsxFragment");
  uppercase.JSXOpeningFragment = alias("jsxOpeningFragment");
  uppercase.JSXClosingFragment = alias("jsxClosingFragment");
  uppercase.Noop = alias("noop");
  uppercase.Placeholder = alias("placeholder");
  uppercase.V8IntrinsicIdentifier = alias("v8IntrinsicIdentifier");
  uppercase.ArgumentPlaceholder = alias("argumentPlaceholder");
  uppercase.BindExpression = alias("bindExpression");
  uppercase.Decorator = alias("decorator");
  uppercase.DoExpression = alias("doExpression");
  uppercase.ExportDefaultSpecifier = alias("exportDefaultSpecifier");
  uppercase.RecordExpression = alias("recordExpression");
  uppercase.TupleExpression = alias("tupleExpression");
  uppercase.DecimalLiteral = alias("decimalLiteral");
  uppercase.ModuleExpression = alias("moduleExpression");
  uppercase.TopicReference = alias("topicReference");
  uppercase.PipelineTopicExpression = alias("pipelineTopicExpression");
  uppercase.PipelineBareFunction = alias("pipelineBareFunction");
  uppercase.PipelinePrimaryTopicReference = alias("pipelinePrimaryTopicReference");
  uppercase.VoidPattern = alias("voidPattern");
  uppercase.TSParameterProperty = alias("tsParameterProperty");
  uppercase.TSDeclareFunction = alias("tsDeclareFunction");
  uppercase.TSDeclareMethod = alias("tsDeclareMethod");
  uppercase.TSQualifiedName = alias("tsQualifiedName");
  uppercase.TSCallSignatureDeclaration = alias("tsCallSignatureDeclaration");
  uppercase.TSConstructSignatureDeclaration = alias("tsConstructSignatureDeclaration");
  uppercase.TSPropertySignature = alias("tsPropertySignature");
  uppercase.TSMethodSignature = alias("tsMethodSignature");
  uppercase.TSIndexSignature = alias("tsIndexSignature");
  uppercase.TSAnyKeyword = alias("tsAnyKeyword");
  uppercase.TSBooleanKeyword = alias("tsBooleanKeyword");
  uppercase.TSBigIntKeyword = alias("tsBigIntKeyword");
  uppercase.TSIntrinsicKeyword = alias("tsIntrinsicKeyword");
  uppercase.TSNeverKeyword = alias("tsNeverKeyword");
  uppercase.TSNullKeyword = alias("tsNullKeyword");
  uppercase.TSNumberKeyword = alias("tsNumberKeyword");
  uppercase.TSObjectKeyword = alias("tsObjectKeyword");
  uppercase.TSStringKeyword = alias("tsStringKeyword");
  uppercase.TSSymbolKeyword = alias("tsSymbolKeyword");
  uppercase.TSUndefinedKeyword = alias("tsUndefinedKeyword");
  uppercase.TSUnknownKeyword = alias("tsUnknownKeyword");
  uppercase.TSVoidKeyword = alias("tsVoidKeyword");
  uppercase.TSThisType = alias("tsThisType");
  uppercase.TSFunctionType = alias("tsFunctionType");
  uppercase.TSConstructorType = alias("tsConstructorType");
  uppercase.TSTypeReference = alias("tsTypeReference");
  uppercase.TSTypePredicate = alias("tsTypePredicate");
  uppercase.TSTypeQuery = alias("tsTypeQuery");
  uppercase.TSTypeLiteral = alias("tsTypeLiteral");
  uppercase.TSArrayType = alias("tsArrayType");
  uppercase.TSTupleType = alias("tsTupleType");
  uppercase.TSOptionalType = alias("tsOptionalType");
  uppercase.TSRestType = alias("tsRestType");
  uppercase.TSNamedTupleMember = alias("tsNamedTupleMember");
  uppercase.TSUnionType = alias("tsUnionType");
  uppercase.TSIntersectionType = alias("tsIntersectionType");
  uppercase.TSConditionalType = alias("tsConditionalType");
  uppercase.TSInferType = alias("tsInferType");
  uppercase.TSParenthesizedType = alias("tsParenthesizedType");
  uppercase.TSTypeOperator = alias("tsTypeOperator");
  uppercase.TSIndexedAccessType = alias("tsIndexedAccessType");
  uppercase.TSMappedType = alias("tsMappedType");
  uppercase.TSTemplateLiteralType = alias("tsTemplateLiteralType");
  uppercase.TSLiteralType = alias("tsLiteralType");
  uppercase.TSExpressionWithTypeArguments = alias("tsExpressionWithTypeArguments");
  uppercase.TSInterfaceDeclaration = alias("tsInterfaceDeclaration");
  uppercase.TSInterfaceBody = alias("tsInterfaceBody");
  uppercase.TSTypeAliasDeclaration = alias("tsTypeAliasDeclaration");
  uppercase.TSInstantiationExpression = alias("tsInstantiationExpression");
  uppercase.TSAsExpression = alias("tsAsExpression");
  uppercase.TSSatisfiesExpression = alias("tsSatisfiesExpression");
  uppercase.TSTypeAssertion = alias("tsTypeAssertion");
  uppercase.TSEnumBody = alias("tsEnumBody");
  uppercase.TSEnumDeclaration = alias("tsEnumDeclaration");
  uppercase.TSEnumMember = alias("tsEnumMember");
  uppercase.TSModuleDeclaration = alias("tsModuleDeclaration");
  uppercase.TSModuleBlock = alias("tsModuleBlock");
  uppercase.TSImportType = alias("tsImportType");
  uppercase.TSImportEqualsDeclaration = alias("tsImportEqualsDeclaration");
  uppercase.TSExternalModuleReference = alias("tsExternalModuleReference");
  uppercase.TSNonNullExpression = alias("tsNonNullExpression");
  uppercase.TSExportAssignment = alias("tsExportAssignment");
  uppercase.TSNamespaceExportDeclaration = alias("tsNamespaceExportDeclaration");
  uppercase.TSTypeAnnotation = alias("tsTypeAnnotation");
  uppercase.TSTypeParameterInstantiation = alias("tsTypeParameterInstantiation");
  uppercase.TSTypeParameterDeclaration = alias("tsTypeParameterDeclaration");
  uppercase.TSTypeParameter = alias("tsTypeParameter");
  uppercase.NumberLiteral = b.numberLiteral;
  uppercase.RegexLiteral = b.regexLiteral;
  uppercase.RestProperty = b.restProperty;
  uppercase.SpreadProperty = b.spreadProperty;
  return uppercase;
}
var hasRequiredGenerated$2;
function requireGenerated$2() {
  if (hasRequiredGenerated$2) return generated$2;
  hasRequiredGenerated$2 = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", {
      value: true
    });
    var _lowercase = requireLowercase();
    Object.keys(_lowercase).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports$1 && exports$1[key] === _lowercase[key]) return;
      Object.defineProperty(exports$1, key, {
        enumerable: true,
        get: function() {
          return _lowercase[key];
        }
      });
    });
    var _uppercase = requireUppercase();
    Object.keys(_uppercase).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports$1 && exports$1[key] === _uppercase[key]) return;
      Object.defineProperty(exports$1, key, {
        enumerable: true,
        get: function() {
          return _uppercase[key];
        }
      });
    });
  })(generated$2);
  return generated$2;
}
var hasRequiredCleanJSXElementLiteralChild;
function requireCleanJSXElementLiteralChild() {
  if (hasRequiredCleanJSXElementLiteralChild) return cleanJSXElementLiteralChild;
  hasRequiredCleanJSXElementLiteralChild = 1;
  Object.defineProperty(cleanJSXElementLiteralChild, "__esModule", {
    value: true
  });
  cleanJSXElementLiteralChild.default = cleanJSXElementLiteralChild$1;
  var _index = requireGenerated$2();
  var _index2 = requireLib$4();
  function cleanJSXElementLiteralChild$1(child, args) {
    const lines = child.value.split(/\r\n|\n|\r/);
    let lastNonEmptyLine = 0;
    for (let i = 0; i < lines.length; i++) {
      if (/[^ \t]/.exec(lines[i])) {
        lastNonEmptyLine = i;
      }
    }
    let str = "";
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const isFirstLine = i === 0;
      const isLastLine = i === lines.length - 1;
      const isLastNonEmptyLine = i === lastNonEmptyLine;
      let trimmedLine = line.replace(/\t/g, " ");
      if (!isFirstLine) {
        trimmedLine = trimmedLine.replace(/^ +/, "");
      }
      if (!isLastLine) {
        trimmedLine = trimmedLine.replace(/ +$/, "");
      }
      if (trimmedLine) {
        if (!isLastNonEmptyLine) {
          trimmedLine += " ";
        }
        str += trimmedLine;
      }
    }
    if (str) args.push((0, _index2.inherits)((0, _index.stringLiteral)(str), child));
  }
  return cleanJSXElementLiteralChild;
}
var hasRequiredBuildChildren;
function requireBuildChildren() {
  if (hasRequiredBuildChildren) return buildChildren;
  hasRequiredBuildChildren = 1;
  Object.defineProperty(buildChildren, "__esModule", {
    value: true
  });
  buildChildren.default = buildChildren$1;
  var _index = requireGenerated$3();
  var _cleanJSXElementLiteralChild = requireCleanJSXElementLiteralChild();
  function buildChildren$1(node2) {
    const elements = [];
    for (let i = 0; i < node2.children.length; i++) {
      let child = node2.children[i];
      if ((0, _index.isJSXText)(child)) {
        (0, _cleanJSXElementLiteralChild.default)(child, elements);
        continue;
      }
      if ((0, _index.isJSXExpressionContainer)(child)) child = child.expression;
      if ((0, _index.isJSXEmptyExpression)(child)) continue;
      elements.push(child);
    }
    return elements;
  }
  return buildChildren;
}
var assertNode = {};
var isNode = {};
var hasRequiredIsNode;
function requireIsNode() {
  if (hasRequiredIsNode) return isNode;
  hasRequiredIsNode = 1;
  Object.defineProperty(isNode, "__esModule", {
    value: true
  });
  isNode.default = isNode$1;
  var _index = requireDefinitions();
  function isNode$1(node2) {
    return !!(node2 && _index.VISITOR_KEYS[node2.type]);
  }
  return isNode;
}
var hasRequiredAssertNode;
function requireAssertNode() {
  if (hasRequiredAssertNode) return assertNode;
  hasRequiredAssertNode = 1;
  Object.defineProperty(assertNode, "__esModule", {
    value: true
  });
  assertNode.default = assertNode$1;
  var _isNode = requireIsNode();
  function assertNode$1(node2) {
    if (!(0, _isNode.default)(node2)) {
      var _node$type;
      const type = (_node$type = node2 == null ? void 0 : node2.type) != null ? _node$type : JSON.stringify(node2);
      throw new TypeError(`Not a valid node of type "${type}"`);
    }
  }
  return assertNode;
}
var generated$1 = {};
var hasRequiredGenerated$1;
function requireGenerated$1() {
  if (hasRequiredGenerated$1) return generated$1;
  hasRequiredGenerated$1 = 1;
  Object.defineProperty(generated$1, "__esModule", {
    value: true
  });
  generated$1.assertAccessor = assertAccessor;
  generated$1.assertAnyTypeAnnotation = assertAnyTypeAnnotation;
  generated$1.assertArgumentPlaceholder = assertArgumentPlaceholder;
  generated$1.assertArrayExpression = assertArrayExpression;
  generated$1.assertArrayPattern = assertArrayPattern;
  generated$1.assertArrayTypeAnnotation = assertArrayTypeAnnotation;
  generated$1.assertArrowFunctionExpression = assertArrowFunctionExpression;
  generated$1.assertAssignmentExpression = assertAssignmentExpression;
  generated$1.assertAssignmentPattern = assertAssignmentPattern;
  generated$1.assertAwaitExpression = assertAwaitExpression;
  generated$1.assertBigIntLiteral = assertBigIntLiteral;
  generated$1.assertBinary = assertBinary;
  generated$1.assertBinaryExpression = assertBinaryExpression;
  generated$1.assertBindExpression = assertBindExpression;
  generated$1.assertBlock = assertBlock;
  generated$1.assertBlockParent = assertBlockParent;
  generated$1.assertBlockStatement = assertBlockStatement;
  generated$1.assertBooleanLiteral = assertBooleanLiteral;
  generated$1.assertBooleanLiteralTypeAnnotation = assertBooleanLiteralTypeAnnotation;
  generated$1.assertBooleanTypeAnnotation = assertBooleanTypeAnnotation;
  generated$1.assertBreakStatement = assertBreakStatement;
  generated$1.assertCallExpression = assertCallExpression;
  generated$1.assertCatchClause = assertCatchClause;
  generated$1.assertClass = assertClass;
  generated$1.assertClassAccessorProperty = assertClassAccessorProperty;
  generated$1.assertClassBody = assertClassBody;
  generated$1.assertClassDeclaration = assertClassDeclaration;
  generated$1.assertClassExpression = assertClassExpression;
  generated$1.assertClassImplements = assertClassImplements;
  generated$1.assertClassMethod = assertClassMethod;
  generated$1.assertClassPrivateMethod = assertClassPrivateMethod;
  generated$1.assertClassPrivateProperty = assertClassPrivateProperty;
  generated$1.assertClassProperty = assertClassProperty;
  generated$1.assertCompletionStatement = assertCompletionStatement;
  generated$1.assertConditional = assertConditional;
  generated$1.assertConditionalExpression = assertConditionalExpression;
  generated$1.assertContinueStatement = assertContinueStatement;
  generated$1.assertDebuggerStatement = assertDebuggerStatement;
  generated$1.assertDecimalLiteral = assertDecimalLiteral;
  generated$1.assertDeclaration = assertDeclaration;
  generated$1.assertDeclareClass = assertDeclareClass;
  generated$1.assertDeclareExportAllDeclaration = assertDeclareExportAllDeclaration;
  generated$1.assertDeclareExportDeclaration = assertDeclareExportDeclaration;
  generated$1.assertDeclareFunction = assertDeclareFunction;
  generated$1.assertDeclareInterface = assertDeclareInterface;
  generated$1.assertDeclareModule = assertDeclareModule;
  generated$1.assertDeclareModuleExports = assertDeclareModuleExports;
  generated$1.assertDeclareOpaqueType = assertDeclareOpaqueType;
  generated$1.assertDeclareTypeAlias = assertDeclareTypeAlias;
  generated$1.assertDeclareVariable = assertDeclareVariable;
  generated$1.assertDeclaredPredicate = assertDeclaredPredicate;
  generated$1.assertDecorator = assertDecorator;
  generated$1.assertDirective = assertDirective;
  generated$1.assertDirectiveLiteral = assertDirectiveLiteral;
  generated$1.assertDoExpression = assertDoExpression;
  generated$1.assertDoWhileStatement = assertDoWhileStatement;
  generated$1.assertEmptyStatement = assertEmptyStatement;
  generated$1.assertEmptyTypeAnnotation = assertEmptyTypeAnnotation;
  generated$1.assertEnumBody = assertEnumBody;
  generated$1.assertEnumBooleanBody = assertEnumBooleanBody;
  generated$1.assertEnumBooleanMember = assertEnumBooleanMember;
  generated$1.assertEnumDeclaration = assertEnumDeclaration;
  generated$1.assertEnumDefaultedMember = assertEnumDefaultedMember;
  generated$1.assertEnumMember = assertEnumMember;
  generated$1.assertEnumNumberBody = assertEnumNumberBody;
  generated$1.assertEnumNumberMember = assertEnumNumberMember;
  generated$1.assertEnumStringBody = assertEnumStringBody;
  generated$1.assertEnumStringMember = assertEnumStringMember;
  generated$1.assertEnumSymbolBody = assertEnumSymbolBody;
  generated$1.assertExistsTypeAnnotation = assertExistsTypeAnnotation;
  generated$1.assertExportAllDeclaration = assertExportAllDeclaration;
  generated$1.assertExportDeclaration = assertExportDeclaration;
  generated$1.assertExportDefaultDeclaration = assertExportDefaultDeclaration;
  generated$1.assertExportDefaultSpecifier = assertExportDefaultSpecifier;
  generated$1.assertExportNamedDeclaration = assertExportNamedDeclaration;
  generated$1.assertExportNamespaceSpecifier = assertExportNamespaceSpecifier;
  generated$1.assertExportSpecifier = assertExportSpecifier;
  generated$1.assertExpression = assertExpression;
  generated$1.assertExpressionStatement = assertExpressionStatement;
  generated$1.assertExpressionWrapper = assertExpressionWrapper;
  generated$1.assertFile = assertFile;
  generated$1.assertFlow = assertFlow;
  generated$1.assertFlowBaseAnnotation = assertFlowBaseAnnotation;
  generated$1.assertFlowDeclaration = assertFlowDeclaration;
  generated$1.assertFlowPredicate = assertFlowPredicate;
  generated$1.assertFlowType = assertFlowType;
  generated$1.assertFor = assertFor;
  generated$1.assertForInStatement = assertForInStatement;
  generated$1.assertForOfStatement = assertForOfStatement;
  generated$1.assertForStatement = assertForStatement;
  generated$1.assertForXStatement = assertForXStatement;
  generated$1.assertFunction = assertFunction;
  generated$1.assertFunctionDeclaration = assertFunctionDeclaration;
  generated$1.assertFunctionExpression = assertFunctionExpression;
  generated$1.assertFunctionParameter = assertFunctionParameter;
  generated$1.assertFunctionParent = assertFunctionParent;
  generated$1.assertFunctionTypeAnnotation = assertFunctionTypeAnnotation;
  generated$1.assertFunctionTypeParam = assertFunctionTypeParam;
  generated$1.assertGenericTypeAnnotation = assertGenericTypeAnnotation;
  generated$1.assertIdentifier = assertIdentifier;
  generated$1.assertIfStatement = assertIfStatement;
  generated$1.assertImmutable = assertImmutable;
  generated$1.assertImport = assertImport;
  generated$1.assertImportAttribute = assertImportAttribute;
  generated$1.assertImportDeclaration = assertImportDeclaration;
  generated$1.assertImportDefaultSpecifier = assertImportDefaultSpecifier;
  generated$1.assertImportExpression = assertImportExpression;
  generated$1.assertImportNamespaceSpecifier = assertImportNamespaceSpecifier;
  generated$1.assertImportOrExportDeclaration = assertImportOrExportDeclaration;
  generated$1.assertImportSpecifier = assertImportSpecifier;
  generated$1.assertIndexedAccessType = assertIndexedAccessType;
  generated$1.assertInferredPredicate = assertInferredPredicate;
  generated$1.assertInterfaceDeclaration = assertInterfaceDeclaration;
  generated$1.assertInterfaceExtends = assertInterfaceExtends;
  generated$1.assertInterfaceTypeAnnotation = assertInterfaceTypeAnnotation;
  generated$1.assertInterpreterDirective = assertInterpreterDirective;
  generated$1.assertIntersectionTypeAnnotation = assertIntersectionTypeAnnotation;
  generated$1.assertJSX = assertJSX;
  generated$1.assertJSXAttribute = assertJSXAttribute;
  generated$1.assertJSXClosingElement = assertJSXClosingElement;
  generated$1.assertJSXClosingFragment = assertJSXClosingFragment;
  generated$1.assertJSXElement = assertJSXElement;
  generated$1.assertJSXEmptyExpression = assertJSXEmptyExpression;
  generated$1.assertJSXExpressionContainer = assertJSXExpressionContainer;
  generated$1.assertJSXFragment = assertJSXFragment;
  generated$1.assertJSXIdentifier = assertJSXIdentifier;
  generated$1.assertJSXMemberExpression = assertJSXMemberExpression;
  generated$1.assertJSXNamespacedName = assertJSXNamespacedName;
  generated$1.assertJSXOpeningElement = assertJSXOpeningElement;
  generated$1.assertJSXOpeningFragment = assertJSXOpeningFragment;
  generated$1.assertJSXSpreadAttribute = assertJSXSpreadAttribute;
  generated$1.assertJSXSpreadChild = assertJSXSpreadChild;
  generated$1.assertJSXText = assertJSXText;
  generated$1.assertLVal = assertLVal;
  generated$1.assertLabeledStatement = assertLabeledStatement;
  generated$1.assertLiteral = assertLiteral;
  generated$1.assertLogicalExpression = assertLogicalExpression;
  generated$1.assertLoop = assertLoop;
  generated$1.assertMemberExpression = assertMemberExpression;
  generated$1.assertMetaProperty = assertMetaProperty;
  generated$1.assertMethod = assertMethod;
  generated$1.assertMiscellaneous = assertMiscellaneous;
  generated$1.assertMixedTypeAnnotation = assertMixedTypeAnnotation;
  generated$1.assertModuleDeclaration = assertModuleDeclaration;
  generated$1.assertModuleExpression = assertModuleExpression;
  generated$1.assertModuleSpecifier = assertModuleSpecifier;
  generated$1.assertNewExpression = assertNewExpression;
  generated$1.assertNoop = assertNoop;
  generated$1.assertNullLiteral = assertNullLiteral;
  generated$1.assertNullLiteralTypeAnnotation = assertNullLiteralTypeAnnotation;
  generated$1.assertNullableTypeAnnotation = assertNullableTypeAnnotation;
  generated$1.assertNumberLiteral = assertNumberLiteral;
  generated$1.assertNumberLiteralTypeAnnotation = assertNumberLiteralTypeAnnotation;
  generated$1.assertNumberTypeAnnotation = assertNumberTypeAnnotation;
  generated$1.assertNumericLiteral = assertNumericLiteral;
  generated$1.assertObjectExpression = assertObjectExpression;
  generated$1.assertObjectMember = assertObjectMember;
  generated$1.assertObjectMethod = assertObjectMethod;
  generated$1.assertObjectPattern = assertObjectPattern;
  generated$1.assertObjectProperty = assertObjectProperty;
  generated$1.assertObjectTypeAnnotation = assertObjectTypeAnnotation;
  generated$1.assertObjectTypeCallProperty = assertObjectTypeCallProperty;
  generated$1.assertObjectTypeIndexer = assertObjectTypeIndexer;
  generated$1.assertObjectTypeInternalSlot = assertObjectTypeInternalSlot;
  generated$1.assertObjectTypeProperty = assertObjectTypeProperty;
  generated$1.assertObjectTypeSpreadProperty = assertObjectTypeSpreadProperty;
  generated$1.assertOpaqueType = assertOpaqueType;
  generated$1.assertOptionalCallExpression = assertOptionalCallExpression;
  generated$1.assertOptionalIndexedAccessType = assertOptionalIndexedAccessType;
  generated$1.assertOptionalMemberExpression = assertOptionalMemberExpression;
  generated$1.assertParenthesizedExpression = assertParenthesizedExpression;
  generated$1.assertPattern = assertPattern;
  generated$1.assertPatternLike = assertPatternLike;
  generated$1.assertPipelineBareFunction = assertPipelineBareFunction;
  generated$1.assertPipelinePrimaryTopicReference = assertPipelinePrimaryTopicReference;
  generated$1.assertPipelineTopicExpression = assertPipelineTopicExpression;
  generated$1.assertPlaceholder = assertPlaceholder;
  generated$1.assertPrivate = assertPrivate;
  generated$1.assertPrivateName = assertPrivateName;
  generated$1.assertProgram = assertProgram;
  generated$1.assertProperty = assertProperty;
  generated$1.assertPureish = assertPureish;
  generated$1.assertQualifiedTypeIdentifier = assertQualifiedTypeIdentifier;
  generated$1.assertRecordExpression = assertRecordExpression;
  generated$1.assertRegExpLiteral = assertRegExpLiteral;
  generated$1.assertRegexLiteral = assertRegexLiteral;
  generated$1.assertRestElement = assertRestElement;
  generated$1.assertRestProperty = assertRestProperty;
  generated$1.assertReturnStatement = assertReturnStatement;
  generated$1.assertScopable = assertScopable;
  generated$1.assertSequenceExpression = assertSequenceExpression;
  generated$1.assertSpreadElement = assertSpreadElement;
  generated$1.assertSpreadProperty = assertSpreadProperty;
  generated$1.assertStandardized = assertStandardized;
  generated$1.assertStatement = assertStatement;
  generated$1.assertStaticBlock = assertStaticBlock;
  generated$1.assertStringLiteral = assertStringLiteral;
  generated$1.assertStringLiteralTypeAnnotation = assertStringLiteralTypeAnnotation;
  generated$1.assertStringTypeAnnotation = assertStringTypeAnnotation;
  generated$1.assertSuper = assertSuper;
  generated$1.assertSwitchCase = assertSwitchCase;
  generated$1.assertSwitchStatement = assertSwitchStatement;
  generated$1.assertSymbolTypeAnnotation = assertSymbolTypeAnnotation;
  generated$1.assertTSAnyKeyword = assertTSAnyKeyword;
  generated$1.assertTSArrayType = assertTSArrayType;
  generated$1.assertTSAsExpression = assertTSAsExpression;
  generated$1.assertTSBaseType = assertTSBaseType;
  generated$1.assertTSBigIntKeyword = assertTSBigIntKeyword;
  generated$1.assertTSBooleanKeyword = assertTSBooleanKeyword;
  generated$1.assertTSCallSignatureDeclaration = assertTSCallSignatureDeclaration;
  generated$1.assertTSConditionalType = assertTSConditionalType;
  generated$1.assertTSConstructSignatureDeclaration = assertTSConstructSignatureDeclaration;
  generated$1.assertTSConstructorType = assertTSConstructorType;
  generated$1.assertTSDeclareFunction = assertTSDeclareFunction;
  generated$1.assertTSDeclareMethod = assertTSDeclareMethod;
  generated$1.assertTSEntityName = assertTSEntityName;
  generated$1.assertTSEnumBody = assertTSEnumBody;
  generated$1.assertTSEnumDeclaration = assertTSEnumDeclaration;
  generated$1.assertTSEnumMember = assertTSEnumMember;
  generated$1.assertTSExportAssignment = assertTSExportAssignment;
  generated$1.assertTSExpressionWithTypeArguments = assertTSExpressionWithTypeArguments;
  generated$1.assertTSExternalModuleReference = assertTSExternalModuleReference;
  generated$1.assertTSFunctionType = assertTSFunctionType;
  generated$1.assertTSImportEqualsDeclaration = assertTSImportEqualsDeclaration;
  generated$1.assertTSImportType = assertTSImportType;
  generated$1.assertTSIndexSignature = assertTSIndexSignature;
  generated$1.assertTSIndexedAccessType = assertTSIndexedAccessType;
  generated$1.assertTSInferType = assertTSInferType;
  generated$1.assertTSInstantiationExpression = assertTSInstantiationExpression;
  generated$1.assertTSInterfaceBody = assertTSInterfaceBody;
  generated$1.assertTSInterfaceDeclaration = assertTSInterfaceDeclaration;
  generated$1.assertTSIntersectionType = assertTSIntersectionType;
  generated$1.assertTSIntrinsicKeyword = assertTSIntrinsicKeyword;
  generated$1.assertTSLiteralType = assertTSLiteralType;
  generated$1.assertTSMappedType = assertTSMappedType;
  generated$1.assertTSMethodSignature = assertTSMethodSignature;
  generated$1.assertTSModuleBlock = assertTSModuleBlock;
  generated$1.assertTSModuleDeclaration = assertTSModuleDeclaration;
  generated$1.assertTSNamedTupleMember = assertTSNamedTupleMember;
  generated$1.assertTSNamespaceExportDeclaration = assertTSNamespaceExportDeclaration;
  generated$1.assertTSNeverKeyword = assertTSNeverKeyword;
  generated$1.assertTSNonNullExpression = assertTSNonNullExpression;
  generated$1.assertTSNullKeyword = assertTSNullKeyword;
  generated$1.assertTSNumberKeyword = assertTSNumberKeyword;
  generated$1.assertTSObjectKeyword = assertTSObjectKeyword;
  generated$1.assertTSOptionalType = assertTSOptionalType;
  generated$1.assertTSParameterProperty = assertTSParameterProperty;
  generated$1.assertTSParenthesizedType = assertTSParenthesizedType;
  generated$1.assertTSPropertySignature = assertTSPropertySignature;
  generated$1.assertTSQualifiedName = assertTSQualifiedName;
  generated$1.assertTSRestType = assertTSRestType;
  generated$1.assertTSSatisfiesExpression = assertTSSatisfiesExpression;
  generated$1.assertTSStringKeyword = assertTSStringKeyword;
  generated$1.assertTSSymbolKeyword = assertTSSymbolKeyword;
  generated$1.assertTSTemplateLiteralType = assertTSTemplateLiteralType;
  generated$1.assertTSThisType = assertTSThisType;
  generated$1.assertTSTupleType = assertTSTupleType;
  generated$1.assertTSType = assertTSType;
  generated$1.assertTSTypeAliasDeclaration = assertTSTypeAliasDeclaration;
  generated$1.assertTSTypeAnnotation = assertTSTypeAnnotation;
  generated$1.assertTSTypeAssertion = assertTSTypeAssertion;
  generated$1.assertTSTypeElement = assertTSTypeElement;
  generated$1.assertTSTypeLiteral = assertTSTypeLiteral;
  generated$1.assertTSTypeOperator = assertTSTypeOperator;
  generated$1.assertTSTypeParameter = assertTSTypeParameter;
  generated$1.assertTSTypeParameterDeclaration = assertTSTypeParameterDeclaration;
  generated$1.assertTSTypeParameterInstantiation = assertTSTypeParameterInstantiation;
  generated$1.assertTSTypePredicate = assertTSTypePredicate;
  generated$1.assertTSTypeQuery = assertTSTypeQuery;
  generated$1.assertTSTypeReference = assertTSTypeReference;
  generated$1.assertTSUndefinedKeyword = assertTSUndefinedKeyword;
  generated$1.assertTSUnionType = assertTSUnionType;
  generated$1.assertTSUnknownKeyword = assertTSUnknownKeyword;
  generated$1.assertTSVoidKeyword = assertTSVoidKeyword;
  generated$1.assertTaggedTemplateExpression = assertTaggedTemplateExpression;
  generated$1.assertTemplateElement = assertTemplateElement;
  generated$1.assertTemplateLiteral = assertTemplateLiteral;
  generated$1.assertTerminatorless = assertTerminatorless;
  generated$1.assertThisExpression = assertThisExpression;
  generated$1.assertThisTypeAnnotation = assertThisTypeAnnotation;
  generated$1.assertThrowStatement = assertThrowStatement;
  generated$1.assertTopicReference = assertTopicReference;
  generated$1.assertTryStatement = assertTryStatement;
  generated$1.assertTupleExpression = assertTupleExpression;
  generated$1.assertTupleTypeAnnotation = assertTupleTypeAnnotation;
  generated$1.assertTypeAlias = assertTypeAlias;
  generated$1.assertTypeAnnotation = assertTypeAnnotation;
  generated$1.assertTypeCastExpression = assertTypeCastExpression;
  generated$1.assertTypeParameter = assertTypeParameter;
  generated$1.assertTypeParameterDeclaration = assertTypeParameterDeclaration;
  generated$1.assertTypeParameterInstantiation = assertTypeParameterInstantiation;
  generated$1.assertTypeScript = assertTypeScript;
  generated$1.assertTypeofTypeAnnotation = assertTypeofTypeAnnotation;
  generated$1.assertUnaryExpression = assertUnaryExpression;
  generated$1.assertUnaryLike = assertUnaryLike;
  generated$1.assertUnionTypeAnnotation = assertUnionTypeAnnotation;
  generated$1.assertUpdateExpression = assertUpdateExpression;
  generated$1.assertUserWhitespacable = assertUserWhitespacable;
  generated$1.assertV8IntrinsicIdentifier = assertV8IntrinsicIdentifier;
  generated$1.assertVariableDeclaration = assertVariableDeclaration;
  generated$1.assertVariableDeclarator = assertVariableDeclarator;
  generated$1.assertVariance = assertVariance;
  generated$1.assertVoidPattern = assertVoidPattern;
  generated$1.assertVoidTypeAnnotation = assertVoidTypeAnnotation;
  generated$1.assertWhile = assertWhile;
  generated$1.assertWhileStatement = assertWhileStatement;
  generated$1.assertWithStatement = assertWithStatement;
  generated$1.assertYieldExpression = assertYieldExpression;
  var _is = requireIs();
  var _deprecationWarning = requireDeprecationWarning();
  function assert(type, node2, opts) {
    if (!(0, _is.default)(type, node2, opts)) {
      throw new Error(`Expected type "${type}" with option ${JSON.stringify(opts)}, but instead got "${node2.type}".`);
    }
  }
  function assertArrayExpression(node2, opts) {
    assert("ArrayExpression", node2, opts);
  }
  function assertAssignmentExpression(node2, opts) {
    assert("AssignmentExpression", node2, opts);
  }
  function assertBinaryExpression(node2, opts) {
    assert("BinaryExpression", node2, opts);
  }
  function assertInterpreterDirective(node2, opts) {
    assert("InterpreterDirective", node2, opts);
  }
  function assertDirective(node2, opts) {
    assert("Directive", node2, opts);
  }
  function assertDirectiveLiteral(node2, opts) {
    assert("DirectiveLiteral", node2, opts);
  }
  function assertBlockStatement(node2, opts) {
    assert("BlockStatement", node2, opts);
  }
  function assertBreakStatement(node2, opts) {
    assert("BreakStatement", node2, opts);
  }
  function assertCallExpression(node2, opts) {
    assert("CallExpression", node2, opts);
  }
  function assertCatchClause(node2, opts) {
    assert("CatchClause", node2, opts);
  }
  function assertConditionalExpression(node2, opts) {
    assert("ConditionalExpression", node2, opts);
  }
  function assertContinueStatement(node2, opts) {
    assert("ContinueStatement", node2, opts);
  }
  function assertDebuggerStatement(node2, opts) {
    assert("DebuggerStatement", node2, opts);
  }
  function assertDoWhileStatement(node2, opts) {
    assert("DoWhileStatement", node2, opts);
  }
  function assertEmptyStatement(node2, opts) {
    assert("EmptyStatement", node2, opts);
  }
  function assertExpressionStatement(node2, opts) {
    assert("ExpressionStatement", node2, opts);
  }
  function assertFile(node2, opts) {
    assert("File", node2, opts);
  }
  function assertForInStatement(node2, opts) {
    assert("ForInStatement", node2, opts);
  }
  function assertForStatement(node2, opts) {
    assert("ForStatement", node2, opts);
  }
  function assertFunctionDeclaration(node2, opts) {
    assert("FunctionDeclaration", node2, opts);
  }
  function assertFunctionExpression(node2, opts) {
    assert("FunctionExpression", node2, opts);
  }
  function assertIdentifier(node2, opts) {
    assert("Identifier", node2, opts);
  }
  function assertIfStatement(node2, opts) {
    assert("IfStatement", node2, opts);
  }
  function assertLabeledStatement(node2, opts) {
    assert("LabeledStatement", node2, opts);
  }
  function assertStringLiteral(node2, opts) {
    assert("StringLiteral", node2, opts);
  }
  function assertNumericLiteral(node2, opts) {
    assert("NumericLiteral", node2, opts);
  }
  function assertNullLiteral(node2, opts) {
    assert("NullLiteral", node2, opts);
  }
  function assertBooleanLiteral(node2, opts) {
    assert("BooleanLiteral", node2, opts);
  }
  function assertRegExpLiteral(node2, opts) {
    assert("RegExpLiteral", node2, opts);
  }
  function assertLogicalExpression(node2, opts) {
    assert("LogicalExpression", node2, opts);
  }
  function assertMemberExpression(node2, opts) {
    assert("MemberExpression", node2, opts);
  }
  function assertNewExpression(node2, opts) {
    assert("NewExpression", node2, opts);
  }
  function assertProgram(node2, opts) {
    assert("Program", node2, opts);
  }
  function assertObjectExpression(node2, opts) {
    assert("ObjectExpression", node2, opts);
  }
  function assertObjectMethod(node2, opts) {
    assert("ObjectMethod", node2, opts);
  }
  function assertObjectProperty(node2, opts) {
    assert("ObjectProperty", node2, opts);
  }
  function assertRestElement(node2, opts) {
    assert("RestElement", node2, opts);
  }
  function assertReturnStatement(node2, opts) {
    assert("ReturnStatement", node2, opts);
  }
  function assertSequenceExpression(node2, opts) {
    assert("SequenceExpression", node2, opts);
  }
  function assertParenthesizedExpression(node2, opts) {
    assert("ParenthesizedExpression", node2, opts);
  }
  function assertSwitchCase(node2, opts) {
    assert("SwitchCase", node2, opts);
  }
  function assertSwitchStatement(node2, opts) {
    assert("SwitchStatement", node2, opts);
  }
  function assertThisExpression(node2, opts) {
    assert("ThisExpression", node2, opts);
  }
  function assertThrowStatement(node2, opts) {
    assert("ThrowStatement", node2, opts);
  }
  function assertTryStatement(node2, opts) {
    assert("TryStatement", node2, opts);
  }
  function assertUnaryExpression(node2, opts) {
    assert("UnaryExpression", node2, opts);
  }
  function assertUpdateExpression(node2, opts) {
    assert("UpdateExpression", node2, opts);
  }
  function assertVariableDeclaration(node2, opts) {
    assert("VariableDeclaration", node2, opts);
  }
  function assertVariableDeclarator(node2, opts) {
    assert("VariableDeclarator", node2, opts);
  }
  function assertWhileStatement(node2, opts) {
    assert("WhileStatement", node2, opts);
  }
  function assertWithStatement(node2, opts) {
    assert("WithStatement", node2, opts);
  }
  function assertAssignmentPattern(node2, opts) {
    assert("AssignmentPattern", node2, opts);
  }
  function assertArrayPattern(node2, opts) {
    assert("ArrayPattern", node2, opts);
  }
  function assertArrowFunctionExpression(node2, opts) {
    assert("ArrowFunctionExpression", node2, opts);
  }
  function assertClassBody(node2, opts) {
    assert("ClassBody", node2, opts);
  }
  function assertClassExpression(node2, opts) {
    assert("ClassExpression", node2, opts);
  }
  function assertClassDeclaration(node2, opts) {
    assert("ClassDeclaration", node2, opts);
  }
  function assertExportAllDeclaration(node2, opts) {
    assert("ExportAllDeclaration", node2, opts);
  }
  function assertExportDefaultDeclaration(node2, opts) {
    assert("ExportDefaultDeclaration", node2, opts);
  }
  function assertExportNamedDeclaration(node2, opts) {
    assert("ExportNamedDeclaration", node2, opts);
  }
  function assertExportSpecifier(node2, opts) {
    assert("ExportSpecifier", node2, opts);
  }
  function assertForOfStatement(node2, opts) {
    assert("ForOfStatement", node2, opts);
  }
  function assertImportDeclaration(node2, opts) {
    assert("ImportDeclaration", node2, opts);
  }
  function assertImportDefaultSpecifier(node2, opts) {
    assert("ImportDefaultSpecifier", node2, opts);
  }
  function assertImportNamespaceSpecifier(node2, opts) {
    assert("ImportNamespaceSpecifier", node2, opts);
  }
  function assertImportSpecifier(node2, opts) {
    assert("ImportSpecifier", node2, opts);
  }
  function assertImportExpression(node2, opts) {
    assert("ImportExpression", node2, opts);
  }
  function assertMetaProperty(node2, opts) {
    assert("MetaProperty", node2, opts);
  }
  function assertClassMethod(node2, opts) {
    assert("ClassMethod", node2, opts);
  }
  function assertObjectPattern(node2, opts) {
    assert("ObjectPattern", node2, opts);
  }
  function assertSpreadElement(node2, opts) {
    assert("SpreadElement", node2, opts);
  }
  function assertSuper(node2, opts) {
    assert("Super", node2, opts);
  }
  function assertTaggedTemplateExpression(node2, opts) {
    assert("TaggedTemplateExpression", node2, opts);
  }
  function assertTemplateElement(node2, opts) {
    assert("TemplateElement", node2, opts);
  }
  function assertTemplateLiteral(node2, opts) {
    assert("TemplateLiteral", node2, opts);
  }
  function assertYieldExpression(node2, opts) {
    assert("YieldExpression", node2, opts);
  }
  function assertAwaitExpression(node2, opts) {
    assert("AwaitExpression", node2, opts);
  }
  function assertImport(node2, opts) {
    assert("Import", node2, opts);
  }
  function assertBigIntLiteral(node2, opts) {
    assert("BigIntLiteral", node2, opts);
  }
  function assertExportNamespaceSpecifier(node2, opts) {
    assert("ExportNamespaceSpecifier", node2, opts);
  }
  function assertOptionalMemberExpression(node2, opts) {
    assert("OptionalMemberExpression", node2, opts);
  }
  function assertOptionalCallExpression(node2, opts) {
    assert("OptionalCallExpression", node2, opts);
  }
  function assertClassProperty(node2, opts) {
    assert("ClassProperty", node2, opts);
  }
  function assertClassAccessorProperty(node2, opts) {
    assert("ClassAccessorProperty", node2, opts);
  }
  function assertClassPrivateProperty(node2, opts) {
    assert("ClassPrivateProperty", node2, opts);
  }
  function assertClassPrivateMethod(node2, opts) {
    assert("ClassPrivateMethod", node2, opts);
  }
  function assertPrivateName(node2, opts) {
    assert("PrivateName", node2, opts);
  }
  function assertStaticBlock(node2, opts) {
    assert("StaticBlock", node2, opts);
  }
  function assertImportAttribute(node2, opts) {
    assert("ImportAttribute", node2, opts);
  }
  function assertAnyTypeAnnotation(node2, opts) {
    assert("AnyTypeAnnotation", node2, opts);
  }
  function assertArrayTypeAnnotation(node2, opts) {
    assert("ArrayTypeAnnotation", node2, opts);
  }
  function assertBooleanTypeAnnotation(node2, opts) {
    assert("BooleanTypeAnnotation", node2, opts);
  }
  function assertBooleanLiteralTypeAnnotation(node2, opts) {
    assert("BooleanLiteralTypeAnnotation", node2, opts);
  }
  function assertNullLiteralTypeAnnotation(node2, opts) {
    assert("NullLiteralTypeAnnotation", node2, opts);
  }
  function assertClassImplements(node2, opts) {
    assert("ClassImplements", node2, opts);
  }
  function assertDeclareClass(node2, opts) {
    assert("DeclareClass", node2, opts);
  }
  function assertDeclareFunction(node2, opts) {
    assert("DeclareFunction", node2, opts);
  }
  function assertDeclareInterface(node2, opts) {
    assert("DeclareInterface", node2, opts);
  }
  function assertDeclareModule(node2, opts) {
    assert("DeclareModule", node2, opts);
  }
  function assertDeclareModuleExports(node2, opts) {
    assert("DeclareModuleExports", node2, opts);
  }
  function assertDeclareTypeAlias(node2, opts) {
    assert("DeclareTypeAlias", node2, opts);
  }
  function assertDeclareOpaqueType(node2, opts) {
    assert("DeclareOpaqueType", node2, opts);
  }
  function assertDeclareVariable(node2, opts) {
    assert("DeclareVariable", node2, opts);
  }
  function assertDeclareExportDeclaration(node2, opts) {
    assert("DeclareExportDeclaration", node2, opts);
  }
  function assertDeclareExportAllDeclaration(node2, opts) {
    assert("DeclareExportAllDeclaration", node2, opts);
  }
  function assertDeclaredPredicate(node2, opts) {
    assert("DeclaredPredicate", node2, opts);
  }
  function assertExistsTypeAnnotation(node2, opts) {
    assert("ExistsTypeAnnotation", node2, opts);
  }
  function assertFunctionTypeAnnotation(node2, opts) {
    assert("FunctionTypeAnnotation", node2, opts);
  }
  function assertFunctionTypeParam(node2, opts) {
    assert("FunctionTypeParam", node2, opts);
  }
  function assertGenericTypeAnnotation(node2, opts) {
    assert("GenericTypeAnnotation", node2, opts);
  }
  function assertInferredPredicate(node2, opts) {
    assert("InferredPredicate", node2, opts);
  }
  function assertInterfaceExtends(node2, opts) {
    assert("InterfaceExtends", node2, opts);
  }
  function assertInterfaceDeclaration(node2, opts) {
    assert("InterfaceDeclaration", node2, opts);
  }
  function assertInterfaceTypeAnnotation(node2, opts) {
    assert("InterfaceTypeAnnotation", node2, opts);
  }
  function assertIntersectionTypeAnnotation(node2, opts) {
    assert("IntersectionTypeAnnotation", node2, opts);
  }
  function assertMixedTypeAnnotation(node2, opts) {
    assert("MixedTypeAnnotation", node2, opts);
  }
  function assertEmptyTypeAnnotation(node2, opts) {
    assert("EmptyTypeAnnotation", node2, opts);
  }
  function assertNullableTypeAnnotation(node2, opts) {
    assert("NullableTypeAnnotation", node2, opts);
  }
  function assertNumberLiteralTypeAnnotation(node2, opts) {
    assert("NumberLiteralTypeAnnotation", node2, opts);
  }
  function assertNumberTypeAnnotation(node2, opts) {
    assert("NumberTypeAnnotation", node2, opts);
  }
  function assertObjectTypeAnnotation(node2, opts) {
    assert("ObjectTypeAnnotation", node2, opts);
  }
  function assertObjectTypeInternalSlot(node2, opts) {
    assert("ObjectTypeInternalSlot", node2, opts);
  }
  function assertObjectTypeCallProperty(node2, opts) {
    assert("ObjectTypeCallProperty", node2, opts);
  }
  function assertObjectTypeIndexer(node2, opts) {
    assert("ObjectTypeIndexer", node2, opts);
  }
  function assertObjectTypeProperty(node2, opts) {
    assert("ObjectTypeProperty", node2, opts);
  }
  function assertObjectTypeSpreadProperty(node2, opts) {
    assert("ObjectTypeSpreadProperty", node2, opts);
  }
  function assertOpaqueType(node2, opts) {
    assert("OpaqueType", node2, opts);
  }
  function assertQualifiedTypeIdentifier(node2, opts) {
    assert("QualifiedTypeIdentifier", node2, opts);
  }
  function assertStringLiteralTypeAnnotation(node2, opts) {
    assert("StringLiteralTypeAnnotation", node2, opts);
  }
  function assertStringTypeAnnotation(node2, opts) {
    assert("StringTypeAnnotation", node2, opts);
  }
  function assertSymbolTypeAnnotation(node2, opts) {
    assert("SymbolTypeAnnotation", node2, opts);
  }
  function assertThisTypeAnnotation(node2, opts) {
    assert("ThisTypeAnnotation", node2, opts);
  }
  function assertTupleTypeAnnotation(node2, opts) {
    assert("TupleTypeAnnotation", node2, opts);
  }
  function assertTypeofTypeAnnotation(node2, opts) {
    assert("TypeofTypeAnnotation", node2, opts);
  }
  function assertTypeAlias(node2, opts) {
    assert("TypeAlias", node2, opts);
  }
  function assertTypeAnnotation(node2, opts) {
    assert("TypeAnnotation", node2, opts);
  }
  function assertTypeCastExpression(node2, opts) {
    assert("TypeCastExpression", node2, opts);
  }
  function assertTypeParameter(node2, opts) {
    assert("TypeParameter", node2, opts);
  }
  function assertTypeParameterDeclaration(node2, opts) {
    assert("TypeParameterDeclaration", node2, opts);
  }
  function assertTypeParameterInstantiation(node2, opts) {
    assert("TypeParameterInstantiation", node2, opts);
  }
  function assertUnionTypeAnnotation(node2, opts) {
    assert("UnionTypeAnnotation", node2, opts);
  }
  function assertVariance(node2, opts) {
    assert("Variance", node2, opts);
  }
  function assertVoidTypeAnnotation(node2, opts) {
    assert("VoidTypeAnnotation", node2, opts);
  }
  function assertEnumDeclaration(node2, opts) {
    assert("EnumDeclaration", node2, opts);
  }
  function assertEnumBooleanBody(node2, opts) {
    assert("EnumBooleanBody", node2, opts);
  }
  function assertEnumNumberBody(node2, opts) {
    assert("EnumNumberBody", node2, opts);
  }
  function assertEnumStringBody(node2, opts) {
    assert("EnumStringBody", node2, opts);
  }
  function assertEnumSymbolBody(node2, opts) {
    assert("EnumSymbolBody", node2, opts);
  }
  function assertEnumBooleanMember(node2, opts) {
    assert("EnumBooleanMember", node2, opts);
  }
  function assertEnumNumberMember(node2, opts) {
    assert("EnumNumberMember", node2, opts);
  }
  function assertEnumStringMember(node2, opts) {
    assert("EnumStringMember", node2, opts);
  }
  function assertEnumDefaultedMember(node2, opts) {
    assert("EnumDefaultedMember", node2, opts);
  }
  function assertIndexedAccessType(node2, opts) {
    assert("IndexedAccessType", node2, opts);
  }
  function assertOptionalIndexedAccessType(node2, opts) {
    assert("OptionalIndexedAccessType", node2, opts);
  }
  function assertJSXAttribute(node2, opts) {
    assert("JSXAttribute", node2, opts);
  }
  function assertJSXClosingElement(node2, opts) {
    assert("JSXClosingElement", node2, opts);
  }
  function assertJSXElement(node2, opts) {
    assert("JSXElement", node2, opts);
  }
  function assertJSXEmptyExpression(node2, opts) {
    assert("JSXEmptyExpression", node2, opts);
  }
  function assertJSXExpressionContainer(node2, opts) {
    assert("JSXExpressionContainer", node2, opts);
  }
  function assertJSXSpreadChild(node2, opts) {
    assert("JSXSpreadChild", node2, opts);
  }
  function assertJSXIdentifier(node2, opts) {
    assert("JSXIdentifier", node2, opts);
  }
  function assertJSXMemberExpression(node2, opts) {
    assert("JSXMemberExpression", node2, opts);
  }
  function assertJSXNamespacedName(node2, opts) {
    assert("JSXNamespacedName", node2, opts);
  }
  function assertJSXOpeningElement(node2, opts) {
    assert("JSXOpeningElement", node2, opts);
  }
  function assertJSXSpreadAttribute(node2, opts) {
    assert("JSXSpreadAttribute", node2, opts);
  }
  function assertJSXText(node2, opts) {
    assert("JSXText", node2, opts);
  }
  function assertJSXFragment(node2, opts) {
    assert("JSXFragment", node2, opts);
  }
  function assertJSXOpeningFragment(node2, opts) {
    assert("JSXOpeningFragment", node2, opts);
  }
  function assertJSXClosingFragment(node2, opts) {
    assert("JSXClosingFragment", node2, opts);
  }
  function assertNoop(node2, opts) {
    assert("Noop", node2, opts);
  }
  function assertPlaceholder(node2, opts) {
    assert("Placeholder", node2, opts);
  }
  function assertV8IntrinsicIdentifier(node2, opts) {
    assert("V8IntrinsicIdentifier", node2, opts);
  }
  function assertArgumentPlaceholder(node2, opts) {
    assert("ArgumentPlaceholder", node2, opts);
  }
  function assertBindExpression(node2, opts) {
    assert("BindExpression", node2, opts);
  }
  function assertDecorator(node2, opts) {
    assert("Decorator", node2, opts);
  }
  function assertDoExpression(node2, opts) {
    assert("DoExpression", node2, opts);
  }
  function assertExportDefaultSpecifier(node2, opts) {
    assert("ExportDefaultSpecifier", node2, opts);
  }
  function assertRecordExpression(node2, opts) {
    assert("RecordExpression", node2, opts);
  }
  function assertTupleExpression(node2, opts) {
    assert("TupleExpression", node2, opts);
  }
  function assertDecimalLiteral(node2, opts) {
    assert("DecimalLiteral", node2, opts);
  }
  function assertModuleExpression(node2, opts) {
    assert("ModuleExpression", node2, opts);
  }
  function assertTopicReference(node2, opts) {
    assert("TopicReference", node2, opts);
  }
  function assertPipelineTopicExpression(node2, opts) {
    assert("PipelineTopicExpression", node2, opts);
  }
  function assertPipelineBareFunction(node2, opts) {
    assert("PipelineBareFunction", node2, opts);
  }
  function assertPipelinePrimaryTopicReference(node2, opts) {
    assert("PipelinePrimaryTopicReference", node2, opts);
  }
  function assertVoidPattern(node2, opts) {
    assert("VoidPattern", node2, opts);
  }
  function assertTSParameterProperty(node2, opts) {
    assert("TSParameterProperty", node2, opts);
  }
  function assertTSDeclareFunction(node2, opts) {
    assert("TSDeclareFunction", node2, opts);
  }
  function assertTSDeclareMethod(node2, opts) {
    assert("TSDeclareMethod", node2, opts);
  }
  function assertTSQualifiedName(node2, opts) {
    assert("TSQualifiedName", node2, opts);
  }
  function assertTSCallSignatureDeclaration(node2, opts) {
    assert("TSCallSignatureDeclaration", node2, opts);
  }
  function assertTSConstructSignatureDeclaration(node2, opts) {
    assert("TSConstructSignatureDeclaration", node2, opts);
  }
  function assertTSPropertySignature(node2, opts) {
    assert("TSPropertySignature", node2, opts);
  }
  function assertTSMethodSignature(node2, opts) {
    assert("TSMethodSignature", node2, opts);
  }
  function assertTSIndexSignature(node2, opts) {
    assert("TSIndexSignature", node2, opts);
  }
  function assertTSAnyKeyword(node2, opts) {
    assert("TSAnyKeyword", node2, opts);
  }
  function assertTSBooleanKeyword(node2, opts) {
    assert("TSBooleanKeyword", node2, opts);
  }
  function assertTSBigIntKeyword(node2, opts) {
    assert("TSBigIntKeyword", node2, opts);
  }
  function assertTSIntrinsicKeyword(node2, opts) {
    assert("TSIntrinsicKeyword", node2, opts);
  }
  function assertTSNeverKeyword(node2, opts) {
    assert("TSNeverKeyword", node2, opts);
  }
  function assertTSNullKeyword(node2, opts) {
    assert("TSNullKeyword", node2, opts);
  }
  function assertTSNumberKeyword(node2, opts) {
    assert("TSNumberKeyword", node2, opts);
  }
  function assertTSObjectKeyword(node2, opts) {
    assert("TSObjectKeyword", node2, opts);
  }
  function assertTSStringKeyword(node2, opts) {
    assert("TSStringKeyword", node2, opts);
  }
  function assertTSSymbolKeyword(node2, opts) {
    assert("TSSymbolKeyword", node2, opts);
  }
  function assertTSUndefinedKeyword(node2, opts) {
    assert("TSUndefinedKeyword", node2, opts);
  }
  function assertTSUnknownKeyword(node2, opts) {
    assert("TSUnknownKeyword", node2, opts);
  }
  function assertTSVoidKeyword(node2, opts) {
    assert("TSVoidKeyword", node2, opts);
  }
  function assertTSThisType(node2, opts) {
    assert("TSThisType", node2, opts);
  }
  function assertTSFunctionType(node2, opts) {
    assert("TSFunctionType", node2, opts);
  }
  function assertTSConstructorType(node2, opts) {
    assert("TSConstructorType", node2, opts);
  }
  function assertTSTypeReference(node2, opts) {
    assert("TSTypeReference", node2, opts);
  }
  function assertTSTypePredicate(node2, opts) {
    assert("TSTypePredicate", node2, opts);
  }
  function assertTSTypeQuery(node2, opts) {
    assert("TSTypeQuery", node2, opts);
  }
  function assertTSTypeLiteral(node2, opts) {
    assert("TSTypeLiteral", node2, opts);
  }
  function assertTSArrayType(node2, opts) {
    assert("TSArrayType", node2, opts);
  }
  function assertTSTupleType(node2, opts) {
    assert("TSTupleType", node2, opts);
  }
  function assertTSOptionalType(node2, opts) {
    assert("TSOptionalType", node2, opts);
  }
  function assertTSRestType(node2, opts) {
    assert("TSRestType", node2, opts);
  }
  function assertTSNamedTupleMember(node2, opts) {
    assert("TSNamedTupleMember", node2, opts);
  }
  function assertTSUnionType(node2, opts) {
    assert("TSUnionType", node2, opts);
  }
  function assertTSIntersectionType(node2, opts) {
    assert("TSIntersectionType", node2, opts);
  }
  function assertTSConditionalType(node2, opts) {
    assert("TSConditionalType", node2, opts);
  }
  function assertTSInferType(node2, opts) {
    assert("TSInferType", node2, opts);
  }
  function assertTSParenthesizedType(node2, opts) {
    assert("TSParenthesizedType", node2, opts);
  }
  function assertTSTypeOperator(node2, opts) {
    assert("TSTypeOperator", node2, opts);
  }
  function assertTSIndexedAccessType(node2, opts) {
    assert("TSIndexedAccessType", node2, opts);
  }
  function assertTSMappedType(node2, opts) {
    assert("TSMappedType", node2, opts);
  }
  function assertTSTemplateLiteralType(node2, opts) {
    assert("TSTemplateLiteralType", node2, opts);
  }
  function assertTSLiteralType(node2, opts) {
    assert("TSLiteralType", node2, opts);
  }
  function assertTSExpressionWithTypeArguments(node2, opts) {
    assert("TSExpressionWithTypeArguments", node2, opts);
  }
  function assertTSInterfaceDeclaration(node2, opts) {
    assert("TSInterfaceDeclaration", node2, opts);
  }
  function assertTSInterfaceBody(node2, opts) {
    assert("TSInterfaceBody", node2, opts);
  }
  function assertTSTypeAliasDeclaration(node2, opts) {
    assert("TSTypeAliasDeclaration", node2, opts);
  }
  function assertTSInstantiationExpression(node2, opts) {
    assert("TSInstantiationExpression", node2, opts);
  }
  function assertTSAsExpression(node2, opts) {
    assert("TSAsExpression", node2, opts);
  }
  function assertTSSatisfiesExpression(node2, opts) {
    assert("TSSatisfiesExpression", node2, opts);
  }
  function assertTSTypeAssertion(node2, opts) {
    assert("TSTypeAssertion", node2, opts);
  }
  function assertTSEnumBody(node2, opts) {
    assert("TSEnumBody", node2, opts);
  }
  function assertTSEnumDeclaration(node2, opts) {
    assert("TSEnumDeclaration", node2, opts);
  }
  function assertTSEnumMember(node2, opts) {
    assert("TSEnumMember", node2, opts);
  }
  function assertTSModuleDeclaration(node2, opts) {
    assert("TSModuleDeclaration", node2, opts);
  }
  function assertTSModuleBlock(node2, opts) {
    assert("TSModuleBlock", node2, opts);
  }
  function assertTSImportType(node2, opts) {
    assert("TSImportType", node2, opts);
  }
  function assertTSImportEqualsDeclaration(node2, opts) {
    assert("TSImportEqualsDeclaration", node2, opts);
  }
  function assertTSExternalModuleReference(node2, opts) {
    assert("TSExternalModuleReference", node2, opts);
  }
  function assertTSNonNullExpression(node2, opts) {
    assert("TSNonNullExpression", node2, opts);
  }
  function assertTSExportAssignment(node2, opts) {
    assert("TSExportAssignment", node2, opts);
  }
  function assertTSNamespaceExportDeclaration(node2, opts) {
    assert("TSNamespaceExportDeclaration", node2, opts);
  }
  function assertTSTypeAnnotation(node2, opts) {
    assert("TSTypeAnnotation", node2, opts);
  }
  function assertTSTypeParameterInstantiation(node2, opts) {
    assert("TSTypeParameterInstantiation", node2, opts);
  }
  function assertTSTypeParameterDeclaration(node2, opts) {
    assert("TSTypeParameterDeclaration", node2, opts);
  }
  function assertTSTypeParameter(node2, opts) {
    assert("TSTypeParameter", node2, opts);
  }
  function assertStandardized(node2, opts) {
    assert("Standardized", node2, opts);
  }
  function assertExpression(node2, opts) {
    assert("Expression", node2, opts);
  }
  function assertBinary(node2, opts) {
    assert("Binary", node2, opts);
  }
  function assertScopable(node2, opts) {
    assert("Scopable", node2, opts);
  }
  function assertBlockParent(node2, opts) {
    assert("BlockParent", node2, opts);
  }
  function assertBlock(node2, opts) {
    assert("Block", node2, opts);
  }
  function assertStatement(node2, opts) {
    assert("Statement", node2, opts);
  }
  function assertTerminatorless(node2, opts) {
    assert("Terminatorless", node2, opts);
  }
  function assertCompletionStatement(node2, opts) {
    assert("CompletionStatement", node2, opts);
  }
  function assertConditional(node2, opts) {
    assert("Conditional", node2, opts);
  }
  function assertLoop(node2, opts) {
    assert("Loop", node2, opts);
  }
  function assertWhile(node2, opts) {
    assert("While", node2, opts);
  }
  function assertExpressionWrapper(node2, opts) {
    assert("ExpressionWrapper", node2, opts);
  }
  function assertFor(node2, opts) {
    assert("For", node2, opts);
  }
  function assertForXStatement(node2, opts) {
    assert("ForXStatement", node2, opts);
  }
  function assertFunction(node2, opts) {
    assert("Function", node2, opts);
  }
  function assertFunctionParent(node2, opts) {
    assert("FunctionParent", node2, opts);
  }
  function assertPureish(node2, opts) {
    assert("Pureish", node2, opts);
  }
  function assertDeclaration(node2, opts) {
    assert("Declaration", node2, opts);
  }
  function assertFunctionParameter(node2, opts) {
    assert("FunctionParameter", node2, opts);
  }
  function assertPatternLike(node2, opts) {
    assert("PatternLike", node2, opts);
  }
  function assertLVal(node2, opts) {
    assert("LVal", node2, opts);
  }
  function assertTSEntityName(node2, opts) {
    assert("TSEntityName", node2, opts);
  }
  function assertLiteral(node2, opts) {
    assert("Literal", node2, opts);
  }
  function assertImmutable(node2, opts) {
    assert("Immutable", node2, opts);
  }
  function assertUserWhitespacable(node2, opts) {
    assert("UserWhitespacable", node2, opts);
  }
  function assertMethod(node2, opts) {
    assert("Method", node2, opts);
  }
  function assertObjectMember(node2, opts) {
    assert("ObjectMember", node2, opts);
  }
  function assertProperty(node2, opts) {
    assert("Property", node2, opts);
  }
  function assertUnaryLike(node2, opts) {
    assert("UnaryLike", node2, opts);
  }
  function assertPattern(node2, opts) {
    assert("Pattern", node2, opts);
  }
  function assertClass(node2, opts) {
    assert("Class", node2, opts);
  }
  function assertImportOrExportDeclaration(node2, opts) {
    assert("ImportOrExportDeclaration", node2, opts);
  }
  function assertExportDeclaration(node2, opts) {
    assert("ExportDeclaration", node2, opts);
  }
  function assertModuleSpecifier(node2, opts) {
    assert("ModuleSpecifier", node2, opts);
  }
  function assertAccessor(node2, opts) {
    assert("Accessor", node2, opts);
  }
  function assertPrivate(node2, opts) {
    assert("Private", node2, opts);
  }
  function assertFlow(node2, opts) {
    assert("Flow", node2, opts);
  }
  function assertFlowType(node2, opts) {
    assert("FlowType", node2, opts);
  }
  function assertFlowBaseAnnotation(node2, opts) {
    assert("FlowBaseAnnotation", node2, opts);
  }
  function assertFlowDeclaration(node2, opts) {
    assert("FlowDeclaration", node2, opts);
  }
  function assertFlowPredicate(node2, opts) {
    assert("FlowPredicate", node2, opts);
  }
  function assertEnumBody(node2, opts) {
    assert("EnumBody", node2, opts);
  }
  function assertEnumMember(node2, opts) {
    assert("EnumMember", node2, opts);
  }
  function assertJSX(node2, opts) {
    assert("JSX", node2, opts);
  }
  function assertMiscellaneous(node2, opts) {
    assert("Miscellaneous", node2, opts);
  }
  function assertTypeScript(node2, opts) {
    assert("TypeScript", node2, opts);
  }
  function assertTSTypeElement(node2, opts) {
    assert("TSTypeElement", node2, opts);
  }
  function assertTSType(node2, opts) {
    assert("TSType", node2, opts);
  }
  function assertTSBaseType(node2, opts) {
    assert("TSBaseType", node2, opts);
  }
  function assertNumberLiteral(node2, opts) {
    (0, _deprecationWarning.default)("assertNumberLiteral", "assertNumericLiteral");
    assert("NumberLiteral", node2, opts);
  }
  function assertRegexLiteral(node2, opts) {
    (0, _deprecationWarning.default)("assertRegexLiteral", "assertRegExpLiteral");
    assert("RegexLiteral", node2, opts);
  }
  function assertRestProperty(node2, opts) {
    (0, _deprecationWarning.default)("assertRestProperty", "assertRestElement");
    assert("RestProperty", node2, opts);
  }
  function assertSpreadProperty(node2, opts) {
    (0, _deprecationWarning.default)("assertSpreadProperty", "assertSpreadElement");
    assert("SpreadProperty", node2, opts);
  }
  function assertModuleDeclaration(node2, opts) {
    (0, _deprecationWarning.default)("assertModuleDeclaration", "assertImportOrExportDeclaration");
    assert("ModuleDeclaration", node2, opts);
  }
  return generated$1;
}
var createTypeAnnotationBasedOnTypeof = {};
var hasRequiredCreateTypeAnnotationBasedOnTypeof;
function requireCreateTypeAnnotationBasedOnTypeof() {
  if (hasRequiredCreateTypeAnnotationBasedOnTypeof) return createTypeAnnotationBasedOnTypeof;
  hasRequiredCreateTypeAnnotationBasedOnTypeof = 1;
  Object.defineProperty(createTypeAnnotationBasedOnTypeof, "__esModule", {
    value: true
  });
  createTypeAnnotationBasedOnTypeof.default = void 0;
  var _index = requireGenerated$2();
  createTypeAnnotationBasedOnTypeof.default = createTypeAnnotationBasedOnTypeof$1;
  function createTypeAnnotationBasedOnTypeof$1(type) {
    switch (type) {
      case "string":
        return (0, _index.stringTypeAnnotation)();
      case "number":
        return (0, _index.numberTypeAnnotation)();
      case "undefined":
        return (0, _index.voidTypeAnnotation)();
      case "boolean":
        return (0, _index.booleanTypeAnnotation)();
      case "function":
        return (0, _index.genericTypeAnnotation)((0, _index.identifier)("Function"));
      case "object":
        return (0, _index.genericTypeAnnotation)((0, _index.identifier)("Object"));
      case "symbol":
        return (0, _index.genericTypeAnnotation)((0, _index.identifier)("Symbol"));
      case "bigint":
        return (0, _index.anyTypeAnnotation)();
    }
    throw new Error("Invalid typeof value: " + type);
  }
  return createTypeAnnotationBasedOnTypeof;
}
var createFlowUnionType = {};
var removeTypeDuplicates$1 = {};
var hasRequiredRemoveTypeDuplicates$1;
function requireRemoveTypeDuplicates$1() {
  if (hasRequiredRemoveTypeDuplicates$1) return removeTypeDuplicates$1;
  hasRequiredRemoveTypeDuplicates$1 = 1;
  Object.defineProperty(removeTypeDuplicates$1, "__esModule", {
    value: true
  });
  removeTypeDuplicates$1.default = removeTypeDuplicates2;
  var _index = requireGenerated$3();
  function getQualifiedName(node2) {
    return (0, _index.isIdentifier)(node2) ? node2.name : `${node2.id.name}.${getQualifiedName(node2.qualification)}`;
  }
  function removeTypeDuplicates2(nodesIn) {
    const nodes = Array.from(nodesIn);
    const generics = /* @__PURE__ */ new Map();
    const bases = /* @__PURE__ */ new Map();
    const typeGroups = /* @__PURE__ */ new Set();
    const types2 = [];
    for (let i = 0; i < nodes.length; i++) {
      const node2 = nodes[i];
      if (!node2) continue;
      if (types2.includes(node2)) {
        continue;
      }
      if ((0, _index.isAnyTypeAnnotation)(node2)) {
        return [node2];
      }
      if ((0, _index.isFlowBaseAnnotation)(node2)) {
        bases.set(node2.type, node2);
        continue;
      }
      if ((0, _index.isUnionTypeAnnotation)(node2)) {
        if (!typeGroups.has(node2.types)) {
          nodes.push(...node2.types);
          typeGroups.add(node2.types);
        }
        continue;
      }
      if ((0, _index.isGenericTypeAnnotation)(node2)) {
        const name = getQualifiedName(node2.id);
        if (generics.has(name)) {
          let existing = generics.get(name);
          if (existing.typeParameters) {
            if (node2.typeParameters) {
              existing.typeParameters.params.push(...node2.typeParameters.params);
              existing.typeParameters.params = removeTypeDuplicates2(existing.typeParameters.params);
            }
          } else {
            existing = node2.typeParameters;
          }
        } else {
          generics.set(name, node2);
        }
        continue;
      }
      types2.push(node2);
    }
    for (const [, baseType] of bases) {
      types2.push(baseType);
    }
    for (const [, genericName] of generics) {
      types2.push(genericName);
    }
    return types2;
  }
  return removeTypeDuplicates$1;
}
var hasRequiredCreateFlowUnionType;
function requireCreateFlowUnionType() {
  if (hasRequiredCreateFlowUnionType) return createFlowUnionType;
  hasRequiredCreateFlowUnionType = 1;
  Object.defineProperty(createFlowUnionType, "__esModule", {
    value: true
  });
  createFlowUnionType.default = createFlowUnionType$1;
  var _index = requireGenerated$2();
  var _removeTypeDuplicates = requireRemoveTypeDuplicates$1();
  function createFlowUnionType$1(types2) {
    const flattened = (0, _removeTypeDuplicates.default)(types2);
    if (flattened.length === 1) {
      return flattened[0];
    } else {
      return (0, _index.unionTypeAnnotation)(flattened);
    }
  }
  return createFlowUnionType;
}
var createTSUnionType = {};
var removeTypeDuplicates = {};
var hasRequiredRemoveTypeDuplicates;
function requireRemoveTypeDuplicates() {
  if (hasRequiredRemoveTypeDuplicates) return removeTypeDuplicates;
  hasRequiredRemoveTypeDuplicates = 1;
  Object.defineProperty(removeTypeDuplicates, "__esModule", {
    value: true
  });
  removeTypeDuplicates.default = removeTypeDuplicates$12;
  var _index = requireGenerated$3();
  function getQualifiedName(node2) {
    return (0, _index.isIdentifier)(node2) ? node2.name : (0, _index.isThisExpression)(node2) ? "this" : `${node2.right.name}.${getQualifiedName(node2.left)}`;
  }
  function removeTypeDuplicates$12(nodesIn) {
    const nodes = Array.from(nodesIn);
    const generics = /* @__PURE__ */ new Map();
    const bases = /* @__PURE__ */ new Map();
    const typeGroups = /* @__PURE__ */ new Set();
    const types2 = [];
    for (let i = 0; i < nodes.length; i++) {
      const node2 = nodes[i];
      if (!node2) continue;
      if (types2.includes(node2)) {
        continue;
      }
      if ((0, _index.isTSAnyKeyword)(node2)) {
        return [node2];
      }
      if ((0, _index.isTSBaseType)(node2)) {
        bases.set(node2.type, node2);
        continue;
      }
      if ((0, _index.isTSUnionType)(node2)) {
        if (!typeGroups.has(node2.types)) {
          nodes.push(...node2.types);
          typeGroups.add(node2.types);
        }
        continue;
      }
      const typeArgumentsKey = "typeParameters";
      if ((0, _index.isTSTypeReference)(node2) && node2[typeArgumentsKey]) {
        const typeArguments = node2[typeArgumentsKey];
        const name = getQualifiedName(node2.typeName);
        if (generics.has(name)) {
          let existing = generics.get(name);
          const existingTypeArguments = existing[typeArgumentsKey];
          if (existingTypeArguments) {
            existingTypeArguments.params.push(...typeArguments.params);
            existingTypeArguments.params = removeTypeDuplicates$12(existingTypeArguments.params);
          } else {
            existing = typeArguments;
          }
        } else {
          generics.set(name, node2);
        }
        continue;
      }
      types2.push(node2);
    }
    for (const [, baseType] of bases) {
      types2.push(baseType);
    }
    for (const [, genericName] of generics) {
      types2.push(genericName);
    }
    return types2;
  }
  return removeTypeDuplicates;
}
var hasRequiredCreateTSUnionType;
function requireCreateTSUnionType() {
  if (hasRequiredCreateTSUnionType) return createTSUnionType;
  hasRequiredCreateTSUnionType = 1;
  Object.defineProperty(createTSUnionType, "__esModule", {
    value: true
  });
  createTSUnionType.default = createTSUnionType$1;
  var _index = requireGenerated$2();
  var _removeTypeDuplicates = requireRemoveTypeDuplicates();
  var _index2 = requireGenerated$3();
  function createTSUnionType$1(typeAnnotations) {
    const types2 = typeAnnotations.map((type) => {
      return (0, _index2.isTSTypeAnnotation)(type) ? type.typeAnnotation : type;
    });
    const flattened = (0, _removeTypeDuplicates.default)(types2);
    if (flattened.length === 1) {
      return flattened[0];
    } else {
      return (0, _index.tsUnionType)(flattened);
    }
  }
  return createTSUnionType;
}
var productions = {};
var hasRequiredProductions;
function requireProductions() {
  if (hasRequiredProductions) return productions;
  hasRequiredProductions = 1;
  Object.defineProperty(productions, "__esModule", {
    value: true
  });
  productions.buildUndefinedNode = buildUndefinedNode;
  var _index = requireGenerated$2();
  function buildUndefinedNode() {
    return (0, _index.unaryExpression)("void", (0, _index.numericLiteral)(0), true);
  }
  return productions;
}
var cloneNode = {};
var hasRequiredCloneNode;
function requireCloneNode() {
  if (hasRequiredCloneNode) return cloneNode;
  hasRequiredCloneNode = 1;
  Object.defineProperty(cloneNode, "__esModule", {
    value: true
  });
  cloneNode.default = cloneNode$1;
  var _index = requireDefinitions();
  var _index2 = requireGenerated$3();
  const {
    hasOwn
  } = {
    hasOwn: Function.call.bind(Object.prototype.hasOwnProperty)
  };
  function cloneIfNode(obj, deep, withoutLoc, commentsCache) {
    if (obj && typeof obj.type === "string") {
      return cloneNodeInternal(obj, deep, withoutLoc, commentsCache);
    }
    return obj;
  }
  function cloneIfNodeOrArray(obj, deep, withoutLoc, commentsCache) {
    if (Array.isArray(obj)) {
      return obj.map((node2) => cloneIfNode(node2, deep, withoutLoc, commentsCache));
    }
    return cloneIfNode(obj, deep, withoutLoc, commentsCache);
  }
  function cloneNode$1(node2, deep = true, withoutLoc = false) {
    return cloneNodeInternal(node2, deep, withoutLoc, /* @__PURE__ */ new Map());
  }
  function cloneNodeInternal(node2, deep = true, withoutLoc = false, commentsCache) {
    if (!node2) return node2;
    const {
      type
    } = node2;
    const newNode = {
      type: node2.type
    };
    if ((0, _index2.isIdentifier)(node2)) {
      newNode.name = node2.name;
      if (hasOwn(node2, "optional") && typeof node2.optional === "boolean") {
        newNode.optional = node2.optional;
      }
      if (hasOwn(node2, "typeAnnotation")) {
        newNode.typeAnnotation = deep ? cloneIfNodeOrArray(node2.typeAnnotation, true, withoutLoc, commentsCache) : node2.typeAnnotation;
      }
      if (hasOwn(node2, "decorators")) {
        newNode.decorators = deep ? cloneIfNodeOrArray(node2.decorators, true, withoutLoc, commentsCache) : node2.decorators;
      }
    } else if (!hasOwn(_index.NODE_FIELDS, type)) {
      throw new Error(`Unknown node type: "${type}"`);
    } else {
      for (const field of Object.keys(_index.NODE_FIELDS[type])) {
        if (hasOwn(node2, field)) {
          if (deep) {
            newNode[field] = (0, _index2.isFile)(node2) && field === "comments" ? maybeCloneComments(node2.comments, deep, withoutLoc, commentsCache) : cloneIfNodeOrArray(node2[field], true, withoutLoc, commentsCache);
          } else {
            newNode[field] = node2[field];
          }
        }
      }
    }
    if (hasOwn(node2, "loc")) {
      if (withoutLoc) {
        newNode.loc = null;
      } else {
        newNode.loc = node2.loc;
      }
    }
    if (hasOwn(node2, "leadingComments")) {
      newNode.leadingComments = maybeCloneComments(node2.leadingComments, deep, withoutLoc, commentsCache);
    }
    if (hasOwn(node2, "innerComments")) {
      newNode.innerComments = maybeCloneComments(node2.innerComments, deep, withoutLoc, commentsCache);
    }
    if (hasOwn(node2, "trailingComments")) {
      newNode.trailingComments = maybeCloneComments(node2.trailingComments, deep, withoutLoc, commentsCache);
    }
    if (hasOwn(node2, "extra")) {
      newNode.extra = Object.assign({}, node2.extra);
    }
    return newNode;
  }
  function maybeCloneComments(comments2, deep, withoutLoc, commentsCache) {
    if (!comments2 || !deep) {
      return comments2;
    }
    return comments2.map((comment) => {
      const cache2 = commentsCache.get(comment);
      if (cache2) return cache2;
      const {
        type,
        value,
        loc
      } = comment;
      const ret = {
        type,
        value,
        loc
      };
      if (withoutLoc) {
        ret.loc = null;
      }
      commentsCache.set(comment, ret);
      return ret;
    });
  }
  return cloneNode;
}
var clone = {};
var hasRequiredClone;
function requireClone() {
  if (hasRequiredClone) return clone;
  hasRequiredClone = 1;
  Object.defineProperty(clone, "__esModule", {
    value: true
  });
  clone.default = clone$1;
  var _cloneNode = requireCloneNode();
  function clone$1(node2) {
    return (0, _cloneNode.default)(node2, false);
  }
  return clone;
}
var cloneDeep = {};
var hasRequiredCloneDeep;
function requireCloneDeep() {
  if (hasRequiredCloneDeep) return cloneDeep;
  hasRequiredCloneDeep = 1;
  Object.defineProperty(cloneDeep, "__esModule", {
    value: true
  });
  cloneDeep.default = cloneDeep$1;
  var _cloneNode = requireCloneNode();
  function cloneDeep$1(node2) {
    return (0, _cloneNode.default)(node2);
  }
  return cloneDeep;
}
var cloneDeepWithoutLoc = {};
var hasRequiredCloneDeepWithoutLoc;
function requireCloneDeepWithoutLoc() {
  if (hasRequiredCloneDeepWithoutLoc) return cloneDeepWithoutLoc;
  hasRequiredCloneDeepWithoutLoc = 1;
  Object.defineProperty(cloneDeepWithoutLoc, "__esModule", {
    value: true
  });
  cloneDeepWithoutLoc.default = cloneDeepWithoutLoc$1;
  var _cloneNode = requireCloneNode();
  function cloneDeepWithoutLoc$1(node2) {
    return (0, _cloneNode.default)(node2, true, true);
  }
  return cloneDeepWithoutLoc;
}
var cloneWithoutLoc = {};
var hasRequiredCloneWithoutLoc;
function requireCloneWithoutLoc() {
  if (hasRequiredCloneWithoutLoc) return cloneWithoutLoc;
  hasRequiredCloneWithoutLoc = 1;
  Object.defineProperty(cloneWithoutLoc, "__esModule", {
    value: true
  });
  cloneWithoutLoc.default = cloneWithoutLoc$1;
  var _cloneNode = requireCloneNode();
  function cloneWithoutLoc$1(node2) {
    return (0, _cloneNode.default)(node2, false, true);
  }
  return cloneWithoutLoc;
}
var addComment = {};
var addComments = {};
var hasRequiredAddComments;
function requireAddComments() {
  if (hasRequiredAddComments) return addComments;
  hasRequiredAddComments = 1;
  Object.defineProperty(addComments, "__esModule", {
    value: true
  });
  addComments.default = addComments$1;
  function addComments$1(node2, type, comments2) {
    if (!comments2 || !node2) return node2;
    const key = `${type}Comments`;
    if (node2[key]) {
      if (type === "leading") {
        node2[key] = comments2.concat(node2[key]);
      } else {
        node2[key].push(...comments2);
      }
    } else {
      node2[key] = comments2;
    }
    return node2;
  }
  return addComments;
}
var hasRequiredAddComment;
function requireAddComment() {
  if (hasRequiredAddComment) return addComment;
  hasRequiredAddComment = 1;
  Object.defineProperty(addComment, "__esModule", {
    value: true
  });
  addComment.default = addComment$1;
  var _addComments = requireAddComments();
  function addComment$1(node2, type, content, line) {
    return (0, _addComments.default)(node2, type, [{
      type: line ? "CommentLine" : "CommentBlock",
      value: content
    }]);
  }
  return addComment;
}
var inheritInnerComments = {};
var inherit = {};
var hasRequiredInherit;
function requireInherit() {
  if (hasRequiredInherit) return inherit;
  hasRequiredInherit = 1;
  Object.defineProperty(inherit, "__esModule", {
    value: true
  });
  inherit.default = inherit$1;
  function inherit$1(key, child, parent) {
    if (child && parent) {
      child[key] = Array.from(new Set([].concat(child[key], parent[key]).filter(Boolean)));
    }
  }
  return inherit;
}
var hasRequiredInheritInnerComments;
function requireInheritInnerComments() {
  if (hasRequiredInheritInnerComments) return inheritInnerComments;
  hasRequiredInheritInnerComments = 1;
  Object.defineProperty(inheritInnerComments, "__esModule", {
    value: true
  });
  inheritInnerComments.default = inheritInnerComments$1;
  var _inherit = requireInherit();
  function inheritInnerComments$1(child, parent) {
    (0, _inherit.default)("innerComments", child, parent);
  }
  return inheritInnerComments;
}
var inheritLeadingComments = {};
var hasRequiredInheritLeadingComments;
function requireInheritLeadingComments() {
  if (hasRequiredInheritLeadingComments) return inheritLeadingComments;
  hasRequiredInheritLeadingComments = 1;
  Object.defineProperty(inheritLeadingComments, "__esModule", {
    value: true
  });
  inheritLeadingComments.default = inheritLeadingComments$1;
  var _inherit = requireInherit();
  function inheritLeadingComments$1(child, parent) {
    (0, _inherit.default)("leadingComments", child, parent);
  }
  return inheritLeadingComments;
}
var inheritsComments = {};
var inheritTrailingComments = {};
var hasRequiredInheritTrailingComments;
function requireInheritTrailingComments() {
  if (hasRequiredInheritTrailingComments) return inheritTrailingComments;
  hasRequiredInheritTrailingComments = 1;
  Object.defineProperty(inheritTrailingComments, "__esModule", {
    value: true
  });
  inheritTrailingComments.default = inheritTrailingComments$1;
  var _inherit = requireInherit();
  function inheritTrailingComments$1(child, parent) {
    (0, _inherit.default)("trailingComments", child, parent);
  }
  return inheritTrailingComments;
}
var hasRequiredInheritsComments;
function requireInheritsComments() {
  if (hasRequiredInheritsComments) return inheritsComments;
  hasRequiredInheritsComments = 1;
  Object.defineProperty(inheritsComments, "__esModule", {
    value: true
  });
  inheritsComments.default = inheritsComments$1;
  var _inheritTrailingComments = requireInheritTrailingComments();
  var _inheritLeadingComments = requireInheritLeadingComments();
  var _inheritInnerComments = requireInheritInnerComments();
  function inheritsComments$1(child, parent) {
    (0, _inheritTrailingComments.default)(child, parent);
    (0, _inheritLeadingComments.default)(child, parent);
    (0, _inheritInnerComments.default)(child, parent);
    return child;
  }
  return inheritsComments;
}
var removeComments = {};
var hasRequiredRemoveComments;
function requireRemoveComments() {
  if (hasRequiredRemoveComments) return removeComments;
  hasRequiredRemoveComments = 1;
  Object.defineProperty(removeComments, "__esModule", {
    value: true
  });
  removeComments.default = removeComments$1;
  var _index = requireConstants();
  function removeComments$1(node2) {
    _index.COMMENT_KEYS.forEach((key) => {
      node2[key] = null;
    });
    return node2;
  }
  return removeComments;
}
var generated = {};
var hasRequiredGenerated;
function requireGenerated() {
  if (hasRequiredGenerated) return generated;
  hasRequiredGenerated = 1;
  Object.defineProperty(generated, "__esModule", {
    value: true
  });
  generated.WHILE_TYPES = generated.USERWHITESPACABLE_TYPES = generated.UNARYLIKE_TYPES = generated.TYPESCRIPT_TYPES = generated.TSTYPE_TYPES = generated.TSTYPEELEMENT_TYPES = generated.TSENTITYNAME_TYPES = generated.TSBASETYPE_TYPES = generated.TERMINATORLESS_TYPES = generated.STATEMENT_TYPES = generated.STANDARDIZED_TYPES = generated.SCOPABLE_TYPES = generated.PUREISH_TYPES = generated.PROPERTY_TYPES = generated.PRIVATE_TYPES = generated.PATTERN_TYPES = generated.PATTERNLIKE_TYPES = generated.OBJECTMEMBER_TYPES = generated.MODULESPECIFIER_TYPES = generated.MODULEDECLARATION_TYPES = generated.MISCELLANEOUS_TYPES = generated.METHOD_TYPES = generated.LVAL_TYPES = generated.LOOP_TYPES = generated.LITERAL_TYPES = generated.JSX_TYPES = generated.IMPORTOREXPORTDECLARATION_TYPES = generated.IMMUTABLE_TYPES = generated.FUNCTION_TYPES = generated.FUNCTIONPARENT_TYPES = generated.FUNCTIONPARAMETER_TYPES = generated.FOR_TYPES = generated.FORXSTATEMENT_TYPES = generated.FLOW_TYPES = generated.FLOWTYPE_TYPES = generated.FLOWPREDICATE_TYPES = generated.FLOWDECLARATION_TYPES = generated.FLOWBASEANNOTATION_TYPES = generated.EXPRESSION_TYPES = generated.EXPRESSIONWRAPPER_TYPES = generated.EXPORTDECLARATION_TYPES = generated.ENUMMEMBER_TYPES = generated.ENUMBODY_TYPES = generated.DECLARATION_TYPES = generated.CONDITIONAL_TYPES = generated.COMPLETIONSTATEMENT_TYPES = generated.CLASS_TYPES = generated.BLOCK_TYPES = generated.BLOCKPARENT_TYPES = generated.BINARY_TYPES = generated.ACCESSOR_TYPES = void 0;
  var _index = requireDefinitions();
  generated.STANDARDIZED_TYPES = _index.FLIPPED_ALIAS_KEYS["Standardized"];
  generated.EXPRESSION_TYPES = _index.FLIPPED_ALIAS_KEYS["Expression"];
  generated.BINARY_TYPES = _index.FLIPPED_ALIAS_KEYS["Binary"];
  generated.SCOPABLE_TYPES = _index.FLIPPED_ALIAS_KEYS["Scopable"];
  generated.BLOCKPARENT_TYPES = _index.FLIPPED_ALIAS_KEYS["BlockParent"];
  generated.BLOCK_TYPES = _index.FLIPPED_ALIAS_KEYS["Block"];
  generated.STATEMENT_TYPES = _index.FLIPPED_ALIAS_KEYS["Statement"];
  generated.TERMINATORLESS_TYPES = _index.FLIPPED_ALIAS_KEYS["Terminatorless"];
  generated.COMPLETIONSTATEMENT_TYPES = _index.FLIPPED_ALIAS_KEYS["CompletionStatement"];
  generated.CONDITIONAL_TYPES = _index.FLIPPED_ALIAS_KEYS["Conditional"];
  generated.LOOP_TYPES = _index.FLIPPED_ALIAS_KEYS["Loop"];
  generated.WHILE_TYPES = _index.FLIPPED_ALIAS_KEYS["While"];
  generated.EXPRESSIONWRAPPER_TYPES = _index.FLIPPED_ALIAS_KEYS["ExpressionWrapper"];
  generated.FOR_TYPES = _index.FLIPPED_ALIAS_KEYS["For"];
  generated.FORXSTATEMENT_TYPES = _index.FLIPPED_ALIAS_KEYS["ForXStatement"];
  generated.FUNCTION_TYPES = _index.FLIPPED_ALIAS_KEYS["Function"];
  generated.FUNCTIONPARENT_TYPES = _index.FLIPPED_ALIAS_KEYS["FunctionParent"];
  generated.PUREISH_TYPES = _index.FLIPPED_ALIAS_KEYS["Pureish"];
  generated.DECLARATION_TYPES = _index.FLIPPED_ALIAS_KEYS["Declaration"];
  generated.FUNCTIONPARAMETER_TYPES = _index.FLIPPED_ALIAS_KEYS["FunctionParameter"];
  generated.PATTERNLIKE_TYPES = _index.FLIPPED_ALIAS_KEYS["PatternLike"];
  generated.LVAL_TYPES = _index.FLIPPED_ALIAS_KEYS["LVal"];
  generated.TSENTITYNAME_TYPES = _index.FLIPPED_ALIAS_KEYS["TSEntityName"];
  generated.LITERAL_TYPES = _index.FLIPPED_ALIAS_KEYS["Literal"];
  generated.IMMUTABLE_TYPES = _index.FLIPPED_ALIAS_KEYS["Immutable"];
  generated.USERWHITESPACABLE_TYPES = _index.FLIPPED_ALIAS_KEYS["UserWhitespacable"];
  generated.METHOD_TYPES = _index.FLIPPED_ALIAS_KEYS["Method"];
  generated.OBJECTMEMBER_TYPES = _index.FLIPPED_ALIAS_KEYS["ObjectMember"];
  generated.PROPERTY_TYPES = _index.FLIPPED_ALIAS_KEYS["Property"];
  generated.UNARYLIKE_TYPES = _index.FLIPPED_ALIAS_KEYS["UnaryLike"];
  generated.PATTERN_TYPES = _index.FLIPPED_ALIAS_KEYS["Pattern"];
  generated.CLASS_TYPES = _index.FLIPPED_ALIAS_KEYS["Class"];
  const IMPORTOREXPORTDECLARATION_TYPES = generated.IMPORTOREXPORTDECLARATION_TYPES = _index.FLIPPED_ALIAS_KEYS["ImportOrExportDeclaration"];
  generated.EXPORTDECLARATION_TYPES = _index.FLIPPED_ALIAS_KEYS["ExportDeclaration"];
  generated.MODULESPECIFIER_TYPES = _index.FLIPPED_ALIAS_KEYS["ModuleSpecifier"];
  generated.ACCESSOR_TYPES = _index.FLIPPED_ALIAS_KEYS["Accessor"];
  generated.PRIVATE_TYPES = _index.FLIPPED_ALIAS_KEYS["Private"];
  generated.FLOW_TYPES = _index.FLIPPED_ALIAS_KEYS["Flow"];
  generated.FLOWTYPE_TYPES = _index.FLIPPED_ALIAS_KEYS["FlowType"];
  generated.FLOWBASEANNOTATION_TYPES = _index.FLIPPED_ALIAS_KEYS["FlowBaseAnnotation"];
  generated.FLOWDECLARATION_TYPES = _index.FLIPPED_ALIAS_KEYS["FlowDeclaration"];
  generated.FLOWPREDICATE_TYPES = _index.FLIPPED_ALIAS_KEYS["FlowPredicate"];
  generated.ENUMBODY_TYPES = _index.FLIPPED_ALIAS_KEYS["EnumBody"];
  generated.ENUMMEMBER_TYPES = _index.FLIPPED_ALIAS_KEYS["EnumMember"];
  generated.JSX_TYPES = _index.FLIPPED_ALIAS_KEYS["JSX"];
  generated.MISCELLANEOUS_TYPES = _index.FLIPPED_ALIAS_KEYS["Miscellaneous"];
  generated.TYPESCRIPT_TYPES = _index.FLIPPED_ALIAS_KEYS["TypeScript"];
  generated.TSTYPEELEMENT_TYPES = _index.FLIPPED_ALIAS_KEYS["TSTypeElement"];
  generated.TSTYPE_TYPES = _index.FLIPPED_ALIAS_KEYS["TSType"];
  generated.TSBASETYPE_TYPES = _index.FLIPPED_ALIAS_KEYS["TSBaseType"];
  generated.MODULEDECLARATION_TYPES = IMPORTOREXPORTDECLARATION_TYPES;
  return generated;
}
var ensureBlock = {};
var toBlock = {};
var hasRequiredToBlock;
function requireToBlock() {
  if (hasRequiredToBlock) return toBlock;
  hasRequiredToBlock = 1;
  Object.defineProperty(toBlock, "__esModule", {
    value: true
  });
  toBlock.default = toBlock$1;
  var _index = requireGenerated$3();
  var _index2 = requireGenerated$2();
  function toBlock$1(node2, parent) {
    if ((0, _index.isBlockStatement)(node2)) {
      return node2;
    }
    let blockNodes = [];
    if ((0, _index.isEmptyStatement)(node2)) {
      blockNodes = [];
    } else {
      if (!(0, _index.isStatement)(node2)) {
        if ((0, _index.isFunction)(parent)) {
          node2 = (0, _index2.returnStatement)(node2);
        } else {
          node2 = (0, _index2.expressionStatement)(node2);
        }
      }
      blockNodes = [node2];
    }
    return (0, _index2.blockStatement)(blockNodes);
  }
  return toBlock;
}
var hasRequiredEnsureBlock;
function requireEnsureBlock() {
  if (hasRequiredEnsureBlock) return ensureBlock;
  hasRequiredEnsureBlock = 1;
  Object.defineProperty(ensureBlock, "__esModule", {
    value: true
  });
  ensureBlock.default = ensureBlock$1;
  var _toBlock = requireToBlock();
  function ensureBlock$1(node2, key = "body") {
    const result = (0, _toBlock.default)(node2[key], node2);
    node2[key] = result;
    return result;
  }
  return ensureBlock;
}
var toBindingIdentifierName = {};
var toIdentifier = {};
var hasRequiredToIdentifier;
function requireToIdentifier() {
  if (hasRequiredToIdentifier) return toIdentifier;
  hasRequiredToIdentifier = 1;
  Object.defineProperty(toIdentifier, "__esModule", {
    value: true
  });
  toIdentifier.default = toIdentifier$1;
  var _isValidIdentifier = requireIsValidIdentifier();
  var _helperValidatorIdentifier = requireLib$6();
  function toIdentifier$1(input) {
    input = input + "";
    let name = "";
    for (const c of input) {
      name += (0, _helperValidatorIdentifier.isIdentifierChar)(c.codePointAt(0)) ? c : "-";
    }
    name = name.replace(/^[-0-9]+/, "");
    name = name.replace(/[-\s]+(.)?/g, function(match, c) {
      return c ? c.toUpperCase() : "";
    });
    if (!(0, _isValidIdentifier.default)(name)) {
      name = `_${name}`;
    }
    return name || "_";
  }
  return toIdentifier;
}
var hasRequiredToBindingIdentifierName;
function requireToBindingIdentifierName() {
  if (hasRequiredToBindingIdentifierName) return toBindingIdentifierName;
  hasRequiredToBindingIdentifierName = 1;
  Object.defineProperty(toBindingIdentifierName, "__esModule", {
    value: true
  });
  toBindingIdentifierName.default = toBindingIdentifierName$1;
  var _toIdentifier = requireToIdentifier();
  function toBindingIdentifierName$1(name) {
    name = (0, _toIdentifier.default)(name);
    if (name === "eval" || name === "arguments") name = "_" + name;
    return name;
  }
  return toBindingIdentifierName;
}
var toComputedKey = {};
var hasRequiredToComputedKey;
function requireToComputedKey() {
  if (hasRequiredToComputedKey) return toComputedKey;
  hasRequiredToComputedKey = 1;
  Object.defineProperty(toComputedKey, "__esModule", {
    value: true
  });
  toComputedKey.default = toComputedKey$1;
  var _index = requireGenerated$3();
  var _index2 = requireGenerated$2();
  function toComputedKey$1(node2, key = node2.key || node2.property) {
    if (!node2.computed && (0, _index.isIdentifier)(key)) key = (0, _index2.stringLiteral)(key.name);
    return key;
  }
  return toComputedKey;
}
var toExpression = {};
var hasRequiredToExpression;
function requireToExpression() {
  if (hasRequiredToExpression) return toExpression;
  hasRequiredToExpression = 1;
  Object.defineProperty(toExpression, "__esModule", {
    value: true
  });
  toExpression.default = void 0;
  var _index = requireGenerated$3();
  toExpression.default = toExpression$1;
  function toExpression$1(node2) {
    if ((0, _index.isExpressionStatement)(node2)) {
      node2 = node2.expression;
    }
    if ((0, _index.isExpression)(node2)) {
      return node2;
    }
    if ((0, _index.isClass)(node2)) {
      node2.type = "ClassExpression";
      node2.abstract = false;
    } else if ((0, _index.isFunction)(node2)) {
      node2.type = "FunctionExpression";
    }
    if (!(0, _index.isExpression)(node2)) {
      throw new Error(`cannot turn ${node2.type} to an expression`);
    }
    return node2;
  }
  return toExpression;
}
var toKeyAlias = {};
var removePropertiesDeep = {};
var traverseFast = {};
var hasRequiredTraverseFast;
function requireTraverseFast() {
  if (hasRequiredTraverseFast) return traverseFast;
  hasRequiredTraverseFast = 1;
  Object.defineProperty(traverseFast, "__esModule", {
    value: true
  });
  traverseFast.default = traverseFast$1;
  var _index = requireDefinitions();
  const _skip = /* @__PURE__ */ Symbol();
  const _stop = /* @__PURE__ */ Symbol();
  function traverseFast$1(node2, enter, opts) {
    if (!node2) return false;
    const keys = _index.VISITOR_KEYS[node2.type];
    if (!keys) return false;
    opts = opts || {};
    const ret = enter(node2, opts);
    if (ret !== void 0) {
      switch (ret) {
        case _skip:
          return false;
        case _stop:
          return true;
      }
    }
    for (const key of keys) {
      const subNode = node2[key];
      if (!subNode) continue;
      if (Array.isArray(subNode)) {
        for (const node3 of subNode) {
          if (traverseFast$1(node3, enter, opts)) return true;
        }
      } else {
        if (traverseFast$1(subNode, enter, opts)) return true;
      }
    }
    return false;
  }
  traverseFast$1.skip = _skip;
  traverseFast$1.stop = _stop;
  return traverseFast;
}
var removeProperties = {};
var hasRequiredRemoveProperties;
function requireRemoveProperties() {
  if (hasRequiredRemoveProperties) return removeProperties;
  hasRequiredRemoveProperties = 1;
  Object.defineProperty(removeProperties, "__esModule", {
    value: true
  });
  removeProperties.default = removeProperties$1;
  var _index = requireConstants();
  const CLEAR_KEYS = ["tokens", "start", "end", "loc", "raw", "rawValue"];
  const CLEAR_KEYS_PLUS_COMMENTS = [..._index.COMMENT_KEYS, "comments", ...CLEAR_KEYS];
  function removeProperties$1(node2, opts = {}) {
    const map = opts.preserveComments ? CLEAR_KEYS : CLEAR_KEYS_PLUS_COMMENTS;
    for (const key of map) {
      if (node2[key] != null) node2[key] = void 0;
    }
    for (const key of Object.keys(node2)) {
      if (key[0] === "_" && node2[key] != null) node2[key] = void 0;
    }
    const symbols = Object.getOwnPropertySymbols(node2);
    for (const sym of symbols) {
      node2[sym] = null;
    }
  }
  return removeProperties;
}
var hasRequiredRemovePropertiesDeep;
function requireRemovePropertiesDeep() {
  if (hasRequiredRemovePropertiesDeep) return removePropertiesDeep;
  hasRequiredRemovePropertiesDeep = 1;
  Object.defineProperty(removePropertiesDeep, "__esModule", {
    value: true
  });
  removePropertiesDeep.default = removePropertiesDeep$1;
  var _traverseFast = requireTraverseFast();
  var _removeProperties = requireRemoveProperties();
  function removePropertiesDeep$1(tree, opts) {
    (0, _traverseFast.default)(tree, _removeProperties.default, opts);
    return tree;
  }
  return removePropertiesDeep;
}
var hasRequiredToKeyAlias;
function requireToKeyAlias() {
  if (hasRequiredToKeyAlias) return toKeyAlias;
  hasRequiredToKeyAlias = 1;
  Object.defineProperty(toKeyAlias, "__esModule", {
    value: true
  });
  toKeyAlias.default = toKeyAlias$1;
  var _index = requireGenerated$3();
  var _cloneNode = requireCloneNode();
  var _removePropertiesDeep = requireRemovePropertiesDeep();
  function toKeyAlias$1(node2, key = node2.key) {
    let alias;
    if (node2.kind === "method") {
      return toKeyAlias$1.increment() + "";
    } else if ((0, _index.isIdentifier)(key)) {
      alias = key.name;
    } else if ((0, _index.isStringLiteral)(key)) {
      alias = JSON.stringify(key.value);
    } else {
      alias = JSON.stringify((0, _removePropertiesDeep.default)((0, _cloneNode.default)(key)));
    }
    if (node2.computed) {
      alias = `[${alias}]`;
    }
    if (node2.static) {
      alias = `static:${alias}`;
    }
    return alias;
  }
  toKeyAlias$1.uid = 0;
  toKeyAlias$1.increment = function() {
    if (toKeyAlias$1.uid >= Number.MAX_SAFE_INTEGER) {
      return toKeyAlias$1.uid = 0;
    } else {
      return toKeyAlias$1.uid++;
    }
  };
  return toKeyAlias;
}
var toStatement = {};
var hasRequiredToStatement;
function requireToStatement() {
  if (hasRequiredToStatement) return toStatement;
  hasRequiredToStatement = 1;
  Object.defineProperty(toStatement, "__esModule", {
    value: true
  });
  toStatement.default = void 0;
  var _index = requireGenerated$3();
  var _index2 = requireGenerated$2();
  toStatement.default = toStatement$1;
  function toStatement$1(node2, ignore) {
    if ((0, _index.isStatement)(node2)) {
      return node2;
    }
    let mustHaveId = false;
    let newType;
    if ((0, _index.isClass)(node2)) {
      mustHaveId = true;
      newType = "ClassDeclaration";
    } else if ((0, _index.isFunction)(node2)) {
      mustHaveId = true;
      newType = "FunctionDeclaration";
    } else if ((0, _index.isAssignmentExpression)(node2)) {
      return (0, _index2.expressionStatement)(node2);
    }
    if (mustHaveId && !node2.id) {
      newType = false;
    }
    if (!newType) {
      if (ignore) {
        return false;
      } else {
        throw new Error(`cannot turn ${node2.type} to a statement`);
      }
    }
    node2.type = newType;
    return node2;
  }
  return toStatement;
}
var valueToNode = {};
var hasRequiredValueToNode;
function requireValueToNode() {
  if (hasRequiredValueToNode) return valueToNode;
  hasRequiredValueToNode = 1;
  Object.defineProperty(valueToNode, "__esModule", {
    value: true
  });
  valueToNode.default = void 0;
  var _isValidIdentifier = requireIsValidIdentifier();
  var _index = requireGenerated$2();
  valueToNode.default = valueToNode$1;
  const objectToString = Function.call.bind(Object.prototype.toString);
  function isRegExp(value) {
    return objectToString(value) === "[object RegExp]";
  }
  function isPlainObject(value) {
    if (typeof value !== "object" || value === null || Object.prototype.toString.call(value) !== "[object Object]") {
      return false;
    }
    const proto = Object.getPrototypeOf(value);
    return proto === null || Object.getPrototypeOf(proto) === null;
  }
  function valueToNode$1(value) {
    if (value === void 0) {
      return (0, _index.identifier)("undefined");
    }
    if (value === true || value === false) {
      return (0, _index.booleanLiteral)(value);
    }
    if (value === null) {
      return (0, _index.nullLiteral)();
    }
    if (typeof value === "string") {
      return (0, _index.stringLiteral)(value);
    }
    if (typeof value === "number") {
      let result;
      if (Number.isFinite(value)) {
        result = (0, _index.numericLiteral)(Math.abs(value));
      } else {
        let numerator;
        if (Number.isNaN(value)) {
          numerator = (0, _index.numericLiteral)(0);
        } else {
          numerator = (0, _index.numericLiteral)(1);
        }
        result = (0, _index.binaryExpression)("/", numerator, (0, _index.numericLiteral)(0));
      }
      if (value < 0 || Object.is(value, -0)) {
        result = (0, _index.unaryExpression)("-", result);
      }
      return result;
    }
    if (typeof value === "bigint") {
      if (value < 0) {
        return (0, _index.unaryExpression)("-", (0, _index.bigIntLiteral)(-value));
      } else {
        return (0, _index.bigIntLiteral)(value);
      }
    }
    if (isRegExp(value)) {
      const pattern = value.source;
      const flags = /\/([a-z]*)$/.exec(value.toString())[1];
      return (0, _index.regExpLiteral)(pattern, flags);
    }
    if (Array.isArray(value)) {
      return (0, _index.arrayExpression)(value.map(valueToNode$1));
    }
    if (isPlainObject(value)) {
      const props = [];
      for (const key of Object.keys(value)) {
        let nodeKey, computed = false;
        if ((0, _isValidIdentifier.default)(key)) {
          if (key === "__proto__") {
            computed = true;
            nodeKey = (0, _index.stringLiteral)(key);
          } else {
            nodeKey = (0, _index.identifier)(key);
          }
        } else {
          nodeKey = (0, _index.stringLiteral)(key);
        }
        props.push((0, _index.objectProperty)(nodeKey, valueToNode$1(value[key]), computed));
      }
      return (0, _index.objectExpression)(props);
    }
    throw new Error("don't know how to turn this value into a node");
  }
  return valueToNode;
}
var appendToMemberExpression = {};
var hasRequiredAppendToMemberExpression;
function requireAppendToMemberExpression() {
  if (hasRequiredAppendToMemberExpression) return appendToMemberExpression;
  hasRequiredAppendToMemberExpression = 1;
  Object.defineProperty(appendToMemberExpression, "__esModule", {
    value: true
  });
  appendToMemberExpression.default = appendToMemberExpression$1;
  var _index = requireGenerated$2();
  function appendToMemberExpression$1(member, append, computed = false) {
    member.object = (0, _index.memberExpression)(member.object, member.property, member.computed);
    member.property = append;
    member.computed = !!computed;
    return member;
  }
  return appendToMemberExpression;
}
var inherits = {};
var hasRequiredInherits;
function requireInherits() {
  if (hasRequiredInherits) return inherits;
  hasRequiredInherits = 1;
  Object.defineProperty(inherits, "__esModule", {
    value: true
  });
  inherits.default = inherits$1;
  var _index = requireConstants();
  var _inheritsComments = requireInheritsComments();
  function inherits$1(child, parent) {
    if (!child || !parent) return child;
    for (const key of _index.INHERIT_KEYS.optional) {
      if (child[key] == null) {
        child[key] = parent[key];
      }
    }
    for (const key of Object.keys(parent)) {
      if (key[0] === "_" && key !== "__clone") {
        child[key] = parent[key];
      }
    }
    for (const key of _index.INHERIT_KEYS.force) {
      child[key] = parent[key];
    }
    (0, _inheritsComments.default)(child, parent);
    return child;
  }
  return inherits;
}
var prependToMemberExpression = {};
var hasRequiredPrependToMemberExpression;
function requirePrependToMemberExpression() {
  if (hasRequiredPrependToMemberExpression) return prependToMemberExpression;
  hasRequiredPrependToMemberExpression = 1;
  Object.defineProperty(prependToMemberExpression, "__esModule", {
    value: true
  });
  prependToMemberExpression.default = prependToMemberExpression$1;
  var _index = requireGenerated$2();
  var _index2 = requireLib$4();
  function prependToMemberExpression$1(member, prepend) {
    if ((0, _index2.isSuper)(member.object)) {
      throw new Error("Cannot prepend node to super property access (`super.foo`).");
    }
    member.object = (0, _index.memberExpression)(prepend, member.object);
    return member;
  }
  return prependToMemberExpression;
}
var getAssignmentIdentifiers = {};
var hasRequiredGetAssignmentIdentifiers;
function requireGetAssignmentIdentifiers() {
  if (hasRequiredGetAssignmentIdentifiers) return getAssignmentIdentifiers;
  hasRequiredGetAssignmentIdentifiers = 1;
  Object.defineProperty(getAssignmentIdentifiers, "__esModule", {
    value: true
  });
  getAssignmentIdentifiers.default = getAssignmentIdentifiers$1;
  function getAssignmentIdentifiers$1(node2) {
    const search = [].concat(node2);
    const ids = /* @__PURE__ */ Object.create(null);
    while (search.length) {
      const id = search.pop();
      if (!id) continue;
      switch (id.type) {
        case "ArrayPattern":
          search.push(...id.elements);
          break;
        case "AssignmentExpression":
        case "AssignmentPattern":
        case "ForInStatement":
        case "ForOfStatement":
          search.push(id.left);
          break;
        case "ObjectPattern":
          search.push(...id.properties);
          break;
        case "ObjectProperty":
          search.push(id.value);
          break;
        case "RestElement":
        case "UpdateExpression":
          search.push(id.argument);
          break;
        case "UnaryExpression":
          if (id.operator === "delete") {
            search.push(id.argument);
          }
          break;
        case "Identifier":
          ids[id.name] = id;
          break;
      }
    }
    return ids;
  }
  return getAssignmentIdentifiers;
}
var getBindingIdentifiers = {};
var hasRequiredGetBindingIdentifiers;
function requireGetBindingIdentifiers() {
  if (hasRequiredGetBindingIdentifiers) return getBindingIdentifiers;
  hasRequiredGetBindingIdentifiers = 1;
  Object.defineProperty(getBindingIdentifiers, "__esModule", {
    value: true
  });
  getBindingIdentifiers.default = getBindingIdentifiers$1;
  var _index = requireGenerated$3();
  function getBindingIdentifiers$1(node2, duplicates, outerOnly, newBindingsOnly) {
    const search = [].concat(node2);
    const ids = /* @__PURE__ */ Object.create(null);
    while (search.length) {
      const id = search.shift();
      if (!id) continue;
      if (newBindingsOnly && ((0, _index.isAssignmentExpression)(id) || (0, _index.isUnaryExpression)(id) || (0, _index.isUpdateExpression)(id))) {
        continue;
      }
      if ((0, _index.isIdentifier)(id)) {
        if (duplicates) {
          const _ids = ids[id.name] = ids[id.name] || [];
          _ids.push(id);
        } else {
          ids[id.name] = id;
        }
        continue;
      }
      if ((0, _index.isExportDeclaration)(id) && !(0, _index.isExportAllDeclaration)(id)) {
        if ((0, _index.isDeclaration)(id.declaration)) {
          search.push(id.declaration);
        }
        continue;
      }
      if (outerOnly) {
        if ((0, _index.isFunctionDeclaration)(id)) {
          search.push(id.id);
          continue;
        }
        if ((0, _index.isFunctionExpression)(id)) {
          continue;
        }
      }
      const keys2 = getBindingIdentifiers$1.keys[id.type];
      if (keys2) {
        for (let i = 0; i < keys2.length; i++) {
          const key = keys2[i];
          const nodes = id[key];
          if (nodes) {
            if (Array.isArray(nodes)) {
              search.push(...nodes);
            } else {
              search.push(nodes);
            }
          }
        }
      }
    }
    return ids;
  }
  const keys = {
    DeclareClass: ["id"],
    DeclareFunction: ["id"],
    DeclareModule: ["id"],
    DeclareVariable: ["id"],
    DeclareInterface: ["id"],
    DeclareTypeAlias: ["id"],
    DeclareOpaqueType: ["id"],
    InterfaceDeclaration: ["id"],
    TypeAlias: ["id"],
    OpaqueType: ["id"],
    CatchClause: ["param"],
    LabeledStatement: ["label"],
    UnaryExpression: ["argument"],
    AssignmentExpression: ["left"],
    ImportSpecifier: ["local"],
    ImportNamespaceSpecifier: ["local"],
    ImportDefaultSpecifier: ["local"],
    ImportDeclaration: ["specifiers"],
    TSImportEqualsDeclaration: ["id"],
    ExportSpecifier: ["exported"],
    ExportNamespaceSpecifier: ["exported"],
    ExportDefaultSpecifier: ["exported"],
    FunctionDeclaration: ["id", "params"],
    FunctionExpression: ["id", "params"],
    ArrowFunctionExpression: ["params"],
    ObjectMethod: ["params"],
    ClassMethod: ["params"],
    ClassPrivateMethod: ["params"],
    ForInStatement: ["left"],
    ForOfStatement: ["left"],
    ClassDeclaration: ["id"],
    ClassExpression: ["id"],
    RestElement: ["argument"],
    UpdateExpression: ["argument"],
    ObjectProperty: ["value"],
    AssignmentPattern: ["left"],
    ArrayPattern: ["elements"],
    ObjectPattern: ["properties"],
    VariableDeclaration: ["declarations"],
    VariableDeclarator: ["id"]
  };
  getBindingIdentifiers$1.keys = keys;
  return getBindingIdentifiers;
}
var getOuterBindingIdentifiers = {};
var hasRequiredGetOuterBindingIdentifiers;
function requireGetOuterBindingIdentifiers() {
  if (hasRequiredGetOuterBindingIdentifiers) return getOuterBindingIdentifiers;
  hasRequiredGetOuterBindingIdentifiers = 1;
  Object.defineProperty(getOuterBindingIdentifiers, "__esModule", {
    value: true
  });
  getOuterBindingIdentifiers.default = void 0;
  var _getBindingIdentifiers = requireGetBindingIdentifiers();
  getOuterBindingIdentifiers.default = getOuterBindingIdentifiers$1;
  function getOuterBindingIdentifiers$1(node2, duplicates) {
    return (0, _getBindingIdentifiers.default)(node2, duplicates, true);
  }
  return getOuterBindingIdentifiers;
}
var getFunctionName = {};
var hasRequiredGetFunctionName;
function requireGetFunctionName() {
  if (hasRequiredGetFunctionName) return getFunctionName;
  hasRequiredGetFunctionName = 1;
  Object.defineProperty(getFunctionName, "__esModule", {
    value: true
  });
  getFunctionName.default = getFunctionName$1;
  var _index = requireGenerated$3();
  function getNameFromLiteralId(id) {
    if ((0, _index.isNullLiteral)(id)) {
      return "null";
    }
    if ((0, _index.isRegExpLiteral)(id)) {
      return `/${id.pattern}/${id.flags}`;
    }
    if ((0, _index.isTemplateLiteral)(id)) {
      return id.quasis.map((quasi) => quasi.value.raw).join("");
    }
    if (id.value !== void 0) {
      return String(id.value);
    }
    return null;
  }
  function getObjectMemberKey(node2) {
    if (!node2.computed || (0, _index.isLiteral)(node2.key)) {
      return node2.key;
    }
  }
  function getFunctionName$1(node2, parent) {
    if ("id" in node2 && node2.id) {
      return {
        name: node2.id.name,
        originalNode: node2.id
      };
    }
    let prefix = "";
    let id;
    if ((0, _index.isObjectProperty)(parent, {
      value: node2
    })) {
      id = getObjectMemberKey(parent);
    } else if ((0, _index.isObjectMethod)(node2) || (0, _index.isClassMethod)(node2)) {
      id = getObjectMemberKey(node2);
      if (node2.kind === "get") prefix = "get ";
      else if (node2.kind === "set") prefix = "set ";
    } else if ((0, _index.isVariableDeclarator)(parent, {
      init: node2
    })) {
      id = parent.id;
    } else if ((0, _index.isAssignmentExpression)(parent, {
      operator: "=",
      right: node2
    })) {
      id = parent.left;
    }
    if (!id) return null;
    const name = (0, _index.isLiteral)(id) ? getNameFromLiteralId(id) : (0, _index.isIdentifier)(id) ? id.name : (0, _index.isPrivateName)(id) ? id.id.name : null;
    if (name == null) return null;
    return {
      name: prefix + name,
      originalNode: id
    };
  }
  return getFunctionName;
}
var traverse$1 = {};
var hasRequiredTraverse;
function requireTraverse() {
  if (hasRequiredTraverse) return traverse$1;
  hasRequiredTraverse = 1;
  Object.defineProperty(traverse$1, "__esModule", {
    value: true
  });
  traverse$1.default = traverse2;
  var _index = requireDefinitions();
  function traverse2(node2, handlers, state) {
    if (typeof handlers === "function") {
      handlers = {
        enter: handlers
      };
    }
    const {
      enter,
      exit
    } = handlers;
    traverseSimpleImpl(node2, enter, exit, state, []);
  }
  function traverseSimpleImpl(node2, enter, exit, state, ancestors) {
    const keys = _index.VISITOR_KEYS[node2.type];
    if (!keys) return;
    if (enter) enter(node2, ancestors, state);
    for (const key of keys) {
      const subNode = node2[key];
      if (Array.isArray(subNode)) {
        for (let i = 0; i < subNode.length; i++) {
          const child = subNode[i];
          if (!child) continue;
          ancestors.push({
            node: node2,
            key,
            index: i
          });
          traverseSimpleImpl(child, enter, exit, state, ancestors);
          ancestors.pop();
        }
      } else if (subNode) {
        ancestors.push({
          node: node2,
          key
        });
        traverseSimpleImpl(subNode, enter, exit, state, ancestors);
        ancestors.pop();
      }
    }
    if (exit) exit(node2, ancestors, state);
  }
  return traverse$1;
}
var isBinding = {};
var hasRequiredIsBinding;
function requireIsBinding() {
  if (hasRequiredIsBinding) return isBinding;
  hasRequiredIsBinding = 1;
  Object.defineProperty(isBinding, "__esModule", {
    value: true
  });
  isBinding.default = isBinding$1;
  var _getBindingIdentifiers = requireGetBindingIdentifiers();
  function isBinding$1(node2, parent, grandparent) {
    if (grandparent && node2.type === "Identifier" && parent.type === "ObjectProperty" && grandparent.type === "ObjectExpression") {
      return false;
    }
    const keys = _getBindingIdentifiers.default.keys[parent.type];
    if (keys) {
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        const val = parent[key];
        if (Array.isArray(val)) {
          if (val.includes(node2)) return true;
        } else {
          if (val === node2) return true;
        }
      }
    }
    return false;
  }
  return isBinding;
}
var isBlockScoped = {};
var isLet = {};
var hasRequiredIsLet;
function requireIsLet() {
  if (hasRequiredIsLet) return isLet;
  hasRequiredIsLet = 1;
  Object.defineProperty(isLet, "__esModule", {
    value: true
  });
  isLet.default = isLet$1;
  var _index = requireGenerated$3();
  {
    var BLOCK_SCOPED_SYMBOL = /* @__PURE__ */ Symbol.for("var used to be block scoped");
  }
  function isLet$1(node2) {
    {
      return (0, _index.isVariableDeclaration)(node2) && (node2.kind !== "var" || node2[BLOCK_SCOPED_SYMBOL]);
    }
  }
  return isLet;
}
var hasRequiredIsBlockScoped;
function requireIsBlockScoped() {
  if (hasRequiredIsBlockScoped) return isBlockScoped;
  hasRequiredIsBlockScoped = 1;
  Object.defineProperty(isBlockScoped, "__esModule", {
    value: true
  });
  isBlockScoped.default = isBlockScoped$1;
  var _index = requireGenerated$3();
  var _isLet = requireIsLet();
  function isBlockScoped$1(node2) {
    return (0, _index.isFunctionDeclaration)(node2) || (0, _index.isClassDeclaration)(node2) || (0, _isLet.default)(node2);
  }
  return isBlockScoped;
}
var isImmutable = {};
var hasRequiredIsImmutable;
function requireIsImmutable() {
  if (hasRequiredIsImmutable) return isImmutable;
  hasRequiredIsImmutable = 1;
  Object.defineProperty(isImmutable, "__esModule", {
    value: true
  });
  isImmutable.default = isImmutable$1;
  var _isType = requireIsType();
  var _index = requireGenerated$3();
  function isImmutable$1(node2) {
    if ((0, _isType.default)(node2.type, "Immutable")) return true;
    if ((0, _index.isIdentifier)(node2)) {
      if (node2.name === "undefined") {
        return true;
      } else {
        return false;
      }
    }
    return false;
  }
  return isImmutable;
}
var isNodesEquivalent = {};
var hasRequiredIsNodesEquivalent;
function requireIsNodesEquivalent() {
  if (hasRequiredIsNodesEquivalent) return isNodesEquivalent;
  hasRequiredIsNodesEquivalent = 1;
  Object.defineProperty(isNodesEquivalent, "__esModule", {
    value: true
  });
  isNodesEquivalent.default = isNodesEquivalent$1;
  var _index = requireDefinitions();
  function isNodesEquivalent$1(a, b) {
    if (typeof a !== "object" || typeof b !== "object" || a == null || b == null) {
      return a === b;
    }
    if (a.type !== b.type) {
      return false;
    }
    const fields = Object.keys(_index.NODE_FIELDS[a.type] || a.type);
    const visitorKeys = _index.VISITOR_KEYS[a.type];
    for (const field of fields) {
      const val_a = a[field];
      const val_b = b[field];
      if (typeof val_a !== typeof val_b) {
        return false;
      }
      if (val_a == null && val_b == null) {
        continue;
      } else if (val_a == null || val_b == null) {
        return false;
      }
      if (Array.isArray(val_a)) {
        if (!Array.isArray(val_b)) {
          return false;
        }
        if (val_a.length !== val_b.length) {
          return false;
        }
        for (let i = 0; i < val_a.length; i++) {
          if (!isNodesEquivalent$1(val_a[i], val_b[i])) {
            return false;
          }
        }
        continue;
      }
      if (typeof val_a === "object" && !(visitorKeys != null && visitorKeys.includes(field))) {
        for (const key of Object.keys(val_a)) {
          if (val_a[key] !== val_b[key]) {
            return false;
          }
        }
        continue;
      }
      if (!isNodesEquivalent$1(val_a, val_b)) {
        return false;
      }
    }
    return true;
  }
  return isNodesEquivalent;
}
var isReferenced = {};
var hasRequiredIsReferenced;
function requireIsReferenced() {
  if (hasRequiredIsReferenced) return isReferenced;
  hasRequiredIsReferenced = 1;
  Object.defineProperty(isReferenced, "__esModule", {
    value: true
  });
  isReferenced.default = isReferenced$1;
  function isReferenced$1(node2, parent, grandparent) {
    switch (parent.type) {
      case "MemberExpression":
      case "OptionalMemberExpression":
        if (parent.property === node2) {
          return !!parent.computed;
        }
        return parent.object === node2;
      case "JSXMemberExpression":
        return parent.object === node2;
      case "VariableDeclarator":
        return parent.init === node2;
      case "ArrowFunctionExpression":
        return parent.body === node2;
      case "PrivateName":
        return false;
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "ObjectMethod":
        if (parent.key === node2) {
          return !!parent.computed;
        }
        return false;
      case "ObjectProperty":
        if (parent.key === node2) {
          return !!parent.computed;
        }
        return !grandparent || grandparent.type !== "ObjectPattern";
      case "ClassProperty":
      case "ClassAccessorProperty":
        if (parent.key === node2) {
          return !!parent.computed;
        }
        return true;
      case "ClassPrivateProperty":
        return parent.key !== node2;
      case "ClassDeclaration":
      case "ClassExpression":
        return parent.superClass === node2;
      case "AssignmentExpression":
        return parent.right === node2;
      case "AssignmentPattern":
        return parent.right === node2;
      case "LabeledStatement":
        return false;
      case "CatchClause":
        return false;
      case "RestElement":
        return false;
      case "BreakStatement":
      case "ContinueStatement":
        return false;
      case "FunctionDeclaration":
      case "FunctionExpression":
        return false;
      case "ExportNamespaceSpecifier":
      case "ExportDefaultSpecifier":
        return false;
      case "ExportSpecifier":
        if (grandparent != null && grandparent.source) {
          return false;
        }
        return parent.local === node2;
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
        return false;
      case "ImportAttribute":
        return false;
      case "JSXAttribute":
        return false;
      case "ObjectPattern":
      case "ArrayPattern":
        return false;
      case "MetaProperty":
        return false;
      case "ObjectTypeProperty":
        return parent.key !== node2;
      case "TSEnumMember":
        return parent.id !== node2;
      case "TSPropertySignature":
        if (parent.key === node2) {
          return !!parent.computed;
        }
        return true;
    }
    return true;
  }
  return isReferenced;
}
var isScope = {};
var hasRequiredIsScope;
function requireIsScope() {
  if (hasRequiredIsScope) return isScope;
  hasRequiredIsScope = 1;
  Object.defineProperty(isScope, "__esModule", {
    value: true
  });
  isScope.default = isScope$1;
  var _index = requireGenerated$3();
  function isScope$1(node2, parent) {
    if ((0, _index.isBlockStatement)(node2) && ((0, _index.isFunction)(parent) || (0, _index.isCatchClause)(parent))) {
      return false;
    }
    if ((0, _index.isPattern)(node2) && ((0, _index.isFunction)(parent) || (0, _index.isCatchClause)(parent))) {
      return true;
    }
    return (0, _index.isScopable)(node2);
  }
  return isScope;
}
var isSpecifierDefault = {};
var hasRequiredIsSpecifierDefault;
function requireIsSpecifierDefault() {
  if (hasRequiredIsSpecifierDefault) return isSpecifierDefault;
  hasRequiredIsSpecifierDefault = 1;
  Object.defineProperty(isSpecifierDefault, "__esModule", {
    value: true
  });
  isSpecifierDefault.default = isSpecifierDefault$1;
  var _index = requireGenerated$3();
  function isSpecifierDefault$1(specifier) {
    return (0, _index.isImportDefaultSpecifier)(specifier) || (0, _index.isIdentifier)(specifier.imported || specifier.exported, {
      name: "default"
    });
  }
  return isSpecifierDefault;
}
var isValidES3Identifier = {};
var hasRequiredIsValidES3Identifier;
function requireIsValidES3Identifier() {
  if (hasRequiredIsValidES3Identifier) return isValidES3Identifier;
  hasRequiredIsValidES3Identifier = 1;
  Object.defineProperty(isValidES3Identifier, "__esModule", {
    value: true
  });
  isValidES3Identifier.default = isValidES3Identifier$1;
  var _isValidIdentifier = requireIsValidIdentifier();
  const RESERVED_WORDS_ES3_ONLY = /* @__PURE__ */ new Set(["abstract", "boolean", "byte", "char", "double", "enum", "final", "float", "goto", "implements", "int", "interface", "long", "native", "package", "private", "protected", "public", "short", "static", "synchronized", "throws", "transient", "volatile"]);
  function isValidES3Identifier$1(name) {
    return (0, _isValidIdentifier.default)(name) && !RESERVED_WORDS_ES3_ONLY.has(name);
  }
  return isValidES3Identifier;
}
var isVar = {};
var hasRequiredIsVar;
function requireIsVar() {
  if (hasRequiredIsVar) return isVar;
  hasRequiredIsVar = 1;
  Object.defineProperty(isVar, "__esModule", {
    value: true
  });
  isVar.default = isVar$1;
  var _index = requireGenerated$3();
  {
    var BLOCK_SCOPED_SYMBOL = /* @__PURE__ */ Symbol.for("var used to be block scoped");
  }
  function isVar$1(node2) {
    {
      return (0, _index.isVariableDeclaration)(node2, {
        kind: "var"
      }) && !node2[BLOCK_SCOPED_SYMBOL];
    }
  }
  return isVar;
}
var toSequenceExpression = {};
var gatherSequenceExpressions = {};
var hasRequiredGatherSequenceExpressions;
function requireGatherSequenceExpressions() {
  if (hasRequiredGatherSequenceExpressions) return gatherSequenceExpressions;
  hasRequiredGatherSequenceExpressions = 1;
  Object.defineProperty(gatherSequenceExpressions, "__esModule", {
    value: true
  });
  gatherSequenceExpressions.default = gatherSequenceExpressions$1;
  var _getBindingIdentifiers = requireGetBindingIdentifiers();
  var _index = requireGenerated$3();
  var _index2 = requireGenerated$2();
  var _productions = requireProductions();
  var _cloneNode = requireCloneNode();
  function gatherSequenceExpressions$1(nodes, declars) {
    const exprs = [];
    let ensureLastUndefined = true;
    for (const node2 of nodes) {
      if (!(0, _index.isEmptyStatement)(node2)) {
        ensureLastUndefined = false;
      }
      if ((0, _index.isExpression)(node2)) {
        exprs.push(node2);
      } else if ((0, _index.isExpressionStatement)(node2)) {
        exprs.push(node2.expression);
      } else if ((0, _index.isVariableDeclaration)(node2)) {
        if (node2.kind !== "var") return;
        for (const declar of node2.declarations) {
          const bindings = (0, _getBindingIdentifiers.default)(declar);
          for (const key of Object.keys(bindings)) {
            declars.push({
              kind: node2.kind,
              id: (0, _cloneNode.default)(bindings[key])
            });
          }
          if (declar.init) {
            exprs.push((0, _index2.assignmentExpression)("=", declar.id, declar.init));
          }
        }
        ensureLastUndefined = true;
      } else if ((0, _index.isIfStatement)(node2)) {
        const consequent = node2.consequent ? gatherSequenceExpressions$1([node2.consequent], declars) : (0, _productions.buildUndefinedNode)();
        const alternate = node2.alternate ? gatherSequenceExpressions$1([node2.alternate], declars) : (0, _productions.buildUndefinedNode)();
        if (!consequent || !alternate) return;
        exprs.push((0, _index2.conditionalExpression)(node2.test, consequent, alternate));
      } else if ((0, _index.isBlockStatement)(node2)) {
        const body = gatherSequenceExpressions$1(node2.body, declars);
        if (!body) return;
        exprs.push(body);
      } else if ((0, _index.isEmptyStatement)(node2)) {
        if (nodes.indexOf(node2) === 0) {
          ensureLastUndefined = true;
        }
      } else {
        return;
      }
    }
    if (ensureLastUndefined) {
      exprs.push((0, _productions.buildUndefinedNode)());
    }
    if (exprs.length === 1) {
      return exprs[0];
    } else {
      return (0, _index2.sequenceExpression)(exprs);
    }
  }
  return gatherSequenceExpressions;
}
var hasRequiredToSequenceExpression;
function requireToSequenceExpression() {
  if (hasRequiredToSequenceExpression) return toSequenceExpression;
  hasRequiredToSequenceExpression = 1;
  Object.defineProperty(toSequenceExpression, "__esModule", {
    value: true
  });
  toSequenceExpression.default = toSequenceExpression$1;
  var _gatherSequenceExpressions = requireGatherSequenceExpressions();
  function toSequenceExpression$1(nodes, scope2) {
    if (!(nodes != null && nodes.length)) return;
    const declars = [];
    const result = (0, _gatherSequenceExpressions.default)(nodes, declars);
    if (!result) return;
    for (const declar of declars) {
      scope2.push(declar);
    }
    return result;
  }
  return toSequenceExpression;
}
var hasRequiredLib$4;
function requireLib$4() {
  if (hasRequiredLib$4) return lib$5;
  hasRequiredLib$4 = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", {
      value: true
    });
    var _exportNames = {
      react: true,
      assertNode: true,
      createTypeAnnotationBasedOnTypeof: true,
      createUnionTypeAnnotation: true,
      createFlowUnionType: true,
      createTSUnionType: true,
      cloneNode: true,
      clone: true,
      cloneDeep: true,
      cloneDeepWithoutLoc: true,
      cloneWithoutLoc: true,
      addComment: true,
      addComments: true,
      inheritInnerComments: true,
      inheritLeadingComments: true,
      inheritsComments: true,
      inheritTrailingComments: true,
      removeComments: true,
      ensureBlock: true,
      toBindingIdentifierName: true,
      toBlock: true,
      toComputedKey: true,
      toExpression: true,
      toIdentifier: true,
      toKeyAlias: true,
      toStatement: true,
      valueToNode: true,
      appendToMemberExpression: true,
      inherits: true,
      prependToMemberExpression: true,
      removeProperties: true,
      removePropertiesDeep: true,
      removeTypeDuplicates: true,
      getAssignmentIdentifiers: true,
      getBindingIdentifiers: true,
      getOuterBindingIdentifiers: true,
      getFunctionName: true,
      traverse: true,
      traverseFast: true,
      shallowEqual: true,
      is: true,
      isBinding: true,
      isBlockScoped: true,
      isImmutable: true,
      isLet: true,
      isNode: true,
      isNodesEquivalent: true,
      isPlaceholderType: true,
      isReferenced: true,
      isScope: true,
      isSpecifierDefault: true,
      isType: true,
      isValidES3Identifier: true,
      isValidIdentifier: true,
      isVar: true,
      matchesPattern: true,
      validate: true,
      buildMatchMemberExpression: true,
      __internal__deprecationWarning: true
    };
    Object.defineProperty(exports$1, "__internal__deprecationWarning", {
      enumerable: true,
      get: function() {
        return _deprecationWarning.default;
      }
    });
    Object.defineProperty(exports$1, "addComment", {
      enumerable: true,
      get: function() {
        return _addComment.default;
      }
    });
    Object.defineProperty(exports$1, "addComments", {
      enumerable: true,
      get: function() {
        return _addComments.default;
      }
    });
    Object.defineProperty(exports$1, "appendToMemberExpression", {
      enumerable: true,
      get: function() {
        return _appendToMemberExpression.default;
      }
    });
    Object.defineProperty(exports$1, "assertNode", {
      enumerable: true,
      get: function() {
        return _assertNode.default;
      }
    });
    Object.defineProperty(exports$1, "buildMatchMemberExpression", {
      enumerable: true,
      get: function() {
        return _buildMatchMemberExpression.default;
      }
    });
    Object.defineProperty(exports$1, "clone", {
      enumerable: true,
      get: function() {
        return _clone.default;
      }
    });
    Object.defineProperty(exports$1, "cloneDeep", {
      enumerable: true,
      get: function() {
        return _cloneDeep.default;
      }
    });
    Object.defineProperty(exports$1, "cloneDeepWithoutLoc", {
      enumerable: true,
      get: function() {
        return _cloneDeepWithoutLoc.default;
      }
    });
    Object.defineProperty(exports$1, "cloneNode", {
      enumerable: true,
      get: function() {
        return _cloneNode.default;
      }
    });
    Object.defineProperty(exports$1, "cloneWithoutLoc", {
      enumerable: true,
      get: function() {
        return _cloneWithoutLoc.default;
      }
    });
    Object.defineProperty(exports$1, "createFlowUnionType", {
      enumerable: true,
      get: function() {
        return _createFlowUnionType.default;
      }
    });
    Object.defineProperty(exports$1, "createTSUnionType", {
      enumerable: true,
      get: function() {
        return _createTSUnionType.default;
      }
    });
    Object.defineProperty(exports$1, "createTypeAnnotationBasedOnTypeof", {
      enumerable: true,
      get: function() {
        return _createTypeAnnotationBasedOnTypeof.default;
      }
    });
    Object.defineProperty(exports$1, "createUnionTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _createFlowUnionType.default;
      }
    });
    Object.defineProperty(exports$1, "ensureBlock", {
      enumerable: true,
      get: function() {
        return _ensureBlock.default;
      }
    });
    Object.defineProperty(exports$1, "getAssignmentIdentifiers", {
      enumerable: true,
      get: function() {
        return _getAssignmentIdentifiers.default;
      }
    });
    Object.defineProperty(exports$1, "getBindingIdentifiers", {
      enumerable: true,
      get: function() {
        return _getBindingIdentifiers.default;
      }
    });
    Object.defineProperty(exports$1, "getFunctionName", {
      enumerable: true,
      get: function() {
        return _getFunctionName.default;
      }
    });
    Object.defineProperty(exports$1, "getOuterBindingIdentifiers", {
      enumerable: true,
      get: function() {
        return _getOuterBindingIdentifiers.default;
      }
    });
    Object.defineProperty(exports$1, "inheritInnerComments", {
      enumerable: true,
      get: function() {
        return _inheritInnerComments.default;
      }
    });
    Object.defineProperty(exports$1, "inheritLeadingComments", {
      enumerable: true,
      get: function() {
        return _inheritLeadingComments.default;
      }
    });
    Object.defineProperty(exports$1, "inheritTrailingComments", {
      enumerable: true,
      get: function() {
        return _inheritTrailingComments.default;
      }
    });
    Object.defineProperty(exports$1, "inherits", {
      enumerable: true,
      get: function() {
        return _inherits.default;
      }
    });
    Object.defineProperty(exports$1, "inheritsComments", {
      enumerable: true,
      get: function() {
        return _inheritsComments.default;
      }
    });
    Object.defineProperty(exports$1, "is", {
      enumerable: true,
      get: function() {
        return _is.default;
      }
    });
    Object.defineProperty(exports$1, "isBinding", {
      enumerable: true,
      get: function() {
        return _isBinding.default;
      }
    });
    Object.defineProperty(exports$1, "isBlockScoped", {
      enumerable: true,
      get: function() {
        return _isBlockScoped.default;
      }
    });
    Object.defineProperty(exports$1, "isImmutable", {
      enumerable: true,
      get: function() {
        return _isImmutable.default;
      }
    });
    Object.defineProperty(exports$1, "isLet", {
      enumerable: true,
      get: function() {
        return _isLet.default;
      }
    });
    Object.defineProperty(exports$1, "isNode", {
      enumerable: true,
      get: function() {
        return _isNode.default;
      }
    });
    Object.defineProperty(exports$1, "isNodesEquivalent", {
      enumerable: true,
      get: function() {
        return _isNodesEquivalent.default;
      }
    });
    Object.defineProperty(exports$1, "isPlaceholderType", {
      enumerable: true,
      get: function() {
        return _isPlaceholderType.default;
      }
    });
    Object.defineProperty(exports$1, "isReferenced", {
      enumerable: true,
      get: function() {
        return _isReferenced.default;
      }
    });
    Object.defineProperty(exports$1, "isScope", {
      enumerable: true,
      get: function() {
        return _isScope.default;
      }
    });
    Object.defineProperty(exports$1, "isSpecifierDefault", {
      enumerable: true,
      get: function() {
        return _isSpecifierDefault.default;
      }
    });
    Object.defineProperty(exports$1, "isType", {
      enumerable: true,
      get: function() {
        return _isType.default;
      }
    });
    Object.defineProperty(exports$1, "isValidES3Identifier", {
      enumerable: true,
      get: function() {
        return _isValidES3Identifier.default;
      }
    });
    Object.defineProperty(exports$1, "isValidIdentifier", {
      enumerable: true,
      get: function() {
        return _isValidIdentifier.default;
      }
    });
    Object.defineProperty(exports$1, "isVar", {
      enumerable: true,
      get: function() {
        return _isVar.default;
      }
    });
    Object.defineProperty(exports$1, "matchesPattern", {
      enumerable: true,
      get: function() {
        return _matchesPattern.default;
      }
    });
    Object.defineProperty(exports$1, "prependToMemberExpression", {
      enumerable: true,
      get: function() {
        return _prependToMemberExpression.default;
      }
    });
    exports$1.react = void 0;
    Object.defineProperty(exports$1, "removeComments", {
      enumerable: true,
      get: function() {
        return _removeComments.default;
      }
    });
    Object.defineProperty(exports$1, "removeProperties", {
      enumerable: true,
      get: function() {
        return _removeProperties.default;
      }
    });
    Object.defineProperty(exports$1, "removePropertiesDeep", {
      enumerable: true,
      get: function() {
        return _removePropertiesDeep.default;
      }
    });
    Object.defineProperty(exports$1, "removeTypeDuplicates", {
      enumerable: true,
      get: function() {
        return _removeTypeDuplicates.default;
      }
    });
    Object.defineProperty(exports$1, "shallowEqual", {
      enumerable: true,
      get: function() {
        return _shallowEqual.default;
      }
    });
    Object.defineProperty(exports$1, "toBindingIdentifierName", {
      enumerable: true,
      get: function() {
        return _toBindingIdentifierName.default;
      }
    });
    Object.defineProperty(exports$1, "toBlock", {
      enumerable: true,
      get: function() {
        return _toBlock.default;
      }
    });
    Object.defineProperty(exports$1, "toComputedKey", {
      enumerable: true,
      get: function() {
        return _toComputedKey.default;
      }
    });
    Object.defineProperty(exports$1, "toExpression", {
      enumerable: true,
      get: function() {
        return _toExpression.default;
      }
    });
    Object.defineProperty(exports$1, "toIdentifier", {
      enumerable: true,
      get: function() {
        return _toIdentifier.default;
      }
    });
    Object.defineProperty(exports$1, "toKeyAlias", {
      enumerable: true,
      get: function() {
        return _toKeyAlias.default;
      }
    });
    Object.defineProperty(exports$1, "toStatement", {
      enumerable: true,
      get: function() {
        return _toStatement.default;
      }
    });
    Object.defineProperty(exports$1, "traverse", {
      enumerable: true,
      get: function() {
        return _traverse.default;
      }
    });
    Object.defineProperty(exports$1, "traverseFast", {
      enumerable: true,
      get: function() {
        return _traverseFast.default;
      }
    });
    Object.defineProperty(exports$1, "validate", {
      enumerable: true,
      get: function() {
        return _validate.default;
      }
    });
    Object.defineProperty(exports$1, "valueToNode", {
      enumerable: true,
      get: function() {
        return _valueToNode.default;
      }
    });
    var _isReactComponent = requireIsReactComponent();
    var _isCompatTag = requireIsCompatTag();
    var _buildChildren = requireBuildChildren();
    var _assertNode = requireAssertNode();
    var _index = requireGenerated$1();
    Object.keys(_index).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports$1 && exports$1[key] === _index[key]) return;
      Object.defineProperty(exports$1, key, {
        enumerable: true,
        get: function() {
          return _index[key];
        }
      });
    });
    var _createTypeAnnotationBasedOnTypeof = requireCreateTypeAnnotationBasedOnTypeof();
    var _createFlowUnionType = requireCreateFlowUnionType();
    var _createTSUnionType = requireCreateTSUnionType();
    var _productions = requireProductions();
    Object.keys(_productions).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports$1 && exports$1[key] === _productions[key]) return;
      Object.defineProperty(exports$1, key, {
        enumerable: true,
        get: function() {
          return _productions[key];
        }
      });
    });
    var _index2 = requireGenerated$2();
    Object.keys(_index2).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports$1 && exports$1[key] === _index2[key]) return;
      Object.defineProperty(exports$1, key, {
        enumerable: true,
        get: function() {
          return _index2[key];
        }
      });
    });
    var _cloneNode = requireCloneNode();
    var _clone = requireClone();
    var _cloneDeep = requireCloneDeep();
    var _cloneDeepWithoutLoc = requireCloneDeepWithoutLoc();
    var _cloneWithoutLoc = requireCloneWithoutLoc();
    var _addComment = requireAddComment();
    var _addComments = requireAddComments();
    var _inheritInnerComments = requireInheritInnerComments();
    var _inheritLeadingComments = requireInheritLeadingComments();
    var _inheritsComments = requireInheritsComments();
    var _inheritTrailingComments = requireInheritTrailingComments();
    var _removeComments = requireRemoveComments();
    var _index3 = requireGenerated();
    Object.keys(_index3).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports$1 && exports$1[key] === _index3[key]) return;
      Object.defineProperty(exports$1, key, {
        enumerable: true,
        get: function() {
          return _index3[key];
        }
      });
    });
    var _index4 = requireConstants();
    Object.keys(_index4).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports$1 && exports$1[key] === _index4[key]) return;
      Object.defineProperty(exports$1, key, {
        enumerable: true,
        get: function() {
          return _index4[key];
        }
      });
    });
    var _ensureBlock = requireEnsureBlock();
    var _toBindingIdentifierName = requireToBindingIdentifierName();
    var _toBlock = requireToBlock();
    var _toComputedKey = requireToComputedKey();
    var _toExpression = requireToExpression();
    var _toIdentifier = requireToIdentifier();
    var _toKeyAlias = requireToKeyAlias();
    var _toStatement = requireToStatement();
    var _valueToNode = requireValueToNode();
    var _index5 = requireDefinitions();
    Object.keys(_index5).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports$1 && exports$1[key] === _index5[key]) return;
      Object.defineProperty(exports$1, key, {
        enumerable: true,
        get: function() {
          return _index5[key];
        }
      });
    });
    var _appendToMemberExpression = requireAppendToMemberExpression();
    var _inherits = requireInherits();
    var _prependToMemberExpression = requirePrependToMemberExpression();
    var _removeProperties = requireRemoveProperties();
    var _removePropertiesDeep = requireRemovePropertiesDeep();
    var _removeTypeDuplicates = requireRemoveTypeDuplicates$1();
    var _getAssignmentIdentifiers = requireGetAssignmentIdentifiers();
    var _getBindingIdentifiers = requireGetBindingIdentifiers();
    var _getOuterBindingIdentifiers = requireGetOuterBindingIdentifiers();
    var _getFunctionName = requireGetFunctionName();
    var _traverse = requireTraverse();
    Object.keys(_traverse).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports$1 && exports$1[key] === _traverse[key]) return;
      Object.defineProperty(exports$1, key, {
        enumerable: true,
        get: function() {
          return _traverse[key];
        }
      });
    });
    var _traverseFast = requireTraverseFast();
    var _shallowEqual = requireShallowEqual();
    var _is = requireIs();
    var _isBinding = requireIsBinding();
    var _isBlockScoped = requireIsBlockScoped();
    var _isImmutable = requireIsImmutable();
    var _isLet = requireIsLet();
    var _isNode = requireIsNode();
    var _isNodesEquivalent = requireIsNodesEquivalent();
    var _isPlaceholderType = requireIsPlaceholderType();
    var _isReferenced = requireIsReferenced();
    var _isScope = requireIsScope();
    var _isSpecifierDefault = requireIsSpecifierDefault();
    var _isType = requireIsType();
    var _isValidES3Identifier = requireIsValidES3Identifier();
    var _isValidIdentifier = requireIsValidIdentifier();
    var _isVar = requireIsVar();
    var _matchesPattern = requireMatchesPattern();
    var _validate = requireValidate();
    var _buildMatchMemberExpression = requireBuildMatchMemberExpression();
    var _index6 = requireGenerated$3();
    Object.keys(_index6).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports$1 && exports$1[key] === _index6[key]) return;
      Object.defineProperty(exports$1, key, {
        enumerable: true,
        get: function() {
          return _index6[key];
        }
      });
    });
    var _deprecationWarning = requireDeprecationWarning();
    var _toSequenceExpression = requireToSequenceExpression();
    exports$1.react = {
      isReactComponent: _isReactComponent.default,
      isCompatTag: _isCompatTag.default,
      buildChildren: _buildChildren.default
    };
    {
      exports$1.toSequenceExpression = _toSequenceExpression.default;
    }
    if (process.env.BABEL_TYPES_8_BREAKING) {
      console.warn("BABEL_TYPES_8_BREAKING is not supported anymore. Use the latest Babel 8.0.0 pre-release instead!");
    }
  })(lib$5);
  return lib$5;
}
var visitors = {};
var virtualTypesValidator = {};
var hasRequiredVirtualTypesValidator;
function requireVirtualTypesValidator() {
  if (hasRequiredVirtualTypesValidator) return virtualTypesValidator;
  hasRequiredVirtualTypesValidator = 1;
  Object.defineProperty(virtualTypesValidator, "__esModule", {
    value: true
  });
  virtualTypesValidator.isBindingIdentifier = isBindingIdentifier;
  virtualTypesValidator.isBlockScoped = isBlockScoped2;
  virtualTypesValidator.isExpression = isExpression;
  virtualTypesValidator.isFlow = isFlow;
  virtualTypesValidator.isForAwaitStatement = isForAwaitStatement;
  virtualTypesValidator.isGenerated = isGenerated;
  virtualTypesValidator.isPure = isPure;
  virtualTypesValidator.isReferenced = isReferenced2;
  virtualTypesValidator.isReferencedIdentifier = isReferencedIdentifier;
  virtualTypesValidator.isReferencedMemberExpression = isReferencedMemberExpression;
  virtualTypesValidator.isRestProperty = isRestProperty;
  virtualTypesValidator.isScope = isScope2;
  virtualTypesValidator.isSpreadProperty = isSpreadProperty;
  virtualTypesValidator.isStatement = isStatement;
  virtualTypesValidator.isUser = isUser;
  virtualTypesValidator.isVar = isVar2;
  var _t = requireLib$4();
  const {
    isBinding: isBinding2,
    isBlockScoped: nodeIsBlockScoped,
    isExportDeclaration,
    isExpression: nodeIsExpression,
    isFlow: nodeIsFlow,
    isForStatement,
    isForXStatement,
    isIdentifier,
    isImportDeclaration,
    isImportSpecifier,
    isJSXIdentifier,
    isJSXMemberExpression,
    isMemberExpression,
    isRestElement: nodeIsRestElement,
    isReferenced: nodeIsReferenced,
    isScope: nodeIsScope,
    isStatement: nodeIsStatement,
    isVar: nodeIsVar,
    isVariableDeclaration,
    react,
    isForOfStatement
  } = _t;
  const {
    isCompatTag: isCompatTag2
  } = react;
  function isReferencedIdentifier(opts) {
    const {
      node: node2,
      parent
    } = this;
    if (isIdentifier(node2, opts)) {
      return nodeIsReferenced(node2, parent, this.parentPath.parent);
    } else if (isJSXIdentifier(node2, opts)) {
      if (!isJSXMemberExpression(parent) && isCompatTag2(node2.name)) return false;
      return nodeIsReferenced(node2, parent, this.parentPath.parent);
    } else {
      return false;
    }
  }
  function isReferencedMemberExpression() {
    const {
      node: node2,
      parent
    } = this;
    return isMemberExpression(node2) && nodeIsReferenced(node2, parent);
  }
  function isBindingIdentifier() {
    const {
      node: node2,
      parent
    } = this;
    const grandparent = this.parentPath.parent;
    return isIdentifier(node2) && isBinding2(node2, parent, grandparent);
  }
  function isStatement() {
    const {
      node: node2,
      parent
    } = this;
    if (nodeIsStatement(node2)) {
      if (isVariableDeclaration(node2)) {
        if (isForXStatement(parent, {
          left: node2
        })) return false;
        if (isForStatement(parent, {
          init: node2
        })) return false;
      }
      return true;
    } else {
      return false;
    }
  }
  function isExpression() {
    if (this.isIdentifier()) {
      return this.isReferencedIdentifier();
    } else {
      return nodeIsExpression(this.node);
    }
  }
  function isScope2() {
    return nodeIsScope(this.node, this.parent);
  }
  function isReferenced2() {
    return nodeIsReferenced(this.node, this.parent);
  }
  function isBlockScoped2() {
    return nodeIsBlockScoped(this.node);
  }
  function isVar2() {
    return nodeIsVar(this.node);
  }
  function isUser() {
    var _this$node;
    return !!((_this$node = this.node) != null && _this$node.loc);
  }
  function isGenerated() {
    return !this.isUser();
  }
  function isPure(constantsOnly) {
    return this.scope.isPure(this.node, constantsOnly);
  }
  function isFlow() {
    const {
      node: node2
    } = this;
    if (nodeIsFlow(node2)) {
      return true;
    } else if (isImportDeclaration(node2)) {
      return node2.importKind === "type" || node2.importKind === "typeof";
    } else if (isExportDeclaration(node2)) {
      return node2.exportKind === "type";
    } else if (isImportSpecifier(node2)) {
      return node2.importKind === "type" || node2.importKind === "typeof";
    } else {
      return false;
    }
  }
  function isRestProperty() {
    var _this$parentPath;
    return nodeIsRestElement(this.node) && ((_this$parentPath = this.parentPath) == null ? void 0 : _this$parentPath.isObjectPattern());
  }
  function isSpreadProperty() {
    var _this$parentPath2;
    return nodeIsRestElement(this.node) && ((_this$parentPath2 = this.parentPath) == null ? void 0 : _this$parentPath2.isObjectExpression());
  }
  function isForAwaitStatement() {
    return isForOfStatement(this.node, {
      await: true
    });
  }
  {
    virtualTypesValidator.isExistentialTypeParam = function isExistentialTypeParam() {
      throw new Error("`path.isExistentialTypeParam` has been renamed to `path.isExistsTypeAnnotation()` in Babel 7.");
    };
    virtualTypesValidator.isNumericLiteralTypeAnnotation = function isNumericLiteralTypeAnnotation() {
      throw new Error("`path.isNumericLiteralTypeAnnotation()` has been renamed to `path.isNumberLiteralTypeAnnotation()` in Babel 7.");
    };
  }
  return virtualTypesValidator;
}
var hasRequiredVisitors;
function requireVisitors() {
  if (hasRequiredVisitors) return visitors;
  hasRequiredVisitors = 1;
  Object.defineProperty(visitors, "__esModule", {
    value: true
  });
  visitors.environmentVisitor = environmentVisitor;
  visitors.explode = explode$1;
  visitors.isExplodedVisitor = isExplodedVisitor;
  visitors.merge = merge;
  visitors.verify = verify$1;
  var virtualTypes2 = requireVirtualTypes();
  var virtualTypesValidators = requireVirtualTypesValidator();
  var _t = requireLib$4();
  var _context = requireContext();
  const {
    DEPRECATED_KEYS,
    DEPRECATED_ALIASES,
    FLIPPED_ALIAS_KEYS,
    TYPES,
    __internal__deprecationWarning: deprecationWarning2
  } = _t;
  function isVirtualType(type) {
    return type in virtualTypes2;
  }
  function isExplodedVisitor(visitor) {
    return visitor == null ? void 0 : visitor._exploded;
  }
  function explode$1(visitor) {
    if (isExplodedVisitor(visitor)) return visitor;
    visitor._exploded = true;
    for (const nodeType of Object.keys(visitor)) {
      if (shouldIgnoreKey(nodeType)) continue;
      const parts = nodeType.split("|");
      if (parts.length === 1) continue;
      const fns = visitor[nodeType];
      delete visitor[nodeType];
      for (const part of parts) {
        visitor[part] = fns;
      }
    }
    verify$1(visitor);
    delete visitor.__esModule;
    ensureEntranceObjects(visitor);
    ensureCallbackArrays(visitor);
    for (const nodeType of Object.keys(visitor)) {
      if (shouldIgnoreKey(nodeType)) continue;
      if (!isVirtualType(nodeType)) continue;
      const fns = visitor[nodeType];
      for (const type of Object.keys(fns)) {
        fns[type] = wrapCheck(nodeType, fns[type]);
      }
      delete visitor[nodeType];
      const types2 = virtualTypes2[nodeType];
      if (types2 !== null) {
        for (const type of types2) {
          var _visitor$type;
          (_visitor$type = visitor[type]) != null ? _visitor$type : visitor[type] = {};
          mergePair(visitor[type], fns);
        }
      } else {
        mergePair(visitor, fns);
      }
    }
    for (const nodeType of Object.keys(visitor)) {
      if (shouldIgnoreKey(nodeType)) continue;
      let aliases = FLIPPED_ALIAS_KEYS[nodeType];
      if (nodeType in DEPRECATED_KEYS) {
        const deprecatedKey = DEPRECATED_KEYS[nodeType];
        deprecationWarning2(nodeType, deprecatedKey, "Visitor ");
        aliases = [deprecatedKey];
      } else if (nodeType in DEPRECATED_ALIASES) {
        const deprecatedAlias = DEPRECATED_ALIASES[nodeType];
        deprecationWarning2(nodeType, deprecatedAlias, "Visitor ");
        aliases = FLIPPED_ALIAS_KEYS[deprecatedAlias];
      }
      if (!aliases) continue;
      const fns = visitor[nodeType];
      delete visitor[nodeType];
      for (const alias of aliases) {
        const existing = visitor[alias];
        if (existing) {
          mergePair(existing, fns);
        } else {
          visitor[alias] = Object.assign({}, fns);
        }
      }
    }
    for (const nodeType of Object.keys(visitor)) {
      if (shouldIgnoreKey(nodeType)) continue;
      ensureCallbackArrays(visitor[nodeType]);
    }
    return visitor;
  }
  function verify$1(visitor) {
    if (visitor._verified) return;
    if (typeof visitor === "function") {
      throw new Error("You passed `traverse()` a function when it expected a visitor object, are you sure you didn't mean `{ enter: Function }`?");
    }
    for (const nodeType of Object.keys(visitor)) {
      if (nodeType === "enter" || nodeType === "exit") {
        validateVisitorMethods(nodeType, visitor[nodeType]);
      }
      if (shouldIgnoreKey(nodeType)) continue;
      if (!TYPES.includes(nodeType)) {
        throw new Error(`You gave us a visitor for the node type ${nodeType} but it's not a valid type in @babel/traverse ${"7.28.5"}`);
      }
      const visitors2 = visitor[nodeType];
      if (typeof visitors2 === "object") {
        for (const visitorKey of Object.keys(visitors2)) {
          if (visitorKey === "enter" || visitorKey === "exit") {
            validateVisitorMethods(`${nodeType}.${visitorKey}`, visitors2[visitorKey]);
          } else {
            throw new Error(`You passed \`traverse()\` a visitor object with the property ${nodeType} that has the invalid property ${visitorKey}`);
          }
        }
      }
    }
    visitor._verified = true;
  }
  function validateVisitorMethods(path2, val) {
    const fns = [].concat(val);
    for (const fn of fns) {
      if (typeof fn !== "function") {
        throw new TypeError(`Non-function found defined in ${path2} with type ${typeof fn}`);
      }
    }
  }
  function merge(visitors2, states = [], wrapper) {
    const mergedVisitor = {
      _verified: true,
      _exploded: true
    };
    {
      Object.defineProperty(mergedVisitor, "_exploded", {
        enumerable: false
      });
      Object.defineProperty(mergedVisitor, "_verified", {
        enumerable: false
      });
    }
    for (let i = 0; i < visitors2.length; i++) {
      const visitor = explode$1(visitors2[i]);
      const state = states[i];
      let topVisitor = visitor;
      if (state || wrapper) {
        topVisitor = wrapWithStateOrWrapper(topVisitor, state, wrapper);
      }
      mergePair(mergedVisitor, topVisitor);
      for (const key of Object.keys(visitor)) {
        if (shouldIgnoreKey(key)) continue;
        let typeVisitor = visitor[key];
        if (state || wrapper) {
          typeVisitor = wrapWithStateOrWrapper(typeVisitor, state, wrapper);
        }
        const nodeVisitor = mergedVisitor[key] || (mergedVisitor[key] = {});
        mergePair(nodeVisitor, typeVisitor);
      }
    }
    return mergedVisitor;
  }
  function wrapWithStateOrWrapper(oldVisitor, state, wrapper) {
    const newVisitor = {};
    for (const phase of ["enter", "exit"]) {
      let fns = oldVisitor[phase];
      if (!Array.isArray(fns)) continue;
      fns = fns.map(function(fn) {
        let newFn = fn;
        if (state) {
          newFn = function(path2) {
            fn.call(state, path2, state);
          };
        }
        if (wrapper) {
          newFn = wrapper(state == null ? void 0 : state.key, phase, newFn);
        }
        if (newFn !== fn) {
          newFn.toString = () => fn.toString();
        }
        return newFn;
      });
      newVisitor[phase] = fns;
    }
    return newVisitor;
  }
  function ensureEntranceObjects(obj) {
    for (const key of Object.keys(obj)) {
      if (shouldIgnoreKey(key)) continue;
      const fns = obj[key];
      if (typeof fns === "function") {
        obj[key] = {
          enter: fns
        };
      }
    }
  }
  function ensureCallbackArrays(obj) {
    if (obj.enter && !Array.isArray(obj.enter)) obj.enter = [obj.enter];
    if (obj.exit && !Array.isArray(obj.exit)) obj.exit = [obj.exit];
  }
  function wrapCheck(nodeType, fn) {
    const fnKey = `is${nodeType}`;
    const validator = virtualTypesValidators[fnKey];
    const newFn = function(path2) {
      if (validator.call(path2)) {
        return fn.apply(this, arguments);
      }
    };
    newFn.toString = () => fn.toString();
    return newFn;
  }
  function shouldIgnoreKey(key) {
    if (key[0] === "_") return true;
    if (key === "enter" || key === "exit" || key === "shouldSkip") return true;
    if (key === "denylist" || key === "noScope" || key === "skipKeys") {
      return true;
    }
    {
      if (key === "blacklist") {
        return true;
      }
    }
    return false;
  }
  function mergePair(dest, src2) {
    for (const phase of ["enter", "exit"]) {
      if (!src2[phase]) continue;
      dest[phase] = [].concat(dest[phase] || [], src2[phase]);
    }
  }
  const _environmentVisitor = {
    FunctionParent(path2) {
      if (path2.isArrowFunctionExpression()) return;
      path2.skip();
      if (path2.isMethod()) {
        if (!path2.requeueComputedKeyAndDecorators) {
          _context.requeueComputedKeyAndDecorators.call(path2);
        } else {
          path2.requeueComputedKeyAndDecorators();
        }
      }
    },
    Property(path2) {
      if (path2.isObjectProperty()) return;
      path2.skip();
      if (!path2.requeueComputedKeyAndDecorators) {
        _context.requeueComputedKeyAndDecorators.call(path2);
      } else {
        path2.requeueComputedKeyAndDecorators();
      }
    }
  };
  function environmentVisitor(visitor) {
    return merge([_environmentVisitor, visitor]);
  }
  return visitors;
}
var hasRequiredRenamer;
function requireRenamer() {
  if (hasRequiredRenamer) return renamer;
  hasRequiredRenamer = 1;
  Object.defineProperty(renamer, "__esModule", {
    value: true
  });
  renamer.default = void 0;
  var t = requireLib$4();
  var _t = t;
  var _traverseNode = requireTraverseNode();
  var _visitors = requireVisitors();
  var _context = requireContext();
  const {
    getAssignmentIdentifiers: getAssignmentIdentifiers2
  } = _t;
  const renameVisitor = {
    ReferencedIdentifier({
      node: node2
    }, state) {
      if (node2.name === state.oldName) {
        node2.name = state.newName;
      }
    },
    Scope(path2, state) {
      if (!path2.scope.bindingIdentifierEquals(state.oldName, state.binding.identifier)) {
        path2.skip();
        if (path2.isMethod()) {
          if (!path2.requeueComputedKeyAndDecorators) {
            _context.requeueComputedKeyAndDecorators.call(path2);
          } else {
            path2.requeueComputedKeyAndDecorators();
          }
        }
      }
    },
    ObjectProperty({
      node: node2,
      scope: scope2
    }, state) {
      const {
        name
      } = node2.key;
      if (node2.shorthand && (name === state.oldName || name === state.newName) && scope2.getBindingIdentifier(name) === state.binding.identifier) {
        node2.shorthand = false;
        {
          var _node$extra;
          if ((_node$extra = node2.extra) != null && _node$extra.shorthand) node2.extra.shorthand = false;
        }
      }
    },
    "AssignmentExpression|Declaration|VariableDeclarator"(path2, state) {
      if (path2.isVariableDeclaration()) return;
      const ids = path2.isAssignmentExpression() ? getAssignmentIdentifiers2(path2.node) : path2.getOuterBindingIdentifiers();
      for (const name in ids) {
        if (name === state.oldName) ids[name].name = state.newName;
      }
    }
  };
  class Renamer {
    constructor(binding2, oldName, newName) {
      this.newName = newName;
      this.oldName = oldName;
      this.binding = binding2;
    }
    maybeConvertFromExportDeclaration(parentDeclar) {
      const maybeExportDeclar = parentDeclar.parentPath;
      if (!maybeExportDeclar.isExportDeclaration()) {
        return;
      }
      if (maybeExportDeclar.isExportDefaultDeclaration()) {
        const {
          declaration
        } = maybeExportDeclar.node;
        if (t.isDeclaration(declaration) && !declaration.id) {
          return;
        }
      }
      if (maybeExportDeclar.isExportAllDeclaration()) {
        return;
      }
      maybeExportDeclar.splitExportDeclaration();
    }
    maybeConvertFromClassFunctionDeclaration(path2) {
      return path2;
    }
    maybeConvertFromClassFunctionExpression(path2) {
      return path2;
    }
    rename() {
      const {
        binding: binding2,
        oldName,
        newName
      } = this;
      const {
        scope: scope2,
        path: path2
      } = binding2;
      const parentDeclar = path2.find((path3) => path3.isDeclaration() || path3.isFunctionExpression() || path3.isClassExpression());
      if (parentDeclar) {
        const bindingIds = parentDeclar.getOuterBindingIdentifiers();
        if (bindingIds[oldName] === binding2.identifier) {
          this.maybeConvertFromExportDeclaration(parentDeclar);
        }
      }
      const blockToTraverse = arguments[0] || scope2.block;
      const skipKeys = {
        discriminant: true
      };
      if (t.isMethod(blockToTraverse)) {
        if (blockToTraverse.computed) {
          skipKeys.key = true;
        }
        if (!t.isObjectMethod(blockToTraverse)) {
          skipKeys.decorators = true;
        }
      }
      (0, _traverseNode.traverseNode)(blockToTraverse, (0, _visitors.explode)(renameVisitor), scope2, this, scope2.path, skipKeys);
      if (!arguments[0]) {
        scope2.removeOwnBinding(oldName);
        scope2.bindings[newName] = binding2;
        this.binding.identifier.name = newName;
      }
      if (parentDeclar) {
        this.maybeConvertFromClassFunctionDeclaration(path2);
        this.maybeConvertFromClassFunctionExpression(path2);
      }
    }
  }
  renamer.default = Renamer;
  return renamer;
}
var traverseForScope = {};
var hasRequiredTraverseForScope;
function requireTraverseForScope() {
  if (hasRequiredTraverseForScope) return traverseForScope;
  hasRequiredTraverseForScope = 1;
  Object.defineProperty(traverseForScope, "__esModule", {
    value: true
  });
  traverseForScope.default = traverseForScope$1;
  var _t = requireLib$4();
  var _index = requireLib();
  var _visitors = requireVisitors();
  var _context = requireContext();
  const {
    VISITOR_KEYS
  } = _t;
  function traverseForScope$1(path2, visitors2, state) {
    const exploded = (0, _visitors.explode)(visitors2);
    if (exploded.enter || exploded.exit) {
      throw new Error("Should not be used with enter/exit visitors.");
    }
    _traverse(path2.parentPath, path2.parent, path2.node, path2.container, path2.key, path2.listKey, path2.hub, path2);
    function _traverse(parentPath, parent, node2, container, key, listKey, hub2, inPath) {
      if (!node2) {
        return;
      }
      const path3 = inPath || _index.NodePath.get({
        hub: hub2,
        parentPath,
        parent,
        container,
        listKey,
        key
      });
      _context.setScope.call(path3);
      const visitor = exploded[node2.type];
      if (visitor) {
        if (visitor.enter) {
          for (const visit of visitor.enter) {
            visit.call(state, path3, state);
          }
        }
        if (visitor.exit) {
          for (const visit of visitor.exit) {
            visit.call(state, path3, state);
          }
        }
      }
      if (path3.shouldSkip) {
        return;
      }
      const keys = VISITOR_KEYS[node2.type];
      if (!(keys != null && keys.length)) {
        return;
      }
      for (const key2 of keys) {
        const prop = node2[key2];
        if (!prop) continue;
        if (Array.isArray(prop)) {
          for (let i = 0; i < prop.length; i++) {
            const value = prop[i];
            _traverse(path3, node2, value, prop, i, key2);
          }
        } else {
          _traverse(path3, node2, prop, node2, key2, null);
        }
      }
    }
  }
  return traverseForScope;
}
var binding = {};
var hasRequiredBinding;
function requireBinding() {
  if (hasRequiredBinding) return binding;
  hasRequiredBinding = 1;
  Object.defineProperty(binding, "__esModule", {
    value: true
  });
  binding.default = void 0;
  class Binding {
    constructor({
      identifier: identifier2,
      scope: scope2,
      path: path2,
      kind
    }) {
      this.identifier = void 0;
      this.scope = void 0;
      this.path = void 0;
      this.kind = void 0;
      this.constantViolations = [];
      this.constant = true;
      this.referencePaths = [];
      this.referenced = false;
      this.references = 0;
      this.identifier = identifier2;
      this.scope = scope2;
      this.path = path2;
      this.kind = kind;
      if ((kind === "var" || kind === "hoisted") && isInitInLoop(path2)) {
        this.reassign(path2);
      }
      this.clearValue();
    }
    deoptValue() {
      this.clearValue();
      this.hasDeoptedValue = true;
    }
    setValue(value) {
      if (this.hasDeoptedValue) return;
      this.hasValue = true;
      this.value = value;
    }
    clearValue() {
      this.hasDeoptedValue = false;
      this.hasValue = false;
      this.value = null;
    }
    reassign(path2) {
      this.constant = false;
      if (this.constantViolations.includes(path2)) {
        return;
      }
      this.constantViolations.push(path2);
    }
    reference(path2) {
      if (this.referencePaths.includes(path2)) {
        return;
      }
      this.referenced = true;
      this.references++;
      this.referencePaths.push(path2);
    }
    dereference() {
      this.references--;
      this.referenced = !!this.references;
    }
  }
  binding.default = Binding;
  function isInitInLoop(path2) {
    const isFunctionDeclarationOrHasInit = !path2.isVariableDeclarator() || path2.node.init;
    for (let {
      parentPath,
      key
    } = path2; parentPath; {
      parentPath,
      key
    } = parentPath) {
      if (parentPath.isFunctionParent()) return false;
      if (key === "left" && parentPath.isForXStatement() || isFunctionDeclarationOrHasInit && key === "body" && parentPath.isLoop()) {
        return true;
      }
    }
    return false;
  }
  return binding;
}
var cache = {};
var hasRequiredCache;
function requireCache() {
  if (hasRequiredCache) return cache;
  hasRequiredCache = 1;
  Object.defineProperty(cache, "__esModule", {
    value: true
  });
  cache.clear = clear;
  cache.clearPath = clearPath;
  cache.clearScope = clearScope;
  cache.getCachedPaths = getCachedPaths;
  cache.getOrCreateCachedPaths = getOrCreateCachedPaths;
  cache.scope = cache.path = void 0;
  let pathsCache = cache.path = /* @__PURE__ */ new WeakMap();
  cache.scope = /* @__PURE__ */ new WeakMap();
  function clear() {
    clearPath();
    clearScope();
  }
  function clearPath() {
    cache.path = pathsCache = /* @__PURE__ */ new WeakMap();
  }
  function clearScope() {
    cache.scope = /* @__PURE__ */ new WeakMap();
  }
  function getCachedPaths(path2) {
    const {
      parent,
      parentPath
    } = path2;
    return pathsCache.get(parent);
  }
  function getOrCreateCachedPaths(node2, parentPath) {
    let paths = pathsCache.get(node2);
    if (!paths) pathsCache.set(node2, paths = /* @__PURE__ */ new Map());
    return paths;
  }
  return cache;
}
const require$$6 = [
  "decodeURI",
  "decodeURIComponent",
  "encodeURI",
  "encodeURIComponent",
  "escape",
  "eval",
  "globalThis",
  "isFinite",
  "isNaN",
  "parseFloat",
  "parseInt",
  "undefined",
  "unescape"
];
const require$$7 = [
  "AggregateError",
  "Array",
  "ArrayBuffer",
  "Atomics",
  "BigInt",
  "BigInt64Array",
  "BigUint64Array",
  "Boolean",
  "DataView",
  "Date",
  "Error",
  "EvalError",
  "FinalizationRegistry",
  "Float16Array",
  "Float32Array",
  "Float64Array",
  "Function",
  "Infinity",
  "Int16Array",
  "Int32Array",
  "Int8Array",
  "Intl",
  "Iterator",
  "JSON",
  "Map",
  "Math",
  "NaN",
  "Number",
  "Object",
  "Promise",
  "Proxy",
  "RangeError",
  "ReferenceError",
  "Reflect",
  "RegExp",
  "Set",
  "SharedArrayBuffer",
  "String",
  "Symbol",
  "SyntaxError",
  "TypeError",
  "Uint16Array",
  "Uint32Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "URIError",
  "WeakMap",
  "WeakRef",
  "WeakSet"
];
var hasRequiredScope;
function requireScope() {
  if (hasRequiredScope) return scope;
  hasRequiredScope = 1;
  Object.defineProperty(scope, "__esModule", {
    value: true
  });
  scope.default = void 0;
  var _renamer = requireRenamer();
  var _index = requireLib();
  requireTraverseForScope();
  var _binding = requireBinding();
  var _t = requireLib$4();
  var t = _t;
  var _cache = requireCache();
  const globalsBuiltinLower = require$$6, globalsBuiltinUpper = require$$7;
  const {
    assignmentExpression,
    callExpression,
    cloneNode: cloneNode2,
    getBindingIdentifiers: getBindingIdentifiers2,
    identifier: identifier2,
    isArrayExpression,
    isBinary,
    isCallExpression,
    isClass,
    isClassBody,
    isClassDeclaration,
    isExportAllDeclaration,
    isExportDefaultDeclaration,
    isExportNamedDeclaration,
    isFunctionDeclaration,
    isIdentifier,
    isImportDeclaration,
    isLiteral,
    isMemberExpression,
    isMethod,
    isModuleSpecifier,
    isNullLiteral,
    isObjectExpression,
    isProperty,
    isPureish,
    isRegExpLiteral,
    isSuper,
    isTaggedTemplateExpression,
    isTemplateLiteral,
    isThisExpression,
    isUnaryExpression,
    isVariableDeclaration,
    expressionStatement,
    matchesPattern: matchesPattern2,
    memberExpression,
    numericLiteral,
    toIdentifier: toIdentifier2,
    variableDeclaration,
    variableDeclarator,
    isRecordExpression,
    isTupleExpression,
    isObjectProperty,
    isTopicReference,
    isMetaProperty,
    isPrivateName,
    isExportDeclaration,
    buildUndefinedNode,
    sequenceExpression
  } = _t;
  function gatherNodeParts(node2, parts) {
    switch (node2 == null ? void 0 : node2.type) {
      default:
        if (isImportDeclaration(node2) || isExportDeclaration(node2)) {
          var _node$specifiers;
          if ((isExportAllDeclaration(node2) || isExportNamedDeclaration(node2) || isImportDeclaration(node2)) && node2.source) {
            gatherNodeParts(node2.source, parts);
          } else if ((isExportNamedDeclaration(node2) || isImportDeclaration(node2)) && (_node$specifiers = node2.specifiers) != null && _node$specifiers.length) {
            for (const e of node2.specifiers) gatherNodeParts(e, parts);
          } else if ((isExportDefaultDeclaration(node2) || isExportNamedDeclaration(node2)) && node2.declaration) {
            gatherNodeParts(node2.declaration, parts);
          }
        } else if (isModuleSpecifier(node2)) {
          gatherNodeParts(node2.local, parts);
        } else if (isLiteral(node2) && !isNullLiteral(node2) && !isRegExpLiteral(node2) && !isTemplateLiteral(node2)) {
          parts.push(node2.value);
        }
        break;
      case "MemberExpression":
      case "OptionalMemberExpression":
      case "JSXMemberExpression":
        gatherNodeParts(node2.object, parts);
        gatherNodeParts(node2.property, parts);
        break;
      case "Identifier":
      case "JSXIdentifier":
        parts.push(node2.name);
        break;
      case "CallExpression":
      case "OptionalCallExpression":
      case "NewExpression":
        gatherNodeParts(node2.callee, parts);
        break;
      case "ObjectExpression":
      case "ObjectPattern":
        for (const e of node2.properties) {
          gatherNodeParts(e, parts);
        }
        break;
      case "SpreadElement":
      case "RestElement":
        gatherNodeParts(node2.argument, parts);
        break;
      case "ObjectProperty":
      case "ObjectMethod":
      case "ClassProperty":
      case "ClassMethod":
      case "ClassPrivateProperty":
      case "ClassPrivateMethod":
        gatherNodeParts(node2.key, parts);
        break;
      case "ThisExpression":
        parts.push("this");
        break;
      case "Super":
        parts.push("super");
        break;
      case "Import":
      case "ImportExpression":
        parts.push("import");
        break;
      case "DoExpression":
        parts.push("do");
        break;
      case "YieldExpression":
        parts.push("yield");
        gatherNodeParts(node2.argument, parts);
        break;
      case "AwaitExpression":
        parts.push("await");
        gatherNodeParts(node2.argument, parts);
        break;
      case "AssignmentExpression":
        gatherNodeParts(node2.left, parts);
        break;
      case "VariableDeclarator":
        gatherNodeParts(node2.id, parts);
        break;
      case "FunctionExpression":
      case "FunctionDeclaration":
      case "ClassExpression":
      case "ClassDeclaration":
        gatherNodeParts(node2.id, parts);
        break;
      case "PrivateName":
        gatherNodeParts(node2.id, parts);
        break;
      case "ParenthesizedExpression":
        gatherNodeParts(node2.expression, parts);
        break;
      case "UnaryExpression":
      case "UpdateExpression":
        gatherNodeParts(node2.argument, parts);
        break;
      case "MetaProperty":
        gatherNodeParts(node2.meta, parts);
        gatherNodeParts(node2.property, parts);
        break;
      case "JSXElement":
        gatherNodeParts(node2.openingElement, parts);
        break;
      case "JSXOpeningElement":
        gatherNodeParts(node2.name, parts);
        break;
      case "JSXFragment":
        gatherNodeParts(node2.openingFragment, parts);
        break;
      case "JSXOpeningFragment":
        parts.push("Fragment");
        break;
      case "JSXNamespacedName":
        gatherNodeParts(node2.namespace, parts);
        gatherNodeParts(node2.name, parts);
        break;
    }
  }
  function resetScope(scope2) {
    {
      scope2.references = /* @__PURE__ */ Object.create(null);
      scope2.uids = /* @__PURE__ */ Object.create(null);
    }
    scope2.bindings = /* @__PURE__ */ Object.create(null);
    scope2.globals = /* @__PURE__ */ Object.create(null);
  }
  function isAnonymousFunctionExpression(path2) {
    return path2.isFunctionExpression() && !path2.node.id || path2.isArrowFunctionExpression();
  }
  {
    var NOT_LOCAL_BINDING = /* @__PURE__ */ Symbol.for("should not be considered a local binding");
  }
  const collectorVisitor = {
    ForStatement(path2) {
      const declar = path2.get("init");
      if (declar.isVar()) {
        const {
          scope: scope2
        } = path2;
        const parentScope = scope2.getFunctionParent() || scope2.getProgramParent();
        parentScope.registerBinding("var", declar);
      }
    },
    Declaration(path2) {
      if (path2.isBlockScoped()) return;
      if (path2.isImportDeclaration()) return;
      if (path2.isExportDeclaration()) return;
      const parent = path2.scope.getFunctionParent() || path2.scope.getProgramParent();
      parent.registerDeclaration(path2);
    },
    ImportDeclaration(path2) {
      const parent = path2.scope.getBlockParent();
      parent.registerDeclaration(path2);
    },
    TSImportEqualsDeclaration(path2) {
      const parent = path2.scope.getBlockParent();
      parent.registerDeclaration(path2);
    },
    ReferencedIdentifier(path2, state) {
      if (t.isTSQualifiedName(path2.parent) && path2.parent.right === path2.node) {
        return;
      }
      if (path2.parentPath.isTSImportEqualsDeclaration()) return;
      state.references.push(path2);
    },
    ForXStatement(path2, state) {
      const left = path2.get("left");
      if (left.isPattern() || left.isIdentifier()) {
        state.constantViolations.push(path2);
      } else if (left.isVar()) {
        const {
          scope: scope2
        } = path2;
        const parentScope = scope2.getFunctionParent() || scope2.getProgramParent();
        parentScope.registerBinding("var", left);
      }
    },
    ExportDeclaration: {
      exit(path2) {
        const {
          node: node2,
          scope: scope2
        } = path2;
        if (isExportAllDeclaration(node2)) return;
        const declar = node2.declaration;
        if (isClassDeclaration(declar) || isFunctionDeclaration(declar)) {
          const id = declar.id;
          if (!id) return;
          const binding2 = scope2.getBinding(id.name);
          binding2 == null || binding2.reference(path2);
        } else if (isVariableDeclaration(declar)) {
          for (const decl of declar.declarations) {
            for (const name of Object.keys(getBindingIdentifiers2(decl))) {
              const binding2 = scope2.getBinding(name);
              binding2 == null || binding2.reference(path2);
            }
          }
        }
      }
    },
    LabeledStatement(path2) {
      path2.scope.getBlockParent().registerDeclaration(path2);
    },
    AssignmentExpression(path2, state) {
      state.assignments.push(path2);
    },
    UpdateExpression(path2, state) {
      state.constantViolations.push(path2);
    },
    UnaryExpression(path2, state) {
      if (path2.node.operator === "delete") {
        state.constantViolations.push(path2);
      }
    },
    BlockScoped(path2) {
      let scope2 = path2.scope;
      if (scope2.path === path2) scope2 = scope2.parent;
      const parent = scope2.getBlockParent();
      parent.registerDeclaration(path2);
      if (path2.isClassDeclaration() && path2.node.id) {
        const id = path2.node.id;
        const name = id.name;
        path2.scope.bindings[name] = path2.scope.parent.getBinding(name);
      }
    },
    CatchClause(path2) {
      path2.scope.registerBinding("let", path2);
    },
    Function(path2) {
      const params = path2.get("params");
      for (const param of params) {
        path2.scope.registerBinding("param", param);
      }
      if (path2.isFunctionExpression() && path2.node.id && !path2.node.id[NOT_LOCAL_BINDING]) {
        path2.scope.registerBinding("local", path2.get("id"), path2);
      }
    },
    ClassExpression(path2) {
      if (path2.node.id && !path2.node.id[NOT_LOCAL_BINDING]) {
        path2.scope.registerBinding("local", path2.get("id"), path2);
      }
    },
    TSTypeAnnotation(path2) {
      path2.skip();
    }
  };
  let scopeVisitor;
  let uid = 0;
  class Scope {
    constructor(path2) {
      this.uid = void 0;
      this.path = void 0;
      this.block = void 0;
      this.inited = void 0;
      this.labels = void 0;
      this.bindings = void 0;
      this.referencesSet = void 0;
      this.globals = void 0;
      this.uidsSet = void 0;
      this.data = void 0;
      this.crawling = void 0;
      const {
        node: node2
      } = path2;
      const cached = _cache.scope.get(node2);
      if ((cached == null ? void 0 : cached.path) === path2) {
        return cached;
      }
      _cache.scope.set(node2, this);
      this.uid = uid++;
      this.block = node2;
      this.path = path2;
      this.labels = /* @__PURE__ */ new Map();
      this.inited = false;
      {
        Object.defineProperties(this, {
          references: {
            enumerable: true,
            configurable: true,
            writable: true,
            value: /* @__PURE__ */ Object.create(null)
          },
          uids: {
            enumerable: true,
            configurable: true,
            writable: true,
            value: /* @__PURE__ */ Object.create(null)
          }
        });
      }
    }
    get parent() {
      var _parent;
      let parent, path2 = this.path;
      do {
        var _path;
        const shouldSkip = path2.key === "key" || path2.listKey === "decorators";
        path2 = path2.parentPath;
        if (shouldSkip && path2.isMethod()) path2 = path2.parentPath;
        if ((_path = path2) != null && _path.isScope()) parent = path2;
      } while (path2 && !parent);
      return (_parent = parent) == null ? void 0 : _parent.scope;
    }
    get references() {
      throw new Error("Scope#references is not available in Babel 8. Use Scope#referencesSet instead.");
    }
    get uids() {
      throw new Error("Scope#uids is not available in Babel 8. Use Scope#uidsSet instead.");
    }
    generateDeclaredUidIdentifier(name) {
      const id = this.generateUidIdentifier(name);
      this.push({
        id
      });
      return cloneNode2(id);
    }
    generateUidIdentifier(name) {
      return identifier2(this.generateUid(name));
    }
    generateUid(name = "temp") {
      name = toIdentifier2(name).replace(/^_+/, "").replace(/\d+$/g, "");
      let uid2;
      let i = 0;
      do {
        uid2 = `_${name}`;
        if (i >= 11) uid2 += i - 1;
        else if (i >= 9) uid2 += i - 9;
        else if (i >= 1) uid2 += i + 1;
        i++;
      } while (this.hasLabel(uid2) || this.hasBinding(uid2) || this.hasGlobal(uid2) || this.hasReference(uid2));
      const program = this.getProgramParent();
      {
        program.references[uid2] = true;
        program.uids[uid2] = true;
      }
      return uid2;
    }
    generateUidBasedOnNode(node2, defaultName) {
      const parts = [];
      gatherNodeParts(node2, parts);
      let id = parts.join("$");
      id = id.replace(/^_/, "") || defaultName || "ref";
      return this.generateUid(id.slice(0, 20));
    }
    generateUidIdentifierBasedOnNode(node2, defaultName) {
      return identifier2(this.generateUidBasedOnNode(node2, defaultName));
    }
    isStatic(node2) {
      if (isThisExpression(node2) || isSuper(node2) || isTopicReference(node2)) {
        return true;
      }
      if (isIdentifier(node2)) {
        const binding2 = this.getBinding(node2.name);
        if (binding2) {
          return binding2.constant;
        } else {
          return this.hasBinding(node2.name);
        }
      }
      return false;
    }
    maybeGenerateMemoised(node2, dontPush) {
      if (this.isStatic(node2)) {
        return null;
      } else {
        const id = this.generateUidIdentifierBasedOnNode(node2);
        if (!dontPush) {
          this.push({
            id
          });
          return cloneNode2(id);
        }
        return id;
      }
    }
    checkBlockScopedCollisions(local, kind, name, id) {
      if (kind === "param") return;
      if (local.kind === "local") return;
      const duplicate = kind === "let" || local.kind === "let" || local.kind === "const" || local.kind === "module" || local.kind === "param" && kind === "const";
      if (duplicate) {
        throw this.path.hub.buildError(id, `Duplicate declaration "${name}"`, TypeError);
      }
    }
    rename(oldName, newName) {
      const binding2 = this.getBinding(oldName);
      if (binding2) {
        newName || (newName = this.generateUidIdentifier(oldName).name);
        const renamer2 = new _renamer.default(binding2, oldName, newName);
        {
          renamer2.rename(arguments[2]);
        }
      }
    }
    dump() {
      const sep = "-".repeat(60);
      console.log(sep);
      let scope2 = this;
      do {
        console.log("#", scope2.block.type);
        for (const name of Object.keys(scope2.bindings)) {
          const binding2 = scope2.bindings[name];
          console.log(" -", name, {
            constant: binding2.constant,
            references: binding2.references,
            violations: binding2.constantViolations.length,
            kind: binding2.kind
          });
        }
      } while (scope2 = scope2.parent);
      console.log(sep);
    }
    hasLabel(name) {
      return !!this.getLabel(name);
    }
    getLabel(name) {
      return this.labels.get(name);
    }
    registerLabel(path2) {
      this.labels.set(path2.node.label.name, path2);
    }
    registerDeclaration(path2) {
      if (path2.isLabeledStatement()) {
        this.registerLabel(path2);
      } else if (path2.isFunctionDeclaration()) {
        this.registerBinding("hoisted", path2.get("id"), path2);
      } else if (path2.isVariableDeclaration()) {
        const declarations = path2.get("declarations");
        const {
          kind
        } = path2.node;
        for (const declar of declarations) {
          this.registerBinding(kind === "using" || kind === "await using" ? "const" : kind, declar);
        }
      } else if (path2.isClassDeclaration()) {
        if (path2.node.declare) return;
        this.registerBinding("let", path2);
      } else if (path2.isImportDeclaration()) {
        const isTypeDeclaration = path2.node.importKind === "type" || path2.node.importKind === "typeof";
        const specifiers = path2.get("specifiers");
        for (const specifier of specifiers) {
          const isTypeSpecifier = isTypeDeclaration || specifier.isImportSpecifier() && (specifier.node.importKind === "type" || specifier.node.importKind === "typeof");
          this.registerBinding(isTypeSpecifier ? "unknown" : "module", specifier);
        }
      } else if (path2.isExportDeclaration()) {
        const declar = path2.get("declaration");
        if (declar.isClassDeclaration() || declar.isFunctionDeclaration() || declar.isVariableDeclaration()) {
          this.registerDeclaration(declar);
        }
      } else {
        this.registerBinding("unknown", path2);
      }
    }
    buildUndefinedNode() {
      return buildUndefinedNode();
    }
    registerConstantViolation(path2) {
      const ids = path2.getAssignmentIdentifiers();
      for (const name of Object.keys(ids)) {
        var _this$getBinding;
        (_this$getBinding = this.getBinding(name)) == null || _this$getBinding.reassign(path2);
      }
    }
    registerBinding(kind, path2, bindingPath = path2) {
      if (!kind) throw new ReferenceError("no `kind`");
      if (path2.isVariableDeclaration()) {
        const declarators = path2.get("declarations");
        for (const declar of declarators) {
          this.registerBinding(kind, declar);
        }
        return;
      }
      const parent = this.getProgramParent();
      const ids = path2.getOuterBindingIdentifiers(true);
      for (const name of Object.keys(ids)) {
        {
          parent.references[name] = true;
        }
        for (const id of ids[name]) {
          const local = this.getOwnBinding(name);
          if (local) {
            if (local.identifier === id) continue;
            this.checkBlockScopedCollisions(local, kind, name, id);
          }
          if (local) {
            local.reassign(bindingPath);
          } else {
            this.bindings[name] = new _binding.default({
              identifier: id,
              scope: this,
              path: bindingPath,
              kind
            });
          }
        }
      }
    }
    addGlobal(node2) {
      this.globals[node2.name] = node2;
    }
    hasUid(name) {
      {
        let scope2 = this;
        do {
          if (scope2.uids[name]) return true;
        } while (scope2 = scope2.parent);
        return false;
      }
    }
    hasGlobal(name) {
      let scope2 = this;
      do {
        if (scope2.globals[name]) return true;
      } while (scope2 = scope2.parent);
      return false;
    }
    hasReference(name) {
      {
        return !!this.getProgramParent().references[name];
      }
    }
    isPure(node2, constantsOnly) {
      if (isIdentifier(node2)) {
        const binding2 = this.getBinding(node2.name);
        if (!binding2) return false;
        if (constantsOnly) return binding2.constant;
        return true;
      } else if (isThisExpression(node2) || isMetaProperty(node2) || isTopicReference(node2) || isPrivateName(node2)) {
        return true;
      } else if (isClass(node2)) {
        var _node$decorators;
        if (node2.superClass && !this.isPure(node2.superClass, constantsOnly)) {
          return false;
        }
        if (((_node$decorators = node2.decorators) == null ? void 0 : _node$decorators.length) > 0) {
          return false;
        }
        return this.isPure(node2.body, constantsOnly);
      } else if (isClassBody(node2)) {
        for (const method of node2.body) {
          if (!this.isPure(method, constantsOnly)) return false;
        }
        return true;
      } else if (isBinary(node2)) {
        return this.isPure(node2.left, constantsOnly) && this.isPure(node2.right, constantsOnly);
      } else if (isArrayExpression(node2) || isTupleExpression(node2)) {
        for (const elem of node2.elements) {
          if (elem !== null && !this.isPure(elem, constantsOnly)) return false;
        }
        return true;
      } else if (isObjectExpression(node2) || isRecordExpression(node2)) {
        for (const prop of node2.properties) {
          if (!this.isPure(prop, constantsOnly)) return false;
        }
        return true;
      } else if (isMethod(node2)) {
        var _node$decorators2;
        if (node2.computed && !this.isPure(node2.key, constantsOnly)) return false;
        if (((_node$decorators2 = node2.decorators) == null ? void 0 : _node$decorators2.length) > 0) {
          return false;
        }
        return true;
      } else if (isProperty(node2)) {
        var _node$decorators3;
        if (node2.computed && !this.isPure(node2.key, constantsOnly)) return false;
        if (((_node$decorators3 = node2.decorators) == null ? void 0 : _node$decorators3.length) > 0) {
          return false;
        }
        if (isObjectProperty(node2) || node2.static) {
          if (node2.value !== null && !this.isPure(node2.value, constantsOnly)) {
            return false;
          }
        }
        return true;
      } else if (isUnaryExpression(node2)) {
        return this.isPure(node2.argument, constantsOnly);
      } else if (isTemplateLiteral(node2)) {
        for (const expression of node2.expressions) {
          if (!this.isPure(expression, constantsOnly)) return false;
        }
        return true;
      } else if (isTaggedTemplateExpression(node2)) {
        return matchesPattern2(node2.tag, "String.raw") && !this.hasBinding("String", {
          noGlobals: true
        }) && this.isPure(node2.quasi, constantsOnly);
      } else if (isMemberExpression(node2)) {
        return !node2.computed && isIdentifier(node2.object) && node2.object.name === "Symbol" && isIdentifier(node2.property) && node2.property.name !== "for" && !this.hasBinding("Symbol", {
          noGlobals: true
        });
      } else if (isCallExpression(node2)) {
        return matchesPattern2(node2.callee, "Symbol.for") && !this.hasBinding("Symbol", {
          noGlobals: true
        }) && node2.arguments.length === 1 && t.isStringLiteral(node2.arguments[0]);
      } else {
        return isPureish(node2);
      }
    }
    setData(key, val) {
      return this.data[key] = val;
    }
    getData(key) {
      let scope2 = this;
      do {
        const data = scope2.data[key];
        if (data != null) return data;
      } while (scope2 = scope2.parent);
    }
    removeData(key) {
      let scope2 = this;
      do {
        const data = scope2.data[key];
        if (data != null) scope2.data[key] = null;
      } while (scope2 = scope2.parent);
    }
    init() {
      if (!this.inited) {
        this.inited = true;
        this.crawl();
      }
    }
    crawl() {
      const path2 = this.path;
      resetScope(this);
      this.data = /* @__PURE__ */ Object.create(null);
      let scope2 = this;
      do {
        if (scope2.crawling) return;
        if (scope2.path.isProgram()) {
          break;
        }
      } while (scope2 = scope2.parent);
      const programParent = scope2;
      const state = {
        references: [],
        constantViolations: [],
        assignments: []
      };
      this.crawling = true;
      scopeVisitor || (scopeVisitor = _index.default.visitors.merge([{
        Scope(path3) {
          resetScope(path3.scope);
        }
      }, collectorVisitor]));
      if (path2.type !== "Program") {
        const typeVisitors = scopeVisitor[path2.type];
        if (typeVisitors) {
          for (const visit of typeVisitors.enter) {
            visit.call(state, path2, state);
          }
        }
      }
      {
        path2.traverse(scopeVisitor, state);
      }
      this.crawling = false;
      for (const path3 of state.assignments) {
        const ids = path3.getAssignmentIdentifiers();
        for (const name of Object.keys(ids)) {
          if (path3.scope.getBinding(name)) continue;
          programParent.addGlobal(ids[name]);
        }
        path3.scope.registerConstantViolation(path3);
      }
      for (const ref of state.references) {
        const binding2 = ref.scope.getBinding(ref.node.name);
        if (binding2) {
          binding2.reference(ref);
        } else {
          programParent.addGlobal(ref.node);
        }
      }
      for (const path3 of state.constantViolations) {
        path3.scope.registerConstantViolation(path3);
      }
    }
    push(opts) {
      let path2 = this.path;
      if (path2.isPattern()) {
        path2 = this.getPatternParent().path;
      } else if (!path2.isBlockStatement() && !path2.isProgram()) {
        path2 = this.getBlockParent().path;
      }
      if (path2.isSwitchStatement()) {
        path2 = (this.getFunctionParent() || this.getProgramParent()).path;
      }
      const {
        init,
        unique,
        kind = "var",
        id
      } = opts;
      if (!init && !unique && (kind === "var" || kind === "let") && isAnonymousFunctionExpression(path2) && isCallExpression(path2.parent, {
        callee: path2.node
      }) && path2.parent.arguments.length <= path2.node.params.length && isIdentifier(id)) {
        path2.pushContainer("params", id);
        path2.scope.registerBinding("param", path2.get("params")[path2.node.params.length - 1]);
        return;
      }
      if (path2.isLoop() || path2.isCatchClause() || path2.isFunction()) {
        path2.ensureBlock();
        path2 = path2.get("body");
      }
      const blockHoist = opts._blockHoist == null ? 2 : opts._blockHoist;
      const dataKey = `declaration:${kind}:${blockHoist}`;
      let declarPath = !unique && path2.getData(dataKey);
      if (!declarPath) {
        const declar = variableDeclaration(kind, []);
        declar._blockHoist = blockHoist;
        [declarPath] = path2.unshiftContainer("body", [declar]);
        if (!unique) path2.setData(dataKey, declarPath);
      }
      const declarator = variableDeclarator(id, init);
      const len = declarPath.node.declarations.push(declarator);
      path2.scope.registerBinding(kind, declarPath.get("declarations")[len - 1]);
    }
    getProgramParent() {
      let scope2 = this;
      do {
        if (scope2.path.isProgram()) {
          return scope2;
        }
      } while (scope2 = scope2.parent);
      throw new Error("Couldn't find a Program");
    }
    getFunctionParent() {
      let scope2 = this;
      do {
        if (scope2.path.isFunctionParent()) {
          return scope2;
        }
      } while (scope2 = scope2.parent);
      return null;
    }
    getBlockParent() {
      let scope2 = this;
      do {
        if (scope2.path.isBlockParent()) {
          return scope2;
        }
      } while (scope2 = scope2.parent);
      throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
    }
    getPatternParent() {
      let scope2 = this;
      do {
        if (!scope2.path.isPattern()) {
          return scope2.getBlockParent();
        }
      } while (scope2 = scope2.parent.parent);
      throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
    }
    getAllBindings() {
      const ids = /* @__PURE__ */ Object.create(null);
      let scope2 = this;
      do {
        for (const key of Object.keys(scope2.bindings)) {
          if (key in ids === false) {
            ids[key] = scope2.bindings[key];
          }
        }
        scope2 = scope2.parent;
      } while (scope2);
      return ids;
    }
    bindingIdentifierEquals(name, node2) {
      return this.getBindingIdentifier(name) === node2;
    }
    getBinding(name) {
      let scope2 = this;
      let previousPath;
      do {
        const binding2 = scope2.getOwnBinding(name);
        if (binding2) {
          var _previousPath;
          if ((_previousPath = previousPath) != null && _previousPath.isPattern() && binding2.kind !== "param" && binding2.kind !== "local") ;
          else {
            return binding2;
          }
        } else if (!binding2 && name === "arguments" && scope2.path.isFunction() && !scope2.path.isArrowFunctionExpression()) {
          break;
        }
        previousPath = scope2.path;
      } while (scope2 = scope2.parent);
    }
    getOwnBinding(name) {
      return this.bindings[name];
    }
    getBindingIdentifier(name) {
      var _this$getBinding2;
      return (_this$getBinding2 = this.getBinding(name)) == null ? void 0 : _this$getBinding2.identifier;
    }
    getOwnBindingIdentifier(name) {
      const binding2 = this.bindings[name];
      return binding2 == null ? void 0 : binding2.identifier;
    }
    hasOwnBinding(name) {
      return !!this.getOwnBinding(name);
    }
    hasBinding(name, opts) {
      if (!name) return false;
      let noGlobals;
      let noUids;
      let upToScope;
      if (typeof opts === "object") {
        noGlobals = opts.noGlobals;
        noUids = opts.noUids;
        upToScope = opts.upToScope;
      } else if (typeof opts === "boolean") {
        noGlobals = opts;
      }
      let scope2 = this;
      do {
        if (upToScope === scope2) {
          break;
        }
        if (scope2.hasOwnBinding(name)) {
          return true;
        }
      } while (scope2 = scope2.parent);
      if (!noUids && this.hasUid(name)) return true;
      if (!noGlobals && Scope.globals.includes(name)) return true;
      if (!noGlobals && Scope.contextVariables.includes(name)) return true;
      return false;
    }
    parentHasBinding(name, opts) {
      var _this$parent;
      return (_this$parent = this.parent) == null ? void 0 : _this$parent.hasBinding(name, opts);
    }
    moveBindingTo(name, scope2) {
      const info = this.getBinding(name);
      if (info) {
        info.scope.removeOwnBinding(name);
        info.scope = scope2;
        scope2.bindings[name] = info;
      }
    }
    removeOwnBinding(name) {
      delete this.bindings[name];
    }
    removeBinding(name) {
      var _this$getBinding3;
      (_this$getBinding3 = this.getBinding(name)) == null || _this$getBinding3.scope.removeOwnBinding(name);
      {
        let scope2 = this;
        do {
          if (scope2.uids[name]) {
            scope2.uids[name] = false;
          }
        } while (scope2 = scope2.parent);
      }
    }
    hoistVariables(emit = (id) => this.push({
      id
    })) {
      this.crawl();
      const seen = /* @__PURE__ */ new Set();
      for (const name of Object.keys(this.bindings)) {
        const binding2 = this.bindings[name];
        if (!binding2) continue;
        const {
          path: path2
        } = binding2;
        if (!path2.isVariableDeclarator()) continue;
        const {
          parent,
          parentPath
        } = path2;
        if (parent.kind !== "var" || seen.has(parent)) continue;
        seen.add(path2.parent);
        let firstId;
        const init = [];
        for (const decl of parent.declarations) {
          firstId != null ? firstId : firstId = decl.id;
          if (decl.init) {
            init.push(assignmentExpression("=", decl.id, decl.init));
          }
          const ids = Object.keys(getBindingIdentifiers2(decl, false, true, true));
          for (const name2 of ids) {
            emit(identifier2(name2), decl.init != null);
          }
        }
        if (parentPath.parentPath.isForXStatement({
          left: parent
        })) {
          parentPath.replaceWith(firstId);
        } else if (init.length === 0) {
          parentPath.remove();
        } else {
          const expr = init.length === 1 ? init[0] : sequenceExpression(init);
          if (parentPath.parentPath.isForStatement({
            init: parent
          })) {
            parentPath.replaceWith(expr);
          } else {
            parentPath.replaceWith(expressionStatement(expr));
          }
        }
      }
    }
  }
  scope.default = Scope;
  Scope.globals = [...globalsBuiltinLower, ...globalsBuiltinUpper];
  Scope.contextVariables = ["arguments", "undefined", "Infinity", "NaN"];
  {
    Scope.prototype._renameFromMap = function _renameFromMap(map, oldName, newName, value) {
      if (map[oldName]) {
        map[newName] = value;
        map[oldName] = null;
      }
    };
    Scope.prototype.traverse = function(node2, opts, state) {
      (0, _index.default)(node2, opts, this, state, this.path);
    };
    Scope.prototype._generateUid = function _generateUid(name, i) {
      let id = name;
      if (i > 1) id += i;
      return `_${id}`;
    };
    Scope.prototype.toArray = function toArray(node2, i, arrayLikeIsIterable) {
      if (isIdentifier(node2)) {
        const binding2 = this.getBinding(node2.name);
        if (binding2 != null && binding2.constant && binding2.path.isGenericType("Array")) {
          return node2;
        }
      }
      if (isArrayExpression(node2)) {
        return node2;
      }
      if (isIdentifier(node2, {
        name: "arguments"
      })) {
        return callExpression(memberExpression(memberExpression(memberExpression(identifier2("Array"), identifier2("prototype")), identifier2("slice")), identifier2("call")), [node2]);
      }
      let helperName;
      const args = [node2];
      if (i === true) {
        helperName = "toConsumableArray";
      } else if (typeof i === "number") {
        args.push(numericLiteral(i));
        helperName = "slicedToArray";
      } else {
        helperName = "toArray";
      }
      if (arrayLikeIsIterable) {
        args.unshift(this.path.hub.addHelper(helperName));
        helperName = "maybeArrayLike";
      }
      return callExpression(this.path.hub.addHelper(helperName), args);
    };
    Scope.prototype.getAllBindingsOfKind = function getAllBindingsOfKind(...kinds) {
      const ids = /* @__PURE__ */ Object.create(null);
      for (const kind of kinds) {
        let scope2 = this;
        do {
          for (const name of Object.keys(scope2.bindings)) {
            const binding2 = scope2.bindings[name];
            if (binding2.kind === kind) ids[name] = binding2;
          }
          scope2 = scope2.parent;
        } while (scope2);
      }
      return ids;
    };
    Object.defineProperties(Scope.prototype, {
      parentBlock: {
        configurable: true,
        enumerable: true,
        get() {
          return this.path.parent;
        }
      },
      hub: {
        configurable: true,
        enumerable: true,
        get() {
          return this.path.hub;
        }
      }
    });
  }
  return scope;
}
var lib$2 = {};
var sourceMap = {};
var genMapping_umd$1 = { exports: {} };
var sourcemapCodec_umd$1 = { exports: {} };
var sourcemapCodec_umd = sourcemapCodec_umd$1.exports;
var hasRequiredSourcemapCodec_umd;
function requireSourcemapCodec_umd() {
  if (hasRequiredSourcemapCodec_umd) return sourcemapCodec_umd$1.exports;
  hasRequiredSourcemapCodec_umd = 1;
  (function(module, exports$1) {
    (function(global2, factory) {
      {
        factory(module);
        module.exports = def(module);
      }
      function def(m) {
        return "default" in m.exports ? m.exports.default : m.exports;
      }
    })(sourcemapCodec_umd, (function(module2) {
      var __defProp = Object.defineProperty;
      var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
      var __getOwnPropNames = Object.getOwnPropertyNames;
      var __hasOwnProp = Object.prototype.hasOwnProperty;
      var __export = (target, all) => {
        for (var name in all)
          __defProp(target, name, { get: all[name], enumerable: true });
      };
      var __copyProps = (to, from, except, desc) => {
        if (from && typeof from === "object" || typeof from === "function") {
          for (let key of __getOwnPropNames(from))
            if (!__hasOwnProp.call(to, key) && key !== except)
              __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
        }
        return to;
      };
      var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
      var sourcemap_codec_exports = {};
      __export(sourcemap_codec_exports, {
        decode: () => decode,
        decodeGeneratedRanges: () => decodeGeneratedRanges,
        decodeOriginalScopes: () => decodeOriginalScopes,
        encode: () => encode,
        encodeGeneratedRanges: () => encodeGeneratedRanges,
        encodeOriginalScopes: () => encodeOriginalScopes
      });
      module2.exports = __toCommonJS(sourcemap_codec_exports);
      var comma = ",".charCodeAt(0);
      var semicolon = ";".charCodeAt(0);
      var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      var intToChar = new Uint8Array(64);
      var charToInt = new Uint8Array(128);
      for (let i = 0; i < chars.length; i++) {
        const c = chars.charCodeAt(i);
        intToChar[i] = c;
        charToInt[c] = i;
      }
      function decodeInteger(reader, relative) {
        let value = 0;
        let shift = 0;
        let integer = 0;
        do {
          const c = reader.next();
          integer = charToInt[c];
          value |= (integer & 31) << shift;
          shift += 5;
        } while (integer & 32);
        const shouldNegate = value & 1;
        value >>>= 1;
        if (shouldNegate) {
          value = -2147483648 | -value;
        }
        return relative + value;
      }
      function encodeInteger(builder2, num, relative) {
        let delta = num - relative;
        delta = delta < 0 ? -delta << 1 | 1 : delta << 1;
        do {
          let clamped = delta & 31;
          delta >>>= 5;
          if (delta > 0) clamped |= 32;
          builder2.write(intToChar[clamped]);
        } while (delta > 0);
        return num;
      }
      function hasMoreVlq(reader, max) {
        if (reader.pos >= max) return false;
        return reader.peek() !== comma;
      }
      var bufLength = 1024 * 16;
      var td = typeof TextDecoder !== "undefined" ? /* @__PURE__ */ new TextDecoder() : typeof Buffer !== "undefined" ? {
        decode(buf) {
          const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);
          return out.toString();
        }
      } : {
        decode(buf) {
          let out = "";
          for (let i = 0; i < buf.length; i++) {
            out += String.fromCharCode(buf[i]);
          }
          return out;
        }
      };
      var StringWriter = class {
        constructor() {
          this.pos = 0;
          this.out = "";
          this.buffer = new Uint8Array(bufLength);
        }
        write(v) {
          const { buffer: buffer2 } = this;
          buffer2[this.pos++] = v;
          if (this.pos === bufLength) {
            this.out += td.decode(buffer2);
            this.pos = 0;
          }
        }
        flush() {
          const { buffer: buffer2, out, pos } = this;
          return pos > 0 ? out + td.decode(buffer2.subarray(0, pos)) : out;
        }
      };
      var StringReader = class {
        constructor(buffer2) {
          this.pos = 0;
          this.buffer = buffer2;
        }
        next() {
          return this.buffer.charCodeAt(this.pos++);
        }
        peek() {
          return this.buffer.charCodeAt(this.pos);
        }
        indexOf(char) {
          const { buffer: buffer2, pos } = this;
          const idx = buffer2.indexOf(char, pos);
          return idx === -1 ? buffer2.length : idx;
        }
      };
      var EMPTY = [];
      function decodeOriginalScopes(input) {
        const { length } = input;
        const reader = new StringReader(input);
        const scopes = [];
        const stack = [];
        let line = 0;
        for (; reader.pos < length; reader.pos++) {
          line = decodeInteger(reader, line);
          const column = decodeInteger(reader, 0);
          if (!hasMoreVlq(reader, length)) {
            const last = stack.pop();
            last[2] = line;
            last[3] = column;
            continue;
          }
          const kind = decodeInteger(reader, 0);
          const fields = decodeInteger(reader, 0);
          const hasName = fields & 1;
          const scope2 = hasName ? [line, column, 0, 0, kind, decodeInteger(reader, 0)] : [line, column, 0, 0, kind];
          let vars = EMPTY;
          if (hasMoreVlq(reader, length)) {
            vars = [];
            do {
              const varsIndex = decodeInteger(reader, 0);
              vars.push(varsIndex);
            } while (hasMoreVlq(reader, length));
          }
          scope2.vars = vars;
          scopes.push(scope2);
          stack.push(scope2);
        }
        return scopes;
      }
      function encodeOriginalScopes(scopes) {
        const writer = new StringWriter();
        for (let i = 0; i < scopes.length; ) {
          i = _encodeOriginalScopes(scopes, i, writer, [0]);
        }
        return writer.flush();
      }
      function _encodeOriginalScopes(scopes, index, writer, state) {
        const scope2 = scopes[index];
        const { 0: startLine, 1: startColumn, 2: endLine, 3: endColumn, 4: kind, vars } = scope2;
        if (index > 0) writer.write(comma);
        state[0] = encodeInteger(writer, startLine, state[0]);
        encodeInteger(writer, startColumn, 0);
        encodeInteger(writer, kind, 0);
        const fields = scope2.length === 6 ? 1 : 0;
        encodeInteger(writer, fields, 0);
        if (scope2.length === 6) encodeInteger(writer, scope2[5], 0);
        for (const v of vars) {
          encodeInteger(writer, v, 0);
        }
        for (index++; index < scopes.length; ) {
          const next = scopes[index];
          const { 0: l, 1: c } = next;
          if (l > endLine || l === endLine && c >= endColumn) {
            break;
          }
          index = _encodeOriginalScopes(scopes, index, writer, state);
        }
        writer.write(comma);
        state[0] = encodeInteger(writer, endLine, state[0]);
        encodeInteger(writer, endColumn, 0);
        return index;
      }
      function decodeGeneratedRanges(input) {
        const { length } = input;
        const reader = new StringReader(input);
        const ranges = [];
        const stack = [];
        let genLine = 0;
        let definitionSourcesIndex = 0;
        let definitionScopeIndex = 0;
        let callsiteSourcesIndex = 0;
        let callsiteLine = 0;
        let callsiteColumn = 0;
        let bindingLine = 0;
        let bindingColumn = 0;
        do {
          const semi = reader.indexOf(";");
          let genColumn = 0;
          for (; reader.pos < semi; reader.pos++) {
            genColumn = decodeInteger(reader, genColumn);
            if (!hasMoreVlq(reader, semi)) {
              const last = stack.pop();
              last[2] = genLine;
              last[3] = genColumn;
              continue;
            }
            const fields = decodeInteger(reader, 0);
            const hasDefinition = fields & 1;
            const hasCallsite = fields & 2;
            const hasScope = fields & 4;
            let callsite = null;
            let bindings = EMPTY;
            let range;
            if (hasDefinition) {
              const defSourcesIndex = decodeInteger(reader, definitionSourcesIndex);
              definitionScopeIndex = decodeInteger(
                reader,
                definitionSourcesIndex === defSourcesIndex ? definitionScopeIndex : 0
              );
              definitionSourcesIndex = defSourcesIndex;
              range = [genLine, genColumn, 0, 0, defSourcesIndex, definitionScopeIndex];
            } else {
              range = [genLine, genColumn, 0, 0];
            }
            range.isScope = !!hasScope;
            if (hasCallsite) {
              const prevCsi = callsiteSourcesIndex;
              const prevLine = callsiteLine;
              callsiteSourcesIndex = decodeInteger(reader, callsiteSourcesIndex);
              const sameSource = prevCsi === callsiteSourcesIndex;
              callsiteLine = decodeInteger(reader, sameSource ? callsiteLine : 0);
              callsiteColumn = decodeInteger(
                reader,
                sameSource && prevLine === callsiteLine ? callsiteColumn : 0
              );
              callsite = [callsiteSourcesIndex, callsiteLine, callsiteColumn];
            }
            range.callsite = callsite;
            if (hasMoreVlq(reader, semi)) {
              bindings = [];
              do {
                bindingLine = genLine;
                bindingColumn = genColumn;
                const expressionsCount = decodeInteger(reader, 0);
                let expressionRanges;
                if (expressionsCount < -1) {
                  expressionRanges = [[decodeInteger(reader, 0)]];
                  for (let i = -1; i > expressionsCount; i--) {
                    const prevBl = bindingLine;
                    bindingLine = decodeInteger(reader, bindingLine);
                    bindingColumn = decodeInteger(reader, bindingLine === prevBl ? bindingColumn : 0);
                    const expression = decodeInteger(reader, 0);
                    expressionRanges.push([expression, bindingLine, bindingColumn]);
                  }
                } else {
                  expressionRanges = [[expressionsCount]];
                }
                bindings.push(expressionRanges);
              } while (hasMoreVlq(reader, semi));
            }
            range.bindings = bindings;
            ranges.push(range);
            stack.push(range);
          }
          genLine++;
          reader.pos = semi + 1;
        } while (reader.pos < length);
        return ranges;
      }
      function encodeGeneratedRanges(ranges) {
        if (ranges.length === 0) return "";
        const writer = new StringWriter();
        for (let i = 0; i < ranges.length; ) {
          i = _encodeGeneratedRanges(ranges, i, writer, [0, 0, 0, 0, 0, 0, 0]);
        }
        return writer.flush();
      }
      function _encodeGeneratedRanges(ranges, index, writer, state) {
        const range = ranges[index];
        const {
          0: startLine,
          1: startColumn,
          2: endLine,
          3: endColumn,
          isScope: isScope2,
          callsite,
          bindings
        } = range;
        if (state[0] < startLine) {
          catchupLine(writer, state[0], startLine);
          state[0] = startLine;
          state[1] = 0;
        } else if (index > 0) {
          writer.write(comma);
        }
        state[1] = encodeInteger(writer, range[1], state[1]);
        const fields = (range.length === 6 ? 1 : 0) | (callsite ? 2 : 0) | (isScope2 ? 4 : 0);
        encodeInteger(writer, fields, 0);
        if (range.length === 6) {
          const { 4: sourcesIndex, 5: scopesIndex } = range;
          if (sourcesIndex !== state[2]) {
            state[3] = 0;
          }
          state[2] = encodeInteger(writer, sourcesIndex, state[2]);
          state[3] = encodeInteger(writer, scopesIndex, state[3]);
        }
        if (callsite) {
          const { 0: sourcesIndex, 1: callLine, 2: callColumn } = range.callsite;
          if (sourcesIndex !== state[4]) {
            state[5] = 0;
            state[6] = 0;
          } else if (callLine !== state[5]) {
            state[6] = 0;
          }
          state[4] = encodeInteger(writer, sourcesIndex, state[4]);
          state[5] = encodeInteger(writer, callLine, state[5]);
          state[6] = encodeInteger(writer, callColumn, state[6]);
        }
        if (bindings) {
          for (const binding2 of bindings) {
            if (binding2.length > 1) encodeInteger(writer, -binding2.length, 0);
            const expression = binding2[0][0];
            encodeInteger(writer, expression, 0);
            let bindingStartLine = startLine;
            let bindingStartColumn = startColumn;
            for (let i = 1; i < binding2.length; i++) {
              const expRange = binding2[i];
              bindingStartLine = encodeInteger(writer, expRange[1], bindingStartLine);
              bindingStartColumn = encodeInteger(writer, expRange[2], bindingStartColumn);
              encodeInteger(writer, expRange[0], 0);
            }
          }
        }
        for (index++; index < ranges.length; ) {
          const next = ranges[index];
          const { 0: l, 1: c } = next;
          if (l > endLine || l === endLine && c >= endColumn) {
            break;
          }
          index = _encodeGeneratedRanges(ranges, index, writer, state);
        }
        if (state[0] < endLine) {
          catchupLine(writer, state[0], endLine);
          state[0] = endLine;
          state[1] = 0;
        } else {
          writer.write(comma);
        }
        state[1] = encodeInteger(writer, endColumn, state[1]);
        return index;
      }
      function catchupLine(writer, lastLine, line) {
        do {
          writer.write(semicolon);
        } while (++lastLine < line);
      }
      function decode(mappings) {
        const { length } = mappings;
        const reader = new StringReader(mappings);
        const decoded = [];
        let genColumn = 0;
        let sourcesIndex = 0;
        let sourceLine = 0;
        let sourceColumn = 0;
        let namesIndex = 0;
        do {
          const semi = reader.indexOf(";");
          const line = [];
          let sorted = true;
          let lastCol = 0;
          genColumn = 0;
          while (reader.pos < semi) {
            let seg;
            genColumn = decodeInteger(reader, genColumn);
            if (genColumn < lastCol) sorted = false;
            lastCol = genColumn;
            if (hasMoreVlq(reader, semi)) {
              sourcesIndex = decodeInteger(reader, sourcesIndex);
              sourceLine = decodeInteger(reader, sourceLine);
              sourceColumn = decodeInteger(reader, sourceColumn);
              if (hasMoreVlq(reader, semi)) {
                namesIndex = decodeInteger(reader, namesIndex);
                seg = [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex];
              } else {
                seg = [genColumn, sourcesIndex, sourceLine, sourceColumn];
              }
            } else {
              seg = [genColumn];
            }
            line.push(seg);
            reader.pos++;
          }
          if (!sorted) sort(line);
          decoded.push(line);
          reader.pos = semi + 1;
        } while (reader.pos <= length);
        return decoded;
      }
      function sort(line) {
        line.sort(sortComparator);
      }
      function sortComparator(a, b) {
        return a[0] - b[0];
      }
      function encode(decoded) {
        const writer = new StringWriter();
        let sourcesIndex = 0;
        let sourceLine = 0;
        let sourceColumn = 0;
        let namesIndex = 0;
        for (let i = 0; i < decoded.length; i++) {
          const line = decoded[i];
          if (i > 0) writer.write(semicolon);
          if (line.length === 0) continue;
          let genColumn = 0;
          for (let j = 0; j < line.length; j++) {
            const segment = line[j];
            if (j > 0) writer.write(comma);
            genColumn = encodeInteger(writer, segment[0], genColumn);
            if (segment.length === 1) continue;
            sourcesIndex = encodeInteger(writer, segment[1], sourcesIndex);
            sourceLine = encodeInteger(writer, segment[2], sourceLine);
            sourceColumn = encodeInteger(writer, segment[3], sourceColumn);
            if (segment.length === 4) continue;
            namesIndex = encodeInteger(writer, segment[4], namesIndex);
          }
        }
        return writer.flush();
      }
    }));
  })(sourcemapCodec_umd$1);
  return sourcemapCodec_umd$1.exports;
}
var traceMapping_umd$1 = { exports: {} };
var resolveUri_umd$1 = { exports: {} };
var resolveUri_umd = resolveUri_umd$1.exports;
var hasRequiredResolveUri_umd;
function requireResolveUri_umd() {
  if (hasRequiredResolveUri_umd) return resolveUri_umd$1.exports;
  hasRequiredResolveUri_umd = 1;
  (function(module, exports$1) {
    (function(global2, factory) {
      module.exports = factory();
    })(resolveUri_umd, (function() {
      const schemeRegex = /^[\w+.-]+:\/\//;
      const urlRegex = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/;
      const fileRegex = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
      function isAbsoluteUrl(input) {
        return schemeRegex.test(input);
      }
      function isSchemeRelativeUrl(input) {
        return input.startsWith("//");
      }
      function isAbsolutePath(input) {
        return input.startsWith("/");
      }
      function isFileUrl(input) {
        return input.startsWith("file:");
      }
      function isRelative(input) {
        return /^[.?#]/.test(input);
      }
      function parseAbsoluteUrl(input) {
        const match = urlRegex.exec(input);
        return makeUrl(match[1], match[2] || "", match[3], match[4] || "", match[5] || "/", match[6] || "", match[7] || "");
      }
      function parseFileUrl(input) {
        const match = fileRegex.exec(input);
        const path2 = match[2];
        return makeUrl("file:", "", match[1] || "", "", isAbsolutePath(path2) ? path2 : "/" + path2, match[3] || "", match[4] || "");
      }
      function makeUrl(scheme, user, host, port, path2, query, hash) {
        return {
          scheme,
          user,
          host,
          port,
          path: path2,
          query,
          hash,
          type: 7
        };
      }
      function parseUrl(input) {
        if (isSchemeRelativeUrl(input)) {
          const url2 = parseAbsoluteUrl("http:" + input);
          url2.scheme = "";
          url2.type = 6;
          return url2;
        }
        if (isAbsolutePath(input)) {
          const url2 = parseAbsoluteUrl("http://foo.com" + input);
          url2.scheme = "";
          url2.host = "";
          url2.type = 5;
          return url2;
        }
        if (isFileUrl(input))
          return parseFileUrl(input);
        if (isAbsoluteUrl(input))
          return parseAbsoluteUrl(input);
        const url = parseAbsoluteUrl("http://foo.com/" + input);
        url.scheme = "";
        url.host = "";
        url.type = input ? input.startsWith("?") ? 3 : input.startsWith("#") ? 2 : 4 : 1;
        return url;
      }
      function stripPathFilename(path2) {
        if (path2.endsWith("/.."))
          return path2;
        const index = path2.lastIndexOf("/");
        return path2.slice(0, index + 1);
      }
      function mergePaths(url, base2) {
        normalizePath(base2, base2.type);
        if (url.path === "/") {
          url.path = base2.path;
        } else {
          url.path = stripPathFilename(base2.path) + url.path;
        }
      }
      function normalizePath(url, type) {
        const rel = type <= 4;
        const pieces = url.path.split("/");
        let pointer = 1;
        let positive = 0;
        let addTrailingSlash = false;
        for (let i = 1; i < pieces.length; i++) {
          const piece = pieces[i];
          if (!piece) {
            addTrailingSlash = true;
            continue;
          }
          addTrailingSlash = false;
          if (piece === ".")
            continue;
          if (piece === "..") {
            if (positive) {
              addTrailingSlash = true;
              positive--;
              pointer--;
            } else if (rel) {
              pieces[pointer++] = piece;
            }
            continue;
          }
          pieces[pointer++] = piece;
          positive++;
        }
        let path2 = "";
        for (let i = 1; i < pointer; i++) {
          path2 += "/" + pieces[i];
        }
        if (!path2 || addTrailingSlash && !path2.endsWith("/..")) {
          path2 += "/";
        }
        url.path = path2;
      }
      function resolve(input, base2) {
        if (!input && !base2)
          return "";
        const url = parseUrl(input);
        let inputType = url.type;
        if (base2 && inputType !== 7) {
          const baseUrl = parseUrl(base2);
          const baseType = baseUrl.type;
          switch (inputType) {
            case 1:
              url.hash = baseUrl.hash;
            // fall through
            case 2:
              url.query = baseUrl.query;
            // fall through
            case 3:
            case 4:
              mergePaths(url, baseUrl);
            // fall through
            case 5:
              url.user = baseUrl.user;
              url.host = baseUrl.host;
              url.port = baseUrl.port;
            // fall through
            case 6:
              url.scheme = baseUrl.scheme;
          }
          if (baseType > inputType)
            inputType = baseType;
        }
        normalizePath(url, inputType);
        const queryHash = url.query + url.hash;
        switch (inputType) {
          // This is impossible, because of the empty checks at the start of the function.
          // case UrlType.Empty:
          case 2:
          case 3:
            return queryHash;
          case 4: {
            const path2 = url.path.slice(1);
            if (!path2)
              return queryHash || ".";
            if (isRelative(base2 || input) && !isRelative(path2)) {
              return "./" + path2 + queryHash;
            }
            return path2 + queryHash;
          }
          case 5:
            return url.path + queryHash;
          default:
            return url.scheme + "//" + url.user + url.host + url.port + url.path + queryHash;
        }
      }
      return resolve;
    }));
  })(resolveUri_umd$1);
  return resolveUri_umd$1.exports;
}
var traceMapping_umd = traceMapping_umd$1.exports;
var hasRequiredTraceMapping_umd;
function requireTraceMapping_umd() {
  if (hasRequiredTraceMapping_umd) return traceMapping_umd$1.exports;
  hasRequiredTraceMapping_umd = 1;
  (function(module, exports$1) {
    (function(global2, factory) {
      {
        factory(module, requireResolveUri_umd(), requireSourcemapCodec_umd());
        module.exports = def(module);
      }
      function def(m) {
        return "default" in m.exports ? m.exports.default : m.exports;
      }
    })(traceMapping_umd, (function(module2, require_resolveURI, require_sourcemapCodec) {
      var __create = Object.create;
      var __defProp = Object.defineProperty;
      var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
      var __getOwnPropNames = Object.getOwnPropertyNames;
      var __getProtoOf = Object.getPrototypeOf;
      var __hasOwnProp = Object.prototype.hasOwnProperty;
      var __commonJS = (cb, mod) => function __require() {
        return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
      };
      var __export = (target, all) => {
        for (var name in all)
          __defProp(target, name, { get: all[name], enumerable: true });
      };
      var __copyProps = (to, from, except, desc) => {
        if (from && typeof from === "object" || typeof from === "function") {
          for (let key of __getOwnPropNames(from))
            if (!__hasOwnProp.call(to, key) && key !== except)
              __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
        }
        return to;
      };
      var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
        // If the importer is in node compatibility mode or this is not an ESM
        // file that has been converted to a CommonJS file using a Babel-
        // compatible transform (i.e. "__esModule" has not been set), then set
        // "default" to the CommonJS "module.exports" for node compatibility.
        !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
        mod
      ));
      var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
      var require_sourcemap_codec = __commonJS({
        "umd:@jridgewell/sourcemap-codec"(exports$12, module22) {
          module22.exports = require_sourcemapCodec;
        }
      });
      var require_resolve_uri = __commonJS({
        "umd:@jridgewell/resolve-uri"(exports$12, module22) {
          module22.exports = require_resolveURI;
        }
      });
      var trace_mapping_exports = {};
      __export(trace_mapping_exports, {
        AnyMap: () => FlattenMap,
        FlattenMap: () => FlattenMap,
        GREATEST_LOWER_BOUND: () => GREATEST_LOWER_BOUND,
        LEAST_UPPER_BOUND: () => LEAST_UPPER_BOUND,
        TraceMap: () => TraceMap,
        allGeneratedPositionsFor: () => allGeneratedPositionsFor,
        decodedMap: () => decodedMap,
        decodedMappings: () => decodedMappings,
        eachMapping: () => eachMapping,
        encodedMap: () => encodedMap,
        encodedMappings: () => encodedMappings,
        generatedPositionFor: () => generatedPositionFor,
        isIgnored: () => isIgnored,
        originalPositionFor: () => originalPositionFor,
        presortedDecodedMap: () => presortedDecodedMap,
        sourceContentFor: () => sourceContentFor,
        traceSegment: () => traceSegment
      });
      module2.exports = __toCommonJS(trace_mapping_exports);
      var import_sourcemap_codec = __toESM(require_sourcemap_codec());
      var import_resolve_uri = __toESM(require_resolve_uri());
      function stripFilename(path2) {
        if (!path2) return "";
        const index = path2.lastIndexOf("/");
        return path2.slice(0, index + 1);
      }
      function resolver(mapUrl, sourceRoot) {
        const from = stripFilename(mapUrl);
        const prefix = sourceRoot ? sourceRoot + "/" : "";
        return (source) => (0, import_resolve_uri.default)(prefix + (source || ""), from);
      }
      var COLUMN = 0;
      var SOURCES_INDEX = 1;
      var SOURCE_LINE = 2;
      var SOURCE_COLUMN = 3;
      var NAMES_INDEX = 4;
      var REV_GENERATED_LINE = 1;
      var REV_GENERATED_COLUMN = 2;
      function maybeSort(mappings, owned) {
        const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);
        if (unsortedIndex === mappings.length) return mappings;
        if (!owned) mappings = mappings.slice();
        for (let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)) {
          mappings[i] = sortSegments(mappings[i], owned);
        }
        return mappings;
      }
      function nextUnsortedSegmentLine(mappings, start) {
        for (let i = start; i < mappings.length; i++) {
          if (!isSorted(mappings[i])) return i;
        }
        return mappings.length;
      }
      function isSorted(line) {
        for (let j = 1; j < line.length; j++) {
          if (line[j][COLUMN] < line[j - 1][COLUMN]) {
            return false;
          }
        }
        return true;
      }
      function sortSegments(line, owned) {
        if (!owned) line = line.slice();
        return line.sort(sortComparator);
      }
      function sortComparator(a, b) {
        return a[COLUMN] - b[COLUMN];
      }
      function buildBySources(decoded, memos) {
        const sources = memos.map(() => []);
        for (let i = 0; i < decoded.length; i++) {
          const line = decoded[i];
          for (let j = 0; j < line.length; j++) {
            const seg = line[j];
            if (seg.length === 1) continue;
            const sourceIndex2 = seg[SOURCES_INDEX];
            const sourceLine = seg[SOURCE_LINE];
            const sourceColumn = seg[SOURCE_COLUMN];
            const source = sources[sourceIndex2];
            const segs = source[sourceLine] || (source[sourceLine] = []);
            segs.push([sourceColumn, i, seg[COLUMN]]);
          }
        }
        for (let i = 0; i < sources.length; i++) {
          const source = sources[i];
          for (let j = 0; j < source.length; j++) {
            const line = source[j];
            if (line) line.sort(sortComparator);
          }
        }
        return sources;
      }
      var found = false;
      function binarySearch(haystack, needle, low, high) {
        while (low <= high) {
          const mid = low + (high - low >> 1);
          const cmp = haystack[mid][COLUMN] - needle;
          if (cmp === 0) {
            found = true;
            return mid;
          }
          if (cmp < 0) {
            low = mid + 1;
          } else {
            high = mid - 1;
          }
        }
        found = false;
        return low - 1;
      }
      function upperBound(haystack, needle, index) {
        for (let i = index + 1; i < haystack.length; index = i++) {
          if (haystack[i][COLUMN] !== needle) break;
        }
        return index;
      }
      function lowerBound(haystack, needle, index) {
        for (let i = index - 1; i >= 0; index = i--) {
          if (haystack[i][COLUMN] !== needle) break;
        }
        return index;
      }
      function memoizedState() {
        return {
          lastKey: -1,
          lastNeedle: -1,
          lastIndex: -1
        };
      }
      function memoizedBinarySearch(haystack, needle, state, key) {
        const { lastKey, lastNeedle, lastIndex } = state;
        let low = 0;
        let high = haystack.length - 1;
        if (key === lastKey) {
          if (needle === lastNeedle) {
            found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;
            return lastIndex;
          }
          if (needle >= lastNeedle) {
            low = lastIndex === -1 ? 0 : lastIndex;
          } else {
            high = lastIndex;
          }
        }
        state.lastKey = key;
        state.lastNeedle = needle;
        return state.lastIndex = binarySearch(haystack, needle, low, high);
      }
      function parse2(map) {
        return typeof map === "string" ? JSON.parse(map) : map;
      }
      var FlattenMap = function(map, mapUrl) {
        const parsed = parse2(map);
        if (!("sections" in parsed)) {
          return new TraceMap(parsed, mapUrl);
        }
        const mappings = [];
        const sources = [];
        const sourcesContent = [];
        const names = [];
        const ignoreList = [];
        recurse(
          parsed,
          mapUrl,
          mappings,
          sources,
          sourcesContent,
          names,
          ignoreList,
          0,
          0,
          Infinity,
          Infinity
        );
        const joined = {
          version: 3,
          file: parsed.file,
          names,
          sources,
          sourcesContent,
          mappings,
          ignoreList
        };
        return presortedDecodedMap(joined);
      };
      function recurse(input, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset, columnOffset, stopLine, stopColumn) {
        const { sections } = input;
        for (let i = 0; i < sections.length; i++) {
          const { map, offset } = sections[i];
          let sl = stopLine;
          let sc = stopColumn;
          if (i + 1 < sections.length) {
            const nextOffset = sections[i + 1].offset;
            sl = Math.min(stopLine, lineOffset + nextOffset.line);
            if (sl === stopLine) {
              sc = Math.min(stopColumn, columnOffset + nextOffset.column);
            } else if (sl < stopLine) {
              sc = columnOffset + nextOffset.column;
            }
          }
          addSection(
            map,
            mapUrl,
            mappings,
            sources,
            sourcesContent,
            names,
            ignoreList,
            lineOffset + offset.line,
            columnOffset + offset.column,
            sl,
            sc
          );
        }
      }
      function addSection(input, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset, columnOffset, stopLine, stopColumn) {
        const parsed = parse2(input);
        if ("sections" in parsed) return recurse(...arguments);
        const map = new TraceMap(parsed, mapUrl);
        const sourcesOffset = sources.length;
        const namesOffset = names.length;
        const decoded = decodedMappings(map);
        const { resolvedSources, sourcesContent: contents, ignoreList: ignores } = map;
        append(sources, resolvedSources);
        append(names, map.names);
        if (contents) append(sourcesContent, contents);
        else for (let i = 0; i < resolvedSources.length; i++) sourcesContent.push(null);
        if (ignores) for (let i = 0; i < ignores.length; i++) ignoreList.push(ignores[i] + sourcesOffset);
        for (let i = 0; i < decoded.length; i++) {
          const lineI = lineOffset + i;
          if (lineI > stopLine) return;
          const out = getLine(mappings, lineI);
          const cOffset = i === 0 ? columnOffset : 0;
          const line = decoded[i];
          for (let j = 0; j < line.length; j++) {
            const seg = line[j];
            const column = cOffset + seg[COLUMN];
            if (lineI === stopLine && column >= stopColumn) return;
            if (seg.length === 1) {
              out.push([column]);
              continue;
            }
            const sourcesIndex = sourcesOffset + seg[SOURCES_INDEX];
            const sourceLine = seg[SOURCE_LINE];
            const sourceColumn = seg[SOURCE_COLUMN];
            out.push(
              seg.length === 4 ? [column, sourcesIndex, sourceLine, sourceColumn] : [column, sourcesIndex, sourceLine, sourceColumn, namesOffset + seg[NAMES_INDEX]]
            );
          }
        }
      }
      function append(arr, other) {
        for (let i = 0; i < other.length; i++) arr.push(other[i]);
      }
      function getLine(arr, index) {
        for (let i = arr.length; i <= index; i++) arr[i] = [];
        return arr[index];
      }
      var LINE_GTR_ZERO = "`line` must be greater than 0 (lines start at line 1)";
      var COL_GTR_EQ_ZERO = "`column` must be greater than or equal to 0 (columns start at column 0)";
      var LEAST_UPPER_BOUND = -1;
      var GREATEST_LOWER_BOUND = 1;
      var TraceMap = class {
        constructor(map, mapUrl) {
          const isString = typeof map === "string";
          if (!isString && map._decodedMemo) return map;
          const parsed = parse2(map);
          const { version, file, names, sourceRoot, sources, sourcesContent } = parsed;
          this.version = version;
          this.file = file;
          this.names = names || [];
          this.sourceRoot = sourceRoot;
          this.sources = sources;
          this.sourcesContent = sourcesContent;
          this.ignoreList = parsed.ignoreList || parsed.x_google_ignoreList || void 0;
          const resolve = resolver(mapUrl, sourceRoot);
          this.resolvedSources = sources.map(resolve);
          const { mappings } = parsed;
          if (typeof mappings === "string") {
            this._encoded = mappings;
            this._decoded = void 0;
          } else if (Array.isArray(mappings)) {
            this._encoded = void 0;
            this._decoded = maybeSort(mappings, isString);
          } else if (parsed.sections) {
            throw new Error(`TraceMap passed sectioned source map, please use FlattenMap export instead`);
          } else {
            throw new Error(`invalid source map: ${JSON.stringify(parsed)}`);
          }
          this._decodedMemo = memoizedState();
          this._bySources = void 0;
          this._bySourceMemos = void 0;
        }
      };
      function cast(map) {
        return map;
      }
      function encodedMappings(map) {
        var _a, _b;
        return (_b = (_a = cast(map))._encoded) != null ? _b : _a._encoded = (0, import_sourcemap_codec.encode)(cast(map)._decoded);
      }
      function decodedMappings(map) {
        var _a;
        return (_a = cast(map))._decoded || (_a._decoded = (0, import_sourcemap_codec.decode)(cast(map)._encoded));
      }
      function traceSegment(map, line, column) {
        const decoded = decodedMappings(map);
        if (line >= decoded.length) return null;
        const segments = decoded[line];
        const index = traceSegmentInternal(
          segments,
          cast(map)._decodedMemo,
          line,
          column,
          GREATEST_LOWER_BOUND
        );
        return index === -1 ? null : segments[index];
      }
      function originalPositionFor(map, needle) {
        let { line, column, bias } = needle;
        line--;
        if (line < 0) throw new Error(LINE_GTR_ZERO);
        if (column < 0) throw new Error(COL_GTR_EQ_ZERO);
        const decoded = decodedMappings(map);
        if (line >= decoded.length) return OMapping(null, null, null, null);
        const segments = decoded[line];
        const index = traceSegmentInternal(
          segments,
          cast(map)._decodedMemo,
          line,
          column,
          bias || GREATEST_LOWER_BOUND
        );
        if (index === -1) return OMapping(null, null, null, null);
        const segment = segments[index];
        if (segment.length === 1) return OMapping(null, null, null, null);
        const { names, resolvedSources } = map;
        return OMapping(
          resolvedSources[segment[SOURCES_INDEX]],
          segment[SOURCE_LINE] + 1,
          segment[SOURCE_COLUMN],
          segment.length === 5 ? names[segment[NAMES_INDEX]] : null
        );
      }
      function generatedPositionFor(map, needle) {
        const { source, line, column, bias } = needle;
        return generatedPosition(map, source, line, column, bias || GREATEST_LOWER_BOUND, false);
      }
      function allGeneratedPositionsFor(map, needle) {
        const { source, line, column, bias } = needle;
        return generatedPosition(map, source, line, column, bias || LEAST_UPPER_BOUND, true);
      }
      function eachMapping(map, cb) {
        const decoded = decodedMappings(map);
        const { names, resolvedSources } = map;
        for (let i = 0; i < decoded.length; i++) {
          const line = decoded[i];
          for (let j = 0; j < line.length; j++) {
            const seg = line[j];
            const generatedLine = i + 1;
            const generatedColumn = seg[0];
            let source = null;
            let originalLine = null;
            let originalColumn = null;
            let name = null;
            if (seg.length !== 1) {
              source = resolvedSources[seg[1]];
              originalLine = seg[2] + 1;
              originalColumn = seg[3];
            }
            if (seg.length === 5) name = names[seg[4]];
            cb({
              generatedLine,
              generatedColumn,
              source,
              originalLine,
              originalColumn,
              name
            });
          }
        }
      }
      function sourceIndex(map, source) {
        const { sources, resolvedSources } = map;
        let index = sources.indexOf(source);
        if (index === -1) index = resolvedSources.indexOf(source);
        return index;
      }
      function sourceContentFor(map, source) {
        const { sourcesContent } = map;
        if (sourcesContent == null) return null;
        const index = sourceIndex(map, source);
        return index === -1 ? null : sourcesContent[index];
      }
      function isIgnored(map, source) {
        const { ignoreList } = map;
        if (ignoreList == null) return false;
        const index = sourceIndex(map, source);
        return index === -1 ? false : ignoreList.includes(index);
      }
      function presortedDecodedMap(map, mapUrl) {
        const tracer = new TraceMap(clone2(map, []), mapUrl);
        cast(tracer)._decoded = map.mappings;
        return tracer;
      }
      function decodedMap(map) {
        return clone2(map, decodedMappings(map));
      }
      function encodedMap(map) {
        return clone2(map, encodedMappings(map));
      }
      function clone2(map, mappings) {
        return {
          version: map.version,
          file: map.file,
          names: map.names,
          sourceRoot: map.sourceRoot,
          sources: map.sources,
          sourcesContent: map.sourcesContent,
          mappings,
          ignoreList: map.ignoreList || map.x_google_ignoreList
        };
      }
      function OMapping(source, line, column, name) {
        return { source, line, column, name };
      }
      function GMapping(line, column) {
        return { line, column };
      }
      function traceSegmentInternal(segments, memo, line, column, bias) {
        let index = memoizedBinarySearch(segments, column, memo, line);
        if (found) {
          index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);
        } else if (bias === LEAST_UPPER_BOUND) index++;
        if (index === -1 || index === segments.length) return -1;
        return index;
      }
      function sliceGeneratedPositions(segments, memo, line, column, bias) {
        let min = traceSegmentInternal(segments, memo, line, column, GREATEST_LOWER_BOUND);
        if (!found && bias === LEAST_UPPER_BOUND) min++;
        if (min === -1 || min === segments.length) return [];
        const matchedColumn = found ? column : segments[min][COLUMN];
        if (!found) min = lowerBound(segments, matchedColumn, min);
        const max = upperBound(segments, matchedColumn, min);
        const result = [];
        for (; min <= max; min++) {
          const segment = segments[min];
          result.push(GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]));
        }
        return result;
      }
      function generatedPosition(map, source, line, column, bias, all) {
        var _a, _b;
        line--;
        if (line < 0) throw new Error(LINE_GTR_ZERO);
        if (column < 0) throw new Error(COL_GTR_EQ_ZERO);
        const { sources, resolvedSources } = map;
        let sourceIndex2 = sources.indexOf(source);
        if (sourceIndex2 === -1) sourceIndex2 = resolvedSources.indexOf(source);
        if (sourceIndex2 === -1) return all ? [] : GMapping(null, null);
        const bySourceMemos = (_a = cast(map))._bySourceMemos || (_a._bySourceMemos = sources.map(memoizedState));
        const generated2 = (_b = cast(map))._bySources || (_b._bySources = buildBySources(decodedMappings(map), bySourceMemos));
        const segments = generated2[sourceIndex2][line];
        if (segments == null) return all ? [] : GMapping(null, null);
        const memo = bySourceMemos[sourceIndex2];
        if (all) return sliceGeneratedPositions(segments, memo, line, column, bias);
        const index = traceSegmentInternal(segments, memo, line, column, bias);
        if (index === -1) return GMapping(null, null);
        const segment = segments[index];
        return GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]);
      }
    }));
  })(traceMapping_umd$1);
  return traceMapping_umd$1.exports;
}
var genMapping_umd = genMapping_umd$1.exports;
var hasRequiredGenMapping_umd;
function requireGenMapping_umd() {
  if (hasRequiredGenMapping_umd) return genMapping_umd$1.exports;
  hasRequiredGenMapping_umd = 1;
  (function(module, exports$1) {
    (function(global2, factory) {
      {
        factory(module, requireSourcemapCodec_umd(), requireTraceMapping_umd());
        module.exports = def(module);
      }
      function def(m) {
        return "default" in m.exports ? m.exports.default : m.exports;
      }
    })(genMapping_umd, (function(module2, require_sourcemapCodec, require_traceMapping) {
      var __create = Object.create;
      var __defProp = Object.defineProperty;
      var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
      var __getOwnPropNames = Object.getOwnPropertyNames;
      var __getProtoOf = Object.getPrototypeOf;
      var __hasOwnProp = Object.prototype.hasOwnProperty;
      var __commonJS = (cb, mod) => function __require() {
        return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
      };
      var __export = (target, all) => {
        for (var name in all)
          __defProp(target, name, { get: all[name], enumerable: true });
      };
      var __copyProps = (to, from, except, desc) => {
        if (from && typeof from === "object" || typeof from === "function") {
          for (let key of __getOwnPropNames(from))
            if (!__hasOwnProp.call(to, key) && key !== except)
              __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
        }
        return to;
      };
      var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
        // If the importer is in node compatibility mode or this is not an ESM
        // file that has been converted to a CommonJS file using a Babel-
        // compatible transform (i.e. "__esModule" has not been set), then set
        // "default" to the CommonJS "module.exports" for node compatibility.
        !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
        mod
      ));
      var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
      var require_sourcemap_codec = __commonJS({
        "umd:@jridgewell/sourcemap-codec"(exports$12, module22) {
          module22.exports = require_sourcemapCodec;
        }
      });
      var require_trace_mapping = __commonJS({
        "umd:@jridgewell/trace-mapping"(exports$12, module22) {
          module22.exports = require_traceMapping;
        }
      });
      var gen_mapping_exports = {};
      __export(gen_mapping_exports, {
        GenMapping: () => GenMapping,
        addMapping: () => addMapping,
        addSegment: () => addSegment,
        allMappings: () => allMappings,
        fromMap: () => fromMap,
        maybeAddMapping: () => maybeAddMapping,
        maybeAddSegment: () => maybeAddSegment,
        setIgnore: () => setIgnore,
        setSourceContent: () => setSourceContent,
        toDecodedMap: () => toDecodedMap,
        toEncodedMap: () => toEncodedMap
      });
      module2.exports = __toCommonJS(gen_mapping_exports);
      var SetArray = class {
        constructor() {
          this._indexes = { __proto__: null };
          this.array = [];
        }
      };
      function cast(set) {
        return set;
      }
      function get(setarr, key) {
        return cast(setarr)._indexes[key];
      }
      function put(setarr, key) {
        const index = get(setarr, key);
        if (index !== void 0) return index;
        const { array, _indexes: indexes } = cast(setarr);
        const length = array.push(key);
        return indexes[key] = length - 1;
      }
      function remove(setarr, key) {
        const index = get(setarr, key);
        if (index === void 0) return;
        const { array, _indexes: indexes } = cast(setarr);
        for (let i = index + 1; i < array.length; i++) {
          const k = array[i];
          array[i - 1] = k;
          indexes[k]--;
        }
        indexes[key] = void 0;
        array.pop();
      }
      var import_sourcemap_codec = __toESM(require_sourcemap_codec());
      var import_trace_mapping = __toESM(require_trace_mapping());
      var COLUMN = 0;
      var SOURCES_INDEX = 1;
      var SOURCE_LINE = 2;
      var SOURCE_COLUMN = 3;
      var NAMES_INDEX = 4;
      var NO_NAME = -1;
      var GenMapping = class {
        constructor({ file, sourceRoot } = {}) {
          this._names = new SetArray();
          this._sources = new SetArray();
          this._sourcesContent = [];
          this._mappings = [];
          this.file = file;
          this.sourceRoot = sourceRoot;
          this._ignoreList = new SetArray();
        }
      };
      function cast2(map) {
        return map;
      }
      function addSegment(map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) {
        return addSegmentInternal(
          false,
          map,
          genLine,
          genColumn,
          source,
          sourceLine,
          sourceColumn,
          name,
          content
        );
      }
      function addMapping(map, mapping) {
        return addMappingInternal(false, map, mapping);
      }
      var maybeAddSegment = (map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) => {
        return addSegmentInternal(
          true,
          map,
          genLine,
          genColumn,
          source,
          sourceLine,
          sourceColumn,
          name,
          content
        );
      };
      var maybeAddMapping = (map, mapping) => {
        return addMappingInternal(true, map, mapping);
      };
      function setSourceContent(map, source, content) {
        const {
          _sources: sources,
          _sourcesContent: sourcesContent
          // _originalScopes: originalScopes,
        } = cast2(map);
        const index = put(sources, source);
        sourcesContent[index] = content;
      }
      function setIgnore(map, source, ignore = true) {
        const {
          _sources: sources,
          _sourcesContent: sourcesContent,
          _ignoreList: ignoreList
          // _originalScopes: originalScopes,
        } = cast2(map);
        const index = put(sources, source);
        if (index === sourcesContent.length) sourcesContent[index] = null;
        if (ignore) put(ignoreList, index);
        else remove(ignoreList, index);
      }
      function toDecodedMap(map) {
        const {
          _mappings: mappings,
          _sources: sources,
          _sourcesContent: sourcesContent,
          _names: names,
          _ignoreList: ignoreList
          // _originalScopes: originalScopes,
          // _generatedRanges: generatedRanges,
        } = cast2(map);
        removeEmptyFinalLines(mappings);
        return {
          version: 3,
          file: map.file || void 0,
          names: names.array,
          sourceRoot: map.sourceRoot || void 0,
          sources: sources.array,
          sourcesContent,
          mappings,
          // originalScopes,
          // generatedRanges,
          ignoreList: ignoreList.array
        };
      }
      function toEncodedMap(map) {
        const decoded = toDecodedMap(map);
        return Object.assign({}, decoded, {
          // originalScopes: decoded.originalScopes.map((os) => encodeOriginalScopes(os)),
          // generatedRanges: encodeGeneratedRanges(decoded.generatedRanges as GeneratedRange[]),
          mappings: (0, import_sourcemap_codec.encode)(decoded.mappings)
        });
      }
      function fromMap(input) {
        const map = new import_trace_mapping.TraceMap(input);
        const gen = new GenMapping({ file: map.file, sourceRoot: map.sourceRoot });
        putAll(cast2(gen)._names, map.names);
        putAll(cast2(gen)._sources, map.sources);
        cast2(gen)._sourcesContent = map.sourcesContent || map.sources.map(() => null);
        cast2(gen)._mappings = (0, import_trace_mapping.decodedMappings)(map);
        if (map.ignoreList) putAll(cast2(gen)._ignoreList, map.ignoreList);
        return gen;
      }
      function allMappings(map) {
        const out = [];
        const { _mappings: mappings, _sources: sources, _names: names } = cast2(map);
        for (let i = 0; i < mappings.length; i++) {
          const line = mappings[i];
          for (let j = 0; j < line.length; j++) {
            const seg = line[j];
            const generated2 = { line: i + 1, column: seg[COLUMN] };
            let source = void 0;
            let original = void 0;
            let name = void 0;
            if (seg.length !== 1) {
              source = sources.array[seg[SOURCES_INDEX]];
              original = { line: seg[SOURCE_LINE] + 1, column: seg[SOURCE_COLUMN] };
              if (seg.length === 5) name = names.array[seg[NAMES_INDEX]];
            }
            out.push({ generated: generated2, source, original, name });
          }
        }
        return out;
      }
      function addSegmentInternal(skipable, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) {
        const {
          _mappings: mappings,
          _sources: sources,
          _sourcesContent: sourcesContent,
          _names: names
          // _originalScopes: originalScopes,
        } = cast2(map);
        const line = getIndex(mappings, genLine);
        const index = getColumnIndex(line, genColumn);
        if (!source) {
          if (skipable && skipSourceless(line, index)) return;
          return insert(line, index, [genColumn]);
        }
        const sourcesIndex = put(sources, source);
        const namesIndex = name ? put(names, name) : NO_NAME;
        if (sourcesIndex === sourcesContent.length) sourcesContent[sourcesIndex] = content != null ? content : null;
        if (skipable && skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex)) {
          return;
        }
        return insert(
          line,
          index,
          name ? [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex] : [genColumn, sourcesIndex, sourceLine, sourceColumn]
        );
      }
      function getIndex(arr, index) {
        for (let i = arr.length; i <= index; i++) {
          arr[i] = [];
        }
        return arr[index];
      }
      function getColumnIndex(line, genColumn) {
        let index = line.length;
        for (let i = index - 1; i >= 0; index = i--) {
          const current = line[i];
          if (genColumn >= current[COLUMN]) break;
        }
        return index;
      }
      function insert(array, index, value) {
        for (let i = array.length; i > index; i--) {
          array[i] = array[i - 1];
        }
        array[index] = value;
      }
      function removeEmptyFinalLines(mappings) {
        const { length } = mappings;
        let len = length;
        for (let i = len - 1; i >= 0; len = i, i--) {
          if (mappings[i].length > 0) break;
        }
        if (len < length) mappings.length = len;
      }
      function putAll(setarr, array) {
        for (let i = 0; i < array.length; i++) put(setarr, array[i]);
      }
      function skipSourceless(line, index) {
        if (index === 0) return true;
        const prev = line[index - 1];
        return prev.length === 1;
      }
      function skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex) {
        if (index === 0) return false;
        const prev = line[index - 1];
        if (prev.length === 1) return false;
        return sourcesIndex === prev[SOURCES_INDEX] && sourceLine === prev[SOURCE_LINE] && sourceColumn === prev[SOURCE_COLUMN] && namesIndex === (prev.length === 5 ? prev[NAMES_INDEX] : NO_NAME);
      }
      function addMappingInternal(skipable, map, mapping) {
        const { generated: generated2, source, original, name, content } = mapping;
        if (!source) {
          return addSegmentInternal(
            skipable,
            map,
            generated2.line - 1,
            generated2.column,
            null,
            null,
            null,
            null,
            null
          );
        }
        return addSegmentInternal(
          skipable,
          map,
          generated2.line - 1,
          generated2.column,
          source,
          original.line - 1,
          original.column,
          name,
          content
        );
      }
    }));
  })(genMapping_umd$1);
  return genMapping_umd$1.exports;
}
var hasRequiredSourceMap;
function requireSourceMap() {
  if (hasRequiredSourceMap) return sourceMap;
  hasRequiredSourceMap = 1;
  Object.defineProperty(sourceMap, "__esModule", {
    value: true
  });
  sourceMap.default = void 0;
  var _genMapping = requireGenMapping_umd();
  var _traceMapping = requireTraceMapping_umd();
  class SourceMap {
    constructor(opts, code) {
      var _opts$sourceFileName;
      this._map = void 0;
      this._rawMappings = void 0;
      this._sourceFileName = void 0;
      this._lastGenLine = 0;
      this._lastSourceLine = 0;
      this._lastSourceColumn = 0;
      this._inputMap = null;
      const map = this._map = new _genMapping.GenMapping({
        sourceRoot: opts.sourceRoot
      });
      this._sourceFileName = (_opts$sourceFileName = opts.sourceFileName) == null ? void 0 : _opts$sourceFileName.replace(/\\/g, "/");
      this._rawMappings = void 0;
      if (opts.inputSourceMap) {
        this._inputMap = new _traceMapping.TraceMap(opts.inputSourceMap);
        const resolvedSources = this._inputMap.resolvedSources;
        if (resolvedSources.length) {
          for (let i = 0; i < resolvedSources.length; i++) {
            var _this$_inputMap$sourc;
            (0, _genMapping.setSourceContent)(map, resolvedSources[i], (_this$_inputMap$sourc = this._inputMap.sourcesContent) == null ? void 0 : _this$_inputMap$sourc[i]);
          }
        }
      }
      if (typeof code === "string" && !opts.inputSourceMap) {
        (0, _genMapping.setSourceContent)(map, this._sourceFileName, code);
      } else if (typeof code === "object") {
        for (const sourceFileName of Object.keys(code)) {
          (0, _genMapping.setSourceContent)(map, sourceFileName.replace(/\\/g, "/"), code[sourceFileName]);
        }
      }
    }
    get() {
      return (0, _genMapping.toEncodedMap)(this._map);
    }
    getDecoded() {
      return (0, _genMapping.toDecodedMap)(this._map);
    }
    getRawMappings() {
      return this._rawMappings || (this._rawMappings = (0, _genMapping.allMappings)(this._map));
    }
    mark(generated2, line, column, identifierName, identifierNamePos, filename) {
      var _originalMapping;
      this._rawMappings = void 0;
      let originalMapping;
      if (line != null) {
        if (this._inputMap) {
          originalMapping = (0, _traceMapping.originalPositionFor)(this._inputMap, {
            line,
            column
          });
          if (!originalMapping.name && identifierNamePos) {
            const originalIdentifierMapping = (0, _traceMapping.originalPositionFor)(this._inputMap, identifierNamePos);
            if (originalIdentifierMapping.name) {
              identifierName = originalIdentifierMapping.name;
            }
          }
        } else {
          originalMapping = {
            name: null,
            source: (filename == null ? void 0 : filename.replace(/\\/g, "/")) || this._sourceFileName,
            line,
            column
          };
        }
      }
      (0, _genMapping.maybeAddMapping)(this._map, {
        name: identifierName,
        generated: generated2,
        source: (_originalMapping = originalMapping) == null ? void 0 : _originalMapping.source,
        original: originalMapping
      });
    }
  }
  sourceMap.default = SourceMap;
  return sourceMap;
}
var printer = {};
var buffer = {};
var hasRequiredBuffer;
function requireBuffer() {
  if (hasRequiredBuffer) return buffer;
  hasRequiredBuffer = 1;
  Object.defineProperty(buffer, "__esModule", {
    value: true
  });
  buffer.default = void 0;
  class Buffer2 {
    constructor(map, indentChar) {
      this._map = null;
      this._buf = "";
      this._str = "";
      this._appendCount = 0;
      this._last = 0;
      this._queue = [];
      this._queueCursor = 0;
      this._canMarkIdName = true;
      this._indentChar = "";
      this._fastIndentations = [];
      this._position = {
        line: 1,
        column: 0
      };
      this._sourcePosition = {
        identifierName: void 0,
        identifierNamePos: void 0,
        line: void 0,
        column: void 0,
        filename: void 0
      };
      this._map = map;
      this._indentChar = indentChar;
      for (let i = 0; i < 64; i++) {
        this._fastIndentations.push(indentChar.repeat(i));
      }
      this._allocQueue();
    }
    _allocQueue() {
      const queue = this._queue;
      for (let i = 0; i < 16; i++) {
        queue.push({
          char: 0,
          repeat: 1,
          line: void 0,
          column: void 0,
          identifierName: void 0,
          identifierNamePos: void 0,
          filename: ""
        });
      }
    }
    _pushQueue(char, repeat, line, column, filename) {
      const cursor = this._queueCursor;
      if (cursor === this._queue.length) {
        this._allocQueue();
      }
      const item = this._queue[cursor];
      item.char = char;
      item.repeat = repeat;
      item.line = line;
      item.column = column;
      item.filename = filename;
      this._queueCursor++;
    }
    _popQueue() {
      if (this._queueCursor === 0) {
        throw new Error("Cannot pop from empty queue");
      }
      return this._queue[--this._queueCursor];
    }
    get() {
      this._flush();
      const map = this._map;
      const result = {
        code: (this._buf + this._str).trimRight(),
        decodedMap: map == null ? void 0 : map.getDecoded(),
        get __mergedMap() {
          return this.map;
        },
        get map() {
          const resultMap = map ? map.get() : null;
          result.map = resultMap;
          return resultMap;
        },
        set map(value) {
          Object.defineProperty(result, "map", {
            value,
            writable: true
          });
        },
        get rawMappings() {
          const mappings = map == null ? void 0 : map.getRawMappings();
          result.rawMappings = mappings;
          return mappings;
        },
        set rawMappings(value) {
          Object.defineProperty(result, "rawMappings", {
            value,
            writable: true
          });
        }
      };
      return result;
    }
    append(str, maybeNewline) {
      this._flush();
      this._append(str, this._sourcePosition, maybeNewline);
    }
    appendChar(char) {
      this._flush();
      this._appendChar(char, 1, this._sourcePosition);
    }
    queue(char) {
      if (char === 10) {
        while (this._queueCursor !== 0) {
          const char2 = this._queue[this._queueCursor - 1].char;
          if (char2 !== 32 && char2 !== 9) {
            break;
          }
          this._queueCursor--;
        }
      }
      const sourcePosition = this._sourcePosition;
      this._pushQueue(char, 1, sourcePosition.line, sourcePosition.column, sourcePosition.filename);
    }
    queueIndentation(repeat) {
      if (repeat === 0) return;
      this._pushQueue(-1, repeat, void 0, void 0, void 0);
    }
    _flush() {
      const queueCursor = this._queueCursor;
      const queue = this._queue;
      for (let i = 0; i < queueCursor; i++) {
        const item = queue[i];
        this._appendChar(item.char, item.repeat, item);
      }
      this._queueCursor = 0;
    }
    _appendChar(char, repeat, sourcePos) {
      this._last = char;
      if (char === -1) {
        const fastIndentation = this._fastIndentations[repeat];
        if (fastIndentation !== void 0) {
          this._str += fastIndentation;
        } else {
          this._str += repeat > 1 ? this._indentChar.repeat(repeat) : this._indentChar;
        }
      } else {
        this._str += repeat > 1 ? String.fromCharCode(char).repeat(repeat) : String.fromCharCode(char);
      }
      if (char !== 10) {
        this._mark(sourcePos.line, sourcePos.column, sourcePos.identifierName, sourcePos.identifierNamePos, sourcePos.filename);
        this._position.column += repeat;
      } else {
        this._position.line++;
        this._position.column = 0;
      }
      if (this._canMarkIdName) {
        sourcePos.identifierName = void 0;
        sourcePos.identifierNamePos = void 0;
      }
    }
    _append(str, sourcePos, maybeNewline) {
      const len = str.length;
      const position = this._position;
      this._last = str.charCodeAt(len - 1);
      if (++this._appendCount > 4096) {
        +this._str;
        this._buf += this._str;
        this._str = str;
        this._appendCount = 0;
      } else {
        this._str += str;
      }
      if (!maybeNewline && !this._map) {
        position.column += len;
        return;
      }
      const {
        column,
        identifierName,
        identifierNamePos,
        filename
      } = sourcePos;
      let line = sourcePos.line;
      if ((identifierName != null || identifierNamePos != null) && this._canMarkIdName) {
        sourcePos.identifierName = void 0;
        sourcePos.identifierNamePos = void 0;
      }
      let i = str.indexOf("\n");
      let last = 0;
      if (i !== 0) {
        this._mark(line, column, identifierName, identifierNamePos, filename);
      }
      while (i !== -1) {
        position.line++;
        position.column = 0;
        last = i + 1;
        if (last < len && line !== void 0) {
          this._mark(++line, 0, void 0, void 0, filename);
        }
        i = str.indexOf("\n", last);
      }
      position.column += len - last;
    }
    _mark(line, column, identifierName, identifierNamePos, filename) {
      var _this$_map;
      (_this$_map = this._map) == null || _this$_map.mark(this._position, line, column, identifierName, identifierNamePos, filename);
    }
    removeTrailingNewline() {
      const queueCursor = this._queueCursor;
      if (queueCursor !== 0 && this._queue[queueCursor - 1].char === 10) {
        this._queueCursor--;
      }
    }
    removeLastSemicolon() {
      const queueCursor = this._queueCursor;
      if (queueCursor !== 0 && this._queue[queueCursor - 1].char === 59) {
        this._queueCursor--;
      }
    }
    getLastChar() {
      const queueCursor = this._queueCursor;
      return queueCursor !== 0 ? this._queue[queueCursor - 1].char : this._last;
    }
    getNewlineCount() {
      const queueCursor = this._queueCursor;
      let count = 0;
      if (queueCursor === 0) return this._last === 10 ? 1 : 0;
      for (let i = queueCursor - 1; i >= 0; i--) {
        if (this._queue[i].char !== 10) {
          break;
        }
        count++;
      }
      return count === queueCursor && this._last === 10 ? count + 1 : count;
    }
    endsWithCharAndNewline() {
      const queue = this._queue;
      const queueCursor = this._queueCursor;
      if (queueCursor !== 0) {
        const lastCp = queue[queueCursor - 1].char;
        if (lastCp !== 10) return;
        if (queueCursor > 1) {
          return queue[queueCursor - 2].char;
        } else {
          return this._last;
        }
      }
    }
    hasContent() {
      return this._queueCursor !== 0 || !!this._last;
    }
    exactSource(loc, cb) {
      if (!this._map) {
        cb();
        return;
      }
      this.source("start", loc);
      const identifierName = loc.identifierName;
      const sourcePos = this._sourcePosition;
      if (identifierName) {
        this._canMarkIdName = false;
        sourcePos.identifierName = identifierName;
      }
      cb();
      if (identifierName) {
        this._canMarkIdName = true;
        sourcePos.identifierName = void 0;
        sourcePos.identifierNamePos = void 0;
      }
      this.source("end", loc);
    }
    source(prop, loc) {
      if (!this._map) return;
      this._normalizePosition(prop, loc, 0);
    }
    sourceWithOffset(prop, loc, columnOffset) {
      if (!this._map) return;
      this._normalizePosition(prop, loc, columnOffset);
    }
    _normalizePosition(prop, loc, columnOffset) {
      const pos = loc[prop];
      const target = this._sourcePosition;
      if (pos) {
        target.line = pos.line;
        target.column = Math.max(pos.column + columnOffset, 0);
        target.filename = loc.filename;
      }
    }
    getCurrentColumn() {
      const queue = this._queue;
      const queueCursor = this._queueCursor;
      let lastIndex = -1;
      let len = 0;
      for (let i = 0; i < queueCursor; i++) {
        const item = queue[i];
        if (item.char === 10) {
          lastIndex = len;
        }
        len += item.repeat;
      }
      return lastIndex === -1 ? this._position.column + len : len - 1 - lastIndex;
    }
    getCurrentLine() {
      let count = 0;
      const queue = this._queue;
      for (let i = 0; i < this._queueCursor; i++) {
        if (queue[i].char === 10) {
          count++;
        }
      }
      return this._position.line + count;
    }
  }
  buffer.default = Buffer2;
  return buffer;
}
var node = {};
var whitespace = {};
var hasRequiredWhitespace;
function requireWhitespace() {
  if (hasRequiredWhitespace) return whitespace;
  hasRequiredWhitespace = 1;
  Object.defineProperty(whitespace, "__esModule", {
    value: true
  });
  whitespace.nodes = void 0;
  var _t = requireLib$4();
  const {
    FLIPPED_ALIAS_KEYS,
    isArrayExpression,
    isAssignmentExpression,
    isBinary,
    isBlockStatement,
    isCallExpression,
    isFunction,
    isIdentifier,
    isLiteral,
    isMemberExpression,
    isObjectExpression,
    isOptionalCallExpression,
    isOptionalMemberExpression,
    isStringLiteral
  } = _t;
  function crawlInternal(node2, state) {
    if (!node2) return state;
    if (isMemberExpression(node2) || isOptionalMemberExpression(node2)) {
      crawlInternal(node2.object, state);
      if (node2.computed) crawlInternal(node2.property, state);
    } else if (isBinary(node2) || isAssignmentExpression(node2)) {
      crawlInternal(node2.left, state);
      crawlInternal(node2.right, state);
    } else if (isCallExpression(node2) || isOptionalCallExpression(node2)) {
      state.hasCall = true;
      crawlInternal(node2.callee, state);
    } else if (isFunction(node2)) {
      state.hasFunction = true;
    } else if (isIdentifier(node2)) {
      state.hasHelper = state.hasHelper || node2.callee && isHelper(node2.callee);
    }
    return state;
  }
  function crawl(node2) {
    return crawlInternal(node2, {
      hasCall: false,
      hasFunction: false,
      hasHelper: false
    });
  }
  function isHelper(node2) {
    if (!node2) return false;
    if (isMemberExpression(node2)) {
      return isHelper(node2.object) || isHelper(node2.property);
    } else if (isIdentifier(node2)) {
      return node2.name === "require" || node2.name.charCodeAt(0) === 95;
    } else if (isCallExpression(node2)) {
      return isHelper(node2.callee);
    } else if (isBinary(node2) || isAssignmentExpression(node2)) {
      return isIdentifier(node2.left) && isHelper(node2.left) || isHelper(node2.right);
    } else {
      return false;
    }
  }
  function isType2(node2) {
    return isLiteral(node2) || isObjectExpression(node2) || isArrayExpression(node2) || isIdentifier(node2) || isMemberExpression(node2);
  }
  const nodes = whitespace.nodes = {
    AssignmentExpression(node2) {
      const state = crawl(node2.right);
      if (state.hasCall && state.hasHelper || state.hasFunction) {
        return state.hasFunction ? 1 | 2 : 2;
      }
      return 0;
    },
    SwitchCase(node2, parent) {
      return (!!node2.consequent.length || parent.cases[0] === node2 ? 1 : 0) | (!node2.consequent.length && parent.cases[parent.cases.length - 1] === node2 ? 2 : 0);
    },
    LogicalExpression(node2) {
      if (isFunction(node2.left) || isFunction(node2.right)) {
        return 2;
      }
      return 0;
    },
    Literal(node2) {
      if (isStringLiteral(node2) && node2.value === "use strict") {
        return 2;
      }
      return 0;
    },
    CallExpression(node2) {
      if (isFunction(node2.callee) || isHelper(node2)) {
        return 1 | 2;
      }
      return 0;
    },
    OptionalCallExpression(node2) {
      if (isFunction(node2.callee)) {
        return 1 | 2;
      }
      return 0;
    },
    VariableDeclaration(node2) {
      for (let i = 0; i < node2.declarations.length; i++) {
        const declar = node2.declarations[i];
        let enabled = isHelper(declar.id) && !isType2(declar.init);
        if (!enabled && declar.init) {
          const state = crawl(declar.init);
          enabled = isHelper(declar.init) && state.hasCall || state.hasFunction;
        }
        if (enabled) {
          return 1 | 2;
        }
      }
      return 0;
    },
    IfStatement(node2) {
      if (isBlockStatement(node2.consequent)) {
        return 1 | 2;
      }
      return 0;
    }
  };
  nodes.ObjectProperty = nodes.ObjectTypeProperty = nodes.ObjectMethod = function(node2, parent) {
    if (parent.properties[0] === node2) {
      return 1;
    }
    return 0;
  };
  nodes.ObjectTypeCallProperty = function(node2, parent) {
    var _parent$properties;
    if (parent.callProperties[0] === node2 && !((_parent$properties = parent.properties) != null && _parent$properties.length)) {
      return 1;
    }
    return 0;
  };
  nodes.ObjectTypeIndexer = function(node2, parent) {
    var _parent$properties2, _parent$callPropertie;
    if (parent.indexers[0] === node2 && !((_parent$properties2 = parent.properties) != null && _parent$properties2.length) && !((_parent$callPropertie = parent.callProperties) != null && _parent$callPropertie.length)) {
      return 1;
    }
    return 0;
  };
  nodes.ObjectTypeInternalSlot = function(node2, parent) {
    var _parent$properties3, _parent$callPropertie2, _parent$indexers;
    if (parent.internalSlots[0] === node2 && !((_parent$properties3 = parent.properties) != null && _parent$properties3.length) && !((_parent$callPropertie2 = parent.callProperties) != null && _parent$callPropertie2.length) && !((_parent$indexers = parent.indexers) != null && _parent$indexers.length)) {
      return 1;
    }
    return 0;
  };
  [["Function", true], ["Class", true], ["Loop", true], ["LabeledStatement", true], ["SwitchStatement", true], ["TryStatement", true]].forEach(function([type, amounts]) {
    [type].concat(FLIPPED_ALIAS_KEYS[type] || []).forEach(function(type2) {
      const ret = amounts ? 1 | 2 : 0;
      nodes[type2] = () => ret;
    });
  });
  return whitespace;
}
var parentheses = {};
var hasRequiredParentheses;
function requireParentheses() {
  if (hasRequiredParentheses) return parentheses;
  hasRequiredParentheses = 1;
  Object.defineProperty(parentheses, "__esModule", {
    value: true
  });
  parentheses.AssignmentExpression = AssignmentExpression;
  parentheses.Binary = Binary;
  parentheses.BinaryExpression = BinaryExpression;
  parentheses.ClassExpression = ClassExpression;
  parentheses.ArrowFunctionExpression = parentheses.ConditionalExpression = ConditionalExpression;
  parentheses.DoExpression = DoExpression;
  parentheses.FunctionExpression = FunctionExpression;
  parentheses.FunctionTypeAnnotation = FunctionTypeAnnotation;
  parentheses.Identifier = Identifier;
  parentheses.LogicalExpression = LogicalExpression;
  parentheses.NullableTypeAnnotation = NullableTypeAnnotation;
  parentheses.ObjectExpression = ObjectExpression;
  parentheses.OptionalIndexedAccessType = OptionalIndexedAccessType;
  parentheses.OptionalCallExpression = parentheses.OptionalMemberExpression = OptionalMemberExpression;
  parentheses.SequenceExpression = SequenceExpression;
  parentheses.TSSatisfiesExpression = parentheses.TSAsExpression = TSAsExpression;
  parentheses.TSConditionalType = TSConditionalType;
  parentheses.TSConstructorType = parentheses.TSFunctionType = TSFunctionType;
  parentheses.TSInferType = TSInferType;
  parentheses.TSInstantiationExpression = TSInstantiationExpression;
  parentheses.TSIntersectionType = TSIntersectionType;
  parentheses.UnaryLike = parentheses.TSTypeAssertion = UnaryLike;
  parentheses.TSTypeOperator = TSTypeOperator;
  parentheses.TSUnionType = TSUnionType;
  parentheses.IntersectionTypeAnnotation = parentheses.UnionTypeAnnotation = UnionTypeAnnotation;
  parentheses.UpdateExpression = UpdateExpression;
  parentheses.AwaitExpression = parentheses.YieldExpression = YieldExpression;
  var _t = requireLib$4();
  var _index = requireNode();
  const {
    isArrayTypeAnnotation,
    isBinaryExpression,
    isCallExpression,
    isForOfStatement,
    isIndexedAccessType,
    isMemberExpression,
    isObjectPattern,
    isOptionalMemberExpression,
    isYieldExpression,
    isStatement
  } = _t;
  const PRECEDENCE = /* @__PURE__ */ new Map([["||", 0], ["??", 0], ["|>", 0], ["&&", 1], ["|", 2], ["^", 3], ["&", 4], ["==", 5], ["===", 5], ["!=", 5], ["!==", 5], ["<", 6], [">", 6], ["<=", 6], [">=", 6], ["in", 6], ["instanceof", 6], [">>", 7], ["<<", 7], [">>>", 7], ["+", 8], ["-", 8], ["*", 9], ["/", 9], ["%", 9], ["**", 10]]);
  function getBinaryPrecedence(node2, nodeType) {
    if (nodeType === "BinaryExpression" || nodeType === "LogicalExpression") {
      return PRECEDENCE.get(node2.operator);
    }
    if (nodeType === "TSAsExpression" || nodeType === "TSSatisfiesExpression") {
      return PRECEDENCE.get("in");
    }
  }
  function isTSTypeExpression(nodeType) {
    return nodeType === "TSAsExpression" || nodeType === "TSSatisfiesExpression" || nodeType === "TSTypeAssertion";
  }
  const isClassExtendsClause = (node2, parent) => {
    const parentType = parent.type;
    return (parentType === "ClassDeclaration" || parentType === "ClassExpression") && parent.superClass === node2;
  };
  const hasPostfixPart = (node2, parent) => {
    const parentType = parent.type;
    return (parentType === "MemberExpression" || parentType === "OptionalMemberExpression") && parent.object === node2 || (parentType === "CallExpression" || parentType === "OptionalCallExpression" || parentType === "NewExpression") && parent.callee === node2 || parentType === "TaggedTemplateExpression" && parent.tag === node2 || parentType === "TSNonNullExpression";
  };
  function NullableTypeAnnotation(node2, parent) {
    return isArrayTypeAnnotation(parent);
  }
  function FunctionTypeAnnotation(node2, parent, tokenContext) {
    const parentType = parent.type;
    return parentType === "UnionTypeAnnotation" || parentType === "IntersectionTypeAnnotation" || parentType === "ArrayTypeAnnotation" || Boolean(tokenContext & _index.TokenContext.arrowFlowReturnType);
  }
  function UpdateExpression(node2, parent) {
    return hasPostfixPart(node2, parent) || isClassExtendsClause(node2, parent);
  }
  function needsParenBeforeExpressionBrace(tokenContext) {
    return Boolean(tokenContext & (_index.TokenContext.expressionStatement | _index.TokenContext.arrowBody));
  }
  function ObjectExpression(node2, parent, tokenContext) {
    return needsParenBeforeExpressionBrace(tokenContext);
  }
  function DoExpression(node2, parent, tokenContext) {
    return !node2.async && Boolean(tokenContext & _index.TokenContext.expressionStatement);
  }
  function Binary(node2, parent) {
    const parentType = parent.type;
    if (node2.type === "BinaryExpression" && node2.operator === "**" && parentType === "BinaryExpression" && parent.operator === "**") {
      return parent.left === node2;
    }
    if (isClassExtendsClause(node2, parent)) {
      return true;
    }
    if (hasPostfixPart(node2, parent) || parentType === "UnaryExpression" || parentType === "SpreadElement" || parentType === "AwaitExpression") {
      return true;
    }
    const parentPos = getBinaryPrecedence(parent, parentType);
    if (parentPos != null) {
      const nodePos = getBinaryPrecedence(node2, node2.type);
      if (parentPos === nodePos && parentType === "BinaryExpression" && parent.right === node2 || parentPos > nodePos) {
        return true;
      }
    }
  }
  function UnionTypeAnnotation(node2, parent) {
    const parentType = parent.type;
    return parentType === "ArrayTypeAnnotation" || parentType === "NullableTypeAnnotation" || parentType === "IntersectionTypeAnnotation" || parentType === "UnionTypeAnnotation";
  }
  function OptionalIndexedAccessType(node2, parent) {
    return isIndexedAccessType(parent) && parent.objectType === node2;
  }
  function TSAsExpression(node2, parent) {
    if ((parent.type === "AssignmentExpression" || parent.type === "AssignmentPattern") && parent.left === node2) {
      return true;
    }
    if (parent.type === "BinaryExpression" && (parent.operator === "|" || parent.operator === "&") && node2 === parent.left) {
      return true;
    }
    return Binary(node2, parent);
  }
  function TSConditionalType(node2, parent) {
    const parentType = parent.type;
    if (parentType === "TSArrayType" || parentType === "TSIndexedAccessType" && parent.objectType === node2 || parentType === "TSOptionalType" || parentType === "TSTypeOperator" || parentType === "TSTypeParameter") {
      return true;
    }
    if ((parentType === "TSIntersectionType" || parentType === "TSUnionType") && parent.types[0] === node2) {
      return true;
    }
    if (parentType === "TSConditionalType" && (parent.checkType === node2 || parent.extendsType === node2)) {
      return true;
    }
    return false;
  }
  function TSUnionType(node2, parent) {
    const parentType = parent.type;
    return parentType === "TSIntersectionType" || parentType === "TSTypeOperator" || parentType === "TSArrayType" || parentType === "TSIndexedAccessType" && parent.objectType === node2 || parentType === "TSOptionalType";
  }
  function TSIntersectionType(node2, parent) {
    const parentType = parent.type;
    return parentType === "TSTypeOperator" || parentType === "TSArrayType" || parentType === "TSIndexedAccessType" && parent.objectType === node2 || parentType === "TSOptionalType";
  }
  function TSInferType(node2, parent) {
    const parentType = parent.type;
    if (parentType === "TSArrayType" || parentType === "TSIndexedAccessType" && parent.objectType === node2 || parentType === "TSOptionalType") {
      return true;
    }
    if (node2.typeParameter.constraint) {
      if ((parentType === "TSIntersectionType" || parentType === "TSUnionType") && parent.types[0] === node2) {
        return true;
      }
    }
    return false;
  }
  function TSTypeOperator(node2, parent) {
    const parentType = parent.type;
    return parentType === "TSArrayType" || parentType === "TSIndexedAccessType" && parent.objectType === node2 || parentType === "TSOptionalType";
  }
  function TSInstantiationExpression(node2, parent) {
    const parentType = parent.type;
    return (parentType === "CallExpression" || parentType === "OptionalCallExpression" || parentType === "NewExpression" || parentType === "TSInstantiationExpression") && !!parent.typeParameters;
  }
  function TSFunctionType(node2, parent) {
    const parentType = parent.type;
    return parentType === "TSIntersectionType" || parentType === "TSUnionType" || parentType === "TSTypeOperator" || parentType === "TSOptionalType" || parentType === "TSArrayType" || parentType === "TSIndexedAccessType" && parent.objectType === node2 || parentType === "TSConditionalType" && (parent.checkType === node2 || parent.extendsType === node2);
  }
  function BinaryExpression(node2, parent, tokenContext) {
    return node2.operator === "in" && Boolean(tokenContext & _index.TokenContext.forInOrInitHeadAccumulate);
  }
  function SequenceExpression(node2, parent) {
    const parentType = parent.type;
    if (parentType === "SequenceExpression" || parentType === "ParenthesizedExpression" || parentType === "MemberExpression" && parent.property === node2 || parentType === "OptionalMemberExpression" && parent.property === node2 || parentType === "TemplateLiteral") {
      return false;
    }
    if (parentType === "ClassDeclaration") {
      return true;
    }
    if (parentType === "ForOfStatement") {
      return parent.right === node2;
    }
    if (parentType === "ExportDefaultDeclaration") {
      return true;
    }
    return !isStatement(parent);
  }
  function YieldExpression(node2, parent) {
    const parentType = parent.type;
    return parentType === "BinaryExpression" || parentType === "LogicalExpression" || parentType === "UnaryExpression" || parentType === "SpreadElement" || hasPostfixPart(node2, parent) || parentType === "AwaitExpression" && isYieldExpression(node2) || parentType === "ConditionalExpression" && node2 === parent.test || isClassExtendsClause(node2, parent) || isTSTypeExpression(parentType);
  }
  function ClassExpression(node2, parent, tokenContext) {
    return Boolean(tokenContext & (_index.TokenContext.expressionStatement | _index.TokenContext.exportDefault));
  }
  function UnaryLike(node2, parent) {
    return hasPostfixPart(node2, parent) || isBinaryExpression(parent) && parent.operator === "**" && parent.left === node2 || isClassExtendsClause(node2, parent);
  }
  function FunctionExpression(node2, parent, tokenContext) {
    return Boolean(tokenContext & (_index.TokenContext.expressionStatement | _index.TokenContext.exportDefault));
  }
  function ConditionalExpression(node2, parent) {
    const parentType = parent.type;
    if (parentType === "UnaryExpression" || parentType === "SpreadElement" || parentType === "BinaryExpression" || parentType === "LogicalExpression" || parentType === "ConditionalExpression" && parent.test === node2 || parentType === "AwaitExpression" || isTSTypeExpression(parentType)) {
      return true;
    }
    return UnaryLike(node2, parent);
  }
  function OptionalMemberExpression(node2, parent) {
    return isCallExpression(parent) && parent.callee === node2 || isMemberExpression(parent) && parent.object === node2;
  }
  function AssignmentExpression(node2, parent, tokenContext) {
    if (needsParenBeforeExpressionBrace(tokenContext) && isObjectPattern(node2.left)) {
      return true;
    } else {
      return ConditionalExpression(node2, parent);
    }
  }
  function LogicalExpression(node2, parent) {
    const parentType = parent.type;
    if (isTSTypeExpression(parentType)) return true;
    if (parentType !== "LogicalExpression") return false;
    switch (node2.operator) {
      case "||":
        return parent.operator === "??" || parent.operator === "&&";
      case "&&":
        return parent.operator === "??";
      case "??":
        return parent.operator !== "??";
    }
  }
  function Identifier(node2, parent, tokenContext, getRawIdentifier) {
    var _node$extra;
    const parentType = parent.type;
    if ((_node$extra = node2.extra) != null && _node$extra.parenthesized && parentType === "AssignmentExpression" && parent.left === node2) {
      const rightType = parent.right.type;
      if ((rightType === "FunctionExpression" || rightType === "ClassExpression") && parent.right.id == null) {
        return true;
      }
    }
    if (getRawIdentifier && getRawIdentifier(node2) !== node2.name) {
      return false;
    }
    if (node2.name === "let") {
      const isFollowedByBracket = isMemberExpression(parent, {
        object: node2,
        computed: true
      }) || isOptionalMemberExpression(parent, {
        object: node2,
        computed: true,
        optional: false
      });
      if (isFollowedByBracket && tokenContext & (_index.TokenContext.expressionStatement | _index.TokenContext.forInitHead | _index.TokenContext.forInHead)) {
        return true;
      }
      return Boolean(tokenContext & _index.TokenContext.forOfHead);
    }
    return node2.name === "async" && isForOfStatement(parent, {
      left: node2,
      await: false
    });
  }
  return parentheses;
}
var hasRequiredNode;
function requireNode() {
  if (hasRequiredNode) return node;
  hasRequiredNode = 1;
  Object.defineProperty(node, "__esModule", {
    value: true
  });
  node.TokenContext = void 0;
  node.isLastChild = isLastChild;
  node.needsParens = needsParens;
  node.needsWhitespace = needsWhitespace;
  node.needsWhitespaceAfter = needsWhitespaceAfter;
  node.needsWhitespaceBefore = needsWhitespaceBefore;
  var whitespace2 = requireWhitespace();
  var parens = requireParentheses();
  var _t = requireLib$4();
  const {
    FLIPPED_ALIAS_KEYS,
    VISITOR_KEYS,
    isCallExpression,
    isDecorator,
    isExpressionStatement,
    isMemberExpression,
    isNewExpression,
    isParenthesizedExpression
  } = _t;
  node.TokenContext = {
    normal: 0,
    expressionStatement: 1,
    arrowBody: 2,
    exportDefault: 4,
    arrowFlowReturnType: 8,
    forInitHead: 16,
    forInHead: 32,
    forOfHead: 64,
    forInOrInitHeadAccumulate: 128,
    forInOrInitHeadAccumulatePassThroughMask: 128
  };
  function expandAliases(obj) {
    const map = /* @__PURE__ */ new Map();
    function add(type, func) {
      const fn = map.get(type);
      map.set(type, fn ? function(node2, parent, stack, getRawIdentifier) {
        var _fn;
        return (_fn = fn(node2, parent, stack, getRawIdentifier)) != null ? _fn : func(node2, parent, stack, getRawIdentifier);
      } : func);
    }
    for (const type of Object.keys(obj)) {
      const aliases = FLIPPED_ALIAS_KEYS[type];
      if (aliases) {
        for (const alias of aliases) {
          add(alias, obj[type]);
        }
      } else {
        add(type, obj[type]);
      }
    }
    return map;
  }
  const expandedParens = expandAliases(parens);
  const expandedWhitespaceNodes = expandAliases(whitespace2.nodes);
  function isOrHasCallExpression(node2) {
    if (isCallExpression(node2)) {
      return true;
    }
    return isMemberExpression(node2) && isOrHasCallExpression(node2.object);
  }
  function needsWhitespace(node2, parent, type) {
    var _expandedWhitespaceNo;
    if (!node2) return false;
    if (isExpressionStatement(node2)) {
      node2 = node2.expression;
    }
    const flag = (_expandedWhitespaceNo = expandedWhitespaceNodes.get(node2.type)) == null ? void 0 : _expandedWhitespaceNo(node2, parent);
    if (typeof flag === "number") {
      return (flag & type) !== 0;
    }
    return false;
  }
  function needsWhitespaceBefore(node2, parent) {
    return needsWhitespace(node2, parent, 1);
  }
  function needsWhitespaceAfter(node2, parent) {
    return needsWhitespace(node2, parent, 2);
  }
  function needsParens(node2, parent, tokenContext, getRawIdentifier) {
    var _expandedParens$get;
    if (!parent) return false;
    if (isNewExpression(parent) && parent.callee === node2) {
      if (isOrHasCallExpression(node2)) return true;
    }
    if (isDecorator(parent)) {
      return !isDecoratorMemberExpression(node2) && !(isCallExpression(node2) && isDecoratorMemberExpression(node2.callee)) && !isParenthesizedExpression(node2);
    }
    return ((_expandedParens$get = expandedParens.get(node2.type)) == null ? void 0 : _expandedParens$get(node2, parent, tokenContext, getRawIdentifier)) || false;
  }
  function isDecoratorMemberExpression(node2) {
    switch (node2.type) {
      case "Identifier":
        return true;
      case "MemberExpression":
        return !node2.computed && node2.property.type === "Identifier" && isDecoratorMemberExpression(node2.object);
      default:
        return false;
    }
  }
  function isLastChild(parent, child) {
    const visitorKeys = VISITOR_KEYS[parent.type];
    for (let i = visitorKeys.length - 1; i >= 0; i--) {
      const val = parent[visitorKeys[i]];
      if (val === child) {
        return true;
      } else if (Array.isArray(val)) {
        let j = val.length - 1;
        while (j >= 0 && val[j] === null) j--;
        return j >= 0 && val[j] === child;
      } else if (val) {
        return false;
      }
    }
    return false;
  }
  return node;
}
var tokenMap = {};
var hasRequiredTokenMap;
function requireTokenMap() {
  if (hasRequiredTokenMap) return tokenMap;
  hasRequiredTokenMap = 1;
  Object.defineProperty(tokenMap, "__esModule", {
    value: true
  });
  tokenMap.TokenMap = void 0;
  var _t = requireLib$4();
  const {
    traverseFast: traverseFast2,
    VISITOR_KEYS
  } = _t;
  class TokenMap {
    constructor(ast, tokens, source) {
      this._tokens = void 0;
      this._source = void 0;
      this._nodesToTokenIndexes = /* @__PURE__ */ new Map();
      this._nodesOccurrencesCountCache = /* @__PURE__ */ new Map();
      this._tokensCache = /* @__PURE__ */ new Map();
      this._tokens = tokens;
      this._source = source;
      traverseFast2(ast, (node2) => {
        const indexes = this._getTokensIndexesOfNode(node2);
        if (indexes.length > 0) this._nodesToTokenIndexes.set(node2, indexes);
      });
      this._tokensCache.clear();
    }
    has(node2) {
      return this._nodesToTokenIndexes.has(node2);
    }
    getIndexes(node2) {
      return this._nodesToTokenIndexes.get(node2);
    }
    find(node2, condition) {
      const indexes = this._nodesToTokenIndexes.get(node2);
      if (indexes) {
        for (let k = 0; k < indexes.length; k++) {
          const index = indexes[k];
          const tok = this._tokens[index];
          if (condition(tok, index)) return tok;
        }
      }
      return null;
    }
    findLastIndex(node2, condition) {
      const indexes = this._nodesToTokenIndexes.get(node2);
      if (indexes) {
        for (let k = indexes.length - 1; k >= 0; k--) {
          const index = indexes[k];
          const tok = this._tokens[index];
          if (condition(tok, index)) return index;
        }
      }
      return -1;
    }
    findMatching(node2, test, occurrenceCount = 0) {
      const indexes = this._nodesToTokenIndexes.get(node2);
      if (indexes) {
        let i = 0;
        const count = occurrenceCount;
        if (count > 1) {
          const cache2 = this._nodesOccurrencesCountCache.get(node2);
          if (cache2 && cache2.test === test && cache2.count < count) {
            i = cache2.i + 1;
            occurrenceCount -= cache2.count + 1;
          }
        }
        for (; i < indexes.length; i++) {
          const tok = this._tokens[indexes[i]];
          if (this.matchesOriginal(tok, test)) {
            if (occurrenceCount === 0) {
              if (count > 0) {
                this._nodesOccurrencesCountCache.set(node2, {
                  test,
                  count,
                  i
                });
              }
              return tok;
            }
            occurrenceCount--;
          }
        }
      }
      return null;
    }
    matchesOriginal(token, test) {
      if (token.end - token.start !== test.length) return false;
      if (token.value != null) return token.value === test;
      return this._source.startsWith(test, token.start);
    }
    startMatches(node2, test) {
      const indexes = this._nodesToTokenIndexes.get(node2);
      if (!indexes) return false;
      const tok = this._tokens[indexes[0]];
      if (tok.start !== node2.start) return false;
      return this.matchesOriginal(tok, test);
    }
    endMatches(node2, test) {
      const indexes = this._nodesToTokenIndexes.get(node2);
      if (!indexes) return false;
      const tok = this._tokens[indexes[indexes.length - 1]];
      if (tok.end !== node2.end) return false;
      return this.matchesOriginal(tok, test);
    }
    _getTokensIndexesOfNode(node2) {
      if (node2.start == null || node2.end == null) return [];
      const {
        first,
        last
      } = this._findTokensOfNode(node2, 0, this._tokens.length - 1);
      let low = first;
      const children = childrenIterator(node2);
      if ((node2.type === "ExportNamedDeclaration" || node2.type === "ExportDefaultDeclaration") && node2.declaration && node2.declaration.type === "ClassDeclaration") {
        children.next();
      }
      const indexes = [];
      for (const child of children) {
        if (child == null) continue;
        if (child.start == null || child.end == null) continue;
        const childTok = this._findTokensOfNode(child, low, last);
        const high = childTok.first;
        for (let k = low; k < high; k++) indexes.push(k);
        low = childTok.last + 1;
      }
      for (let k = low; k <= last; k++) indexes.push(k);
      return indexes;
    }
    _findTokensOfNode(node2, low, high) {
      const cached = this._tokensCache.get(node2);
      if (cached) return cached;
      const first = this._findFirstTokenOfNode(node2.start, low, high);
      const last = this._findLastTokenOfNode(node2.end, first, high);
      this._tokensCache.set(node2, {
        first,
        last
      });
      return {
        first,
        last
      };
    }
    _findFirstTokenOfNode(start, low, high) {
      while (low <= high) {
        const mid = high + low >> 1;
        if (start < this._tokens[mid].start) {
          high = mid - 1;
        } else if (start > this._tokens[mid].start) {
          low = mid + 1;
        } else {
          return mid;
        }
      }
      return low;
    }
    _findLastTokenOfNode(end, low, high) {
      while (low <= high) {
        const mid = high + low >> 1;
        if (end < this._tokens[mid].end) {
          high = mid - 1;
        } else if (end > this._tokens[mid].end) {
          low = mid + 1;
        } else {
          return mid;
        }
      }
      return high;
    }
  }
  tokenMap.TokenMap = TokenMap;
  function* childrenIterator(node2) {
    if (node2.type === "TemplateLiteral") {
      yield node2.quasis[0];
      for (let i = 1; i < node2.quasis.length; i++) {
        yield node2.expressions[i - 1];
        yield node2.quasis[i];
      }
      return;
    }
    const keys = VISITOR_KEYS[node2.type];
    for (const key of keys) {
      const child = node2[key];
      if (!child) continue;
      if (Array.isArray(child)) {
        yield* child;
      } else {
        yield child;
      }
    }
  }
  return tokenMap;
}
var generators = {};
var templateLiterals = {};
var hasRequiredTemplateLiterals;
function requireTemplateLiterals() {
  if (hasRequiredTemplateLiterals) return templateLiterals;
  hasRequiredTemplateLiterals = 1;
  Object.defineProperty(templateLiterals, "__esModule", {
    value: true
  });
  templateLiterals.TaggedTemplateExpression = TaggedTemplateExpression;
  templateLiterals.TemplateElement = TemplateElement;
  templateLiterals.TemplateLiteral = TemplateLiteral;
  templateLiterals._printTemplate = _printTemplate;
  function TaggedTemplateExpression(node2) {
    this.print(node2.tag);
    {
      this.print(node2.typeParameters);
    }
    this.print(node2.quasi);
  }
  function TemplateElement() {
    throw new Error("TemplateElement printing is handled in TemplateLiteral");
  }
  function _printTemplate(node2, substitutions) {
    const quasis = node2.quasis;
    let partRaw = "`";
    for (let i = 0; i < quasis.length - 1; i++) {
      partRaw += quasis[i].value.raw;
      this.token(partRaw + "${", true);
      this.print(substitutions[i]);
      partRaw = "}";
      if (this.tokenMap) {
        const token = this.tokenMap.findMatching(node2, "}", i);
        if (token) this._catchUpTo(token.loc.start);
      }
    }
    partRaw += quasis[quasis.length - 1].value.raw;
    this.token(partRaw + "`", true);
  }
  function TemplateLiteral(node2) {
    this._printTemplate(node2, node2.expressions);
  }
  return templateLiterals;
}
var expressions = {};
var hasRequiredExpressions;
function requireExpressions() {
  if (hasRequiredExpressions) return expressions;
  hasRequiredExpressions = 1;
  Object.defineProperty(expressions, "__esModule", {
    value: true
  });
  expressions.LogicalExpression = expressions.BinaryExpression = expressions.AssignmentExpression = AssignmentExpression;
  expressions.AssignmentPattern = AssignmentPattern;
  expressions.AwaitExpression = AwaitExpression;
  expressions.BindExpression = BindExpression;
  expressions.CallExpression = CallExpression;
  expressions.ConditionalExpression = ConditionalExpression;
  expressions.Decorator = Decorator;
  expressions.DoExpression = DoExpression;
  expressions.EmptyStatement = EmptyStatement;
  expressions.ExpressionStatement = ExpressionStatement;
  expressions.Import = Import;
  expressions.MemberExpression = MemberExpression;
  expressions.MetaProperty = MetaProperty;
  expressions.ModuleExpression = ModuleExpression;
  expressions.NewExpression = NewExpression;
  expressions.OptionalCallExpression = OptionalCallExpression;
  expressions.OptionalMemberExpression = OptionalMemberExpression;
  expressions.ParenthesizedExpression = ParenthesizedExpression;
  expressions.PrivateName = PrivateName;
  expressions.SequenceExpression = SequenceExpression;
  expressions.Super = Super;
  expressions.ThisExpression = ThisExpression;
  expressions.UnaryExpression = UnaryExpression;
  expressions.UpdateExpression = UpdateExpression;
  expressions.V8IntrinsicIdentifier = V8IntrinsicIdentifier;
  expressions.YieldExpression = YieldExpression;
  expressions._shouldPrintDecoratorsBeforeExport = _shouldPrintDecoratorsBeforeExport;
  var _t = requireLib$4();
  var _index = requireNode();
  const {
    isCallExpression,
    isLiteral,
    isMemberExpression,
    isNewExpression,
    isPattern
  } = _t;
  function UnaryExpression(node2) {
    const {
      operator
    } = node2;
    if (operator === "void" || operator === "delete" || operator === "typeof" || operator === "throw") {
      this.word(operator);
      this.space();
    } else {
      this.token(operator);
    }
    this.print(node2.argument);
  }
  function DoExpression(node2) {
    if (node2.async) {
      this.word("async", true);
      this.space();
    }
    this.word("do");
    this.space();
    this.print(node2.body);
  }
  function ParenthesizedExpression(node2) {
    this.tokenChar(40);
    const exit = this.enterDelimited();
    this.print(node2.expression);
    exit();
    this.rightParens(node2);
  }
  function UpdateExpression(node2) {
    if (node2.prefix) {
      this.token(node2.operator);
      this.print(node2.argument);
    } else {
      this.print(node2.argument, true);
      this.token(node2.operator);
    }
  }
  function ConditionalExpression(node2) {
    this.print(node2.test);
    this.space();
    this.tokenChar(63);
    this.space();
    this.print(node2.consequent);
    this.space();
    this.tokenChar(58);
    this.space();
    this.print(node2.alternate);
  }
  function NewExpression(node2, parent) {
    this.word("new");
    this.space();
    this.print(node2.callee);
    if (this.format.minified && node2.arguments.length === 0 && !node2.optional && !isCallExpression(parent, {
      callee: node2
    }) && !isMemberExpression(parent) && !isNewExpression(parent)) {
      return;
    }
    this.print(node2.typeArguments);
    {
      this.print(node2.typeParameters);
      if (node2.optional) {
        this.token("?.");
      }
    }
    if (node2.arguments.length === 0 && this.tokenMap && !this.tokenMap.endMatches(node2, ")")) {
      return;
    }
    this.tokenChar(40);
    const exit = this.enterDelimited();
    this.printList(node2.arguments, this.shouldPrintTrailingComma(")"));
    exit();
    this.rightParens(node2);
  }
  function SequenceExpression(node2) {
    this.printList(node2.expressions);
  }
  function ThisExpression() {
    this.word("this");
  }
  function Super() {
    this.word("super");
  }
  function _shouldPrintDecoratorsBeforeExport(node2) {
    if (typeof this.format.decoratorsBeforeExport === "boolean") {
      return this.format.decoratorsBeforeExport;
    }
    return typeof node2.start === "number" && node2.start === node2.declaration.start;
  }
  function Decorator(node2) {
    this.tokenChar(64);
    this.print(node2.expression);
    this.newline();
  }
  function OptionalMemberExpression(node2) {
    let {
      computed
    } = node2;
    const {
      optional,
      property
    } = node2;
    this.print(node2.object);
    if (!computed && isMemberExpression(property)) {
      throw new TypeError("Got a MemberExpression for MemberExpression property");
    }
    if (isLiteral(property) && typeof property.value === "number") {
      computed = true;
    }
    if (optional) {
      this.token("?.");
    }
    if (computed) {
      this.tokenChar(91);
      this.print(property);
      this.tokenChar(93);
    } else {
      if (!optional) {
        this.tokenChar(46);
      }
      this.print(property);
    }
  }
  function OptionalCallExpression(node2) {
    this.print(node2.callee);
    {
      this.print(node2.typeParameters);
    }
    if (node2.optional) {
      this.token("?.");
    }
    this.print(node2.typeArguments);
    this.tokenChar(40);
    const exit = this.enterDelimited();
    this.printList(node2.arguments);
    exit();
    this.rightParens(node2);
  }
  function CallExpression(node2) {
    this.print(node2.callee);
    this.print(node2.typeArguments);
    {
      this.print(node2.typeParameters);
    }
    this.tokenChar(40);
    const exit = this.enterDelimited();
    this.printList(node2.arguments, this.shouldPrintTrailingComma(")"));
    exit();
    this.rightParens(node2);
  }
  function Import() {
    this.word("import");
  }
  function AwaitExpression(node2) {
    this.word("await");
    this.space();
    this.print(node2.argument);
  }
  function YieldExpression(node2) {
    if (node2.delegate) {
      this.word("yield", true);
      this.tokenChar(42);
      if (node2.argument) {
        this.space();
        this.print(node2.argument);
      }
    } else if (node2.argument) {
      this.word("yield", true);
      this.space();
      this.print(node2.argument);
    } else {
      this.word("yield");
    }
  }
  function EmptyStatement() {
    this.semicolon(true);
  }
  function ExpressionStatement(node2) {
    this.tokenContext |= _index.TokenContext.expressionStatement;
    this.print(node2.expression);
    this.semicolon();
  }
  function AssignmentPattern(node2) {
    this.print(node2.left);
    if (node2.left.type === "Identifier" || isPattern(node2.left)) {
      if (node2.left.optional) this.tokenChar(63);
      this.print(node2.left.typeAnnotation);
    }
    this.space();
    this.tokenChar(61);
    this.space();
    this.print(node2.right);
  }
  function AssignmentExpression(node2) {
    this.print(node2.left);
    this.space();
    if (node2.operator === "in" || node2.operator === "instanceof") {
      this.word(node2.operator);
    } else {
      this.token(node2.operator);
      this._endsWithDiv = node2.operator === "/";
    }
    this.space();
    this.print(node2.right);
  }
  function BindExpression(node2) {
    this.print(node2.object);
    this.token("::");
    this.print(node2.callee);
  }
  function MemberExpression(node2) {
    this.print(node2.object);
    if (!node2.computed && isMemberExpression(node2.property)) {
      throw new TypeError("Got a MemberExpression for MemberExpression property");
    }
    let computed = node2.computed;
    if (isLiteral(node2.property) && typeof node2.property.value === "number") {
      computed = true;
    }
    if (computed) {
      const exit = this.enterDelimited();
      this.tokenChar(91);
      this.print(node2.property);
      this.tokenChar(93);
      exit();
    } else {
      this.tokenChar(46);
      this.print(node2.property);
    }
  }
  function MetaProperty(node2) {
    this.print(node2.meta);
    this.tokenChar(46);
    this.print(node2.property);
  }
  function PrivateName(node2) {
    this.tokenChar(35);
    this.print(node2.id);
  }
  function V8IntrinsicIdentifier(node2) {
    this.tokenChar(37);
    this.word(node2.name);
  }
  function ModuleExpression(node2) {
    this.word("module", true);
    this.space();
    this.tokenChar(123);
    this.indent();
    const {
      body
    } = node2;
    if (body.body.length || body.directives.length) {
      this.newline();
    }
    this.print(body);
    this.dedent();
    this.rightBrace(node2);
  }
  return expressions;
}
var statements = {};
var hasRequiredStatements;
function requireStatements() {
  if (hasRequiredStatements) return statements;
  hasRequiredStatements = 1;
  Object.defineProperty(statements, "__esModule", {
    value: true
  });
  statements.BreakStatement = BreakStatement;
  statements.CatchClause = CatchClause;
  statements.ContinueStatement = ContinueStatement;
  statements.DebuggerStatement = DebuggerStatement;
  statements.DoWhileStatement = DoWhileStatement;
  statements.ForOfStatement = statements.ForInStatement = void 0;
  statements.ForStatement = ForStatement;
  statements.IfStatement = IfStatement;
  statements.LabeledStatement = LabeledStatement;
  statements.ReturnStatement = ReturnStatement;
  statements.SwitchCase = SwitchCase;
  statements.SwitchStatement = SwitchStatement;
  statements.ThrowStatement = ThrowStatement;
  statements.TryStatement = TryStatement;
  statements.VariableDeclaration = VariableDeclaration;
  statements.VariableDeclarator = VariableDeclarator;
  statements.WhileStatement = WhileStatement;
  statements.WithStatement = WithStatement;
  var _t = requireLib$4();
  const {
    isFor,
    isForStatement,
    isIfStatement,
    isStatement
  } = _t;
  function WithStatement(node2) {
    this.word("with");
    this.space();
    this.tokenChar(40);
    this.print(node2.object);
    this.tokenChar(41);
    this.printBlock(node2);
  }
  function IfStatement(node2) {
    this.word("if");
    this.space();
    this.tokenChar(40);
    this.print(node2.test);
    this.tokenChar(41);
    this.space();
    const needsBlock = node2.alternate && isIfStatement(getLastStatement(node2.consequent));
    if (needsBlock) {
      this.tokenChar(123);
      this.newline();
      this.indent();
    }
    this.printAndIndentOnComments(node2.consequent);
    if (needsBlock) {
      this.dedent();
      this.newline();
      this.tokenChar(125);
    }
    if (node2.alternate) {
      if (this.endsWith(125)) this.space();
      this.word("else");
      this.space();
      this.printAndIndentOnComments(node2.alternate);
    }
  }
  function getLastStatement(statement) {
    const {
      body
    } = statement;
    if (isStatement(body) === false) {
      return statement;
    }
    return getLastStatement(body);
  }
  function ForStatement(node2) {
    this.word("for");
    this.space();
    this.tokenChar(40);
    {
      const exit = this.enterForStatementInit();
      this.print(node2.init);
      exit();
    }
    this.tokenChar(59);
    if (node2.test) {
      this.space();
      this.print(node2.test);
    }
    this.token(";", false, 1);
    if (node2.update) {
      this.space();
      this.print(node2.update);
    }
    this.tokenChar(41);
    this.printBlock(node2);
  }
  function WhileStatement(node2) {
    this.word("while");
    this.space();
    this.tokenChar(40);
    this.print(node2.test);
    this.tokenChar(41);
    this.printBlock(node2);
  }
  function ForXStatement(node2) {
    this.word("for");
    this.space();
    const isForOf = node2.type === "ForOfStatement";
    if (isForOf && node2.await) {
      this.word("await");
      this.space();
    }
    this.noIndentInnerCommentsHere();
    this.tokenChar(40);
    {
      const exit = this.enterForXStatementInit(isForOf);
      this.print(node2.left);
      exit == null || exit();
    }
    this.space();
    this.word(isForOf ? "of" : "in");
    this.space();
    this.print(node2.right);
    this.tokenChar(41);
    this.printBlock(node2);
  }
  statements.ForInStatement = ForXStatement;
  statements.ForOfStatement = ForXStatement;
  function DoWhileStatement(node2) {
    this.word("do");
    this.space();
    this.print(node2.body);
    this.space();
    this.word("while");
    this.space();
    this.tokenChar(40);
    this.print(node2.test);
    this.tokenChar(41);
    this.semicolon();
  }
  function printStatementAfterKeyword(printer2, node2) {
    if (node2) {
      printer2.space();
      printer2.printTerminatorless(node2);
    }
    printer2.semicolon();
  }
  function BreakStatement(node2) {
    this.word("break");
    printStatementAfterKeyword(this, node2.label);
  }
  function ContinueStatement(node2) {
    this.word("continue");
    printStatementAfterKeyword(this, node2.label);
  }
  function ReturnStatement(node2) {
    this.word("return");
    printStatementAfterKeyword(this, node2.argument);
  }
  function ThrowStatement(node2) {
    this.word("throw");
    printStatementAfterKeyword(this, node2.argument);
  }
  function LabeledStatement(node2) {
    this.print(node2.label);
    this.tokenChar(58);
    this.space();
    this.print(node2.body);
  }
  function TryStatement(node2) {
    this.word("try");
    this.space();
    this.print(node2.block);
    this.space();
    if (node2.handlers) {
      this.print(node2.handlers[0]);
    } else {
      this.print(node2.handler);
    }
    if (node2.finalizer) {
      this.space();
      this.word("finally");
      this.space();
      this.print(node2.finalizer);
    }
  }
  function CatchClause(node2) {
    this.word("catch");
    this.space();
    if (node2.param) {
      this.tokenChar(40);
      this.print(node2.param);
      this.print(node2.param.typeAnnotation);
      this.tokenChar(41);
      this.space();
    }
    this.print(node2.body);
  }
  function SwitchStatement(node2) {
    this.word("switch");
    this.space();
    this.tokenChar(40);
    this.print(node2.discriminant);
    this.tokenChar(41);
    this.space();
    this.tokenChar(123);
    this.printSequence(node2.cases, true);
    this.rightBrace(node2);
  }
  function SwitchCase(node2) {
    if (node2.test) {
      this.word("case");
      this.space();
      this.print(node2.test);
      this.tokenChar(58);
    } else {
      this.word("default");
      this.tokenChar(58);
    }
    if (node2.consequent.length) {
      this.newline();
      this.printSequence(node2.consequent, true);
    }
  }
  function DebuggerStatement() {
    this.word("debugger");
    this.semicolon();
  }
  function VariableDeclaration(node2, parent) {
    if (node2.declare) {
      this.word("declare");
      this.space();
    }
    const {
      kind
    } = node2;
    if (kind === "await using") {
      this.word("await");
      this.space();
      this.word("using", true);
    } else {
      this.word(kind, kind === "using");
    }
    this.space();
    let hasInits = false;
    if (!isFor(parent)) {
      for (const declar of node2.declarations) {
        if (declar.init) {
          hasInits = true;
        }
      }
    }
    this.printList(node2.declarations, void 0, void 0, node2.declarations.length > 1, hasInits ? function(occurrenceCount) {
      this.token(",", false, occurrenceCount);
      this.newline();
    } : void 0);
    if (isFor(parent)) {
      if (isForStatement(parent)) {
        if (parent.init === node2) return;
      } else {
        if (parent.left === node2) return;
      }
    }
    this.semicolon();
  }
  function VariableDeclarator(node2) {
    this.print(node2.id);
    if (node2.definite) this.tokenChar(33);
    this.print(node2.id.typeAnnotation);
    if (node2.init) {
      this.space();
      this.tokenChar(61);
      this.space();
      this.print(node2.init);
    }
  }
  return statements;
}
var classes = {};
var hasRequiredClasses;
function requireClasses() {
  if (hasRequiredClasses) return classes;
  hasRequiredClasses = 1;
  Object.defineProperty(classes, "__esModule", {
    value: true
  });
  classes.ClassAccessorProperty = ClassAccessorProperty;
  classes.ClassBody = ClassBody;
  classes.ClassExpression = classes.ClassDeclaration = ClassDeclaration;
  classes.ClassMethod = ClassMethod;
  classes.ClassPrivateMethod = ClassPrivateMethod;
  classes.ClassPrivateProperty = ClassPrivateProperty;
  classes.ClassProperty = ClassProperty;
  classes.StaticBlock = StaticBlock;
  classes._classMethodHead = _classMethodHead;
  var _t = requireLib$4();
  const {
    isExportDefaultDeclaration,
    isExportNamedDeclaration
  } = _t;
  function ClassDeclaration(node2, parent) {
    const inExport = isExportDefaultDeclaration(parent) || isExportNamedDeclaration(parent);
    if (!inExport || !this._shouldPrintDecoratorsBeforeExport(parent)) {
      this.printJoin(node2.decorators);
    }
    if (node2.declare) {
      this.word("declare");
      this.space();
    }
    if (node2.abstract) {
      this.word("abstract");
      this.space();
    }
    this.word("class");
    if (node2.id) {
      this.space();
      this.print(node2.id);
    }
    this.print(node2.typeParameters);
    if (node2.superClass) {
      this.space();
      this.word("extends");
      this.space();
      this.print(node2.superClass);
      this.print(node2.superTypeParameters);
    }
    if (node2.implements) {
      this.space();
      this.word("implements");
      this.space();
      this.printList(node2.implements);
    }
    this.space();
    this.print(node2.body);
  }
  function ClassBody(node2) {
    this.tokenChar(123);
    if (node2.body.length === 0) {
      this.tokenChar(125);
    } else {
      this.newline();
      const separator = classBodyEmptySemicolonsPrinter(this, node2);
      separator == null || separator(-1);
      const exit = this.enterDelimited();
      this.printJoin(node2.body, true, true, separator, true);
      exit();
      if (!this.endsWith(10)) this.newline();
      this.rightBrace(node2);
    }
  }
  function classBodyEmptySemicolonsPrinter(printer2, node2) {
    if (!printer2.tokenMap || node2.start == null || node2.end == null) {
      return null;
    }
    const indexes = printer2.tokenMap.getIndexes(node2);
    if (!indexes) return null;
    let k = 1;
    let occurrenceCount = 0;
    let nextLocIndex = 0;
    const advanceNextLocIndex = () => {
      while (nextLocIndex < node2.body.length && node2.body[nextLocIndex].start == null) {
        nextLocIndex++;
      }
    };
    advanceNextLocIndex();
    return (i) => {
      if (nextLocIndex <= i) {
        nextLocIndex = i + 1;
        advanceNextLocIndex();
      }
      const end = nextLocIndex === node2.body.length ? node2.end : node2.body[nextLocIndex].start;
      let tok;
      while (k < indexes.length && printer2.tokenMap.matchesOriginal(tok = printer2._tokens[indexes[k]], ";") && tok.start < end) {
        printer2.token(";", void 0, occurrenceCount++);
        k++;
      }
    };
  }
  function ClassProperty(node2) {
    this.printJoin(node2.decorators);
    if (!node2.static && !this.format.preserveFormat) {
      var _node$key$loc;
      const endLine = (_node$key$loc = node2.key.loc) == null || (_node$key$loc = _node$key$loc.end) == null ? void 0 : _node$key$loc.line;
      if (endLine) this.catchUp(endLine);
    }
    this.tsPrintClassMemberModifiers(node2);
    if (node2.computed) {
      this.tokenChar(91);
      this.print(node2.key);
      this.tokenChar(93);
    } else {
      this._variance(node2);
      this.print(node2.key);
    }
    if (node2.optional) {
      this.tokenChar(63);
    }
    if (node2.definite) {
      this.tokenChar(33);
    }
    this.print(node2.typeAnnotation);
    if (node2.value) {
      this.space();
      this.tokenChar(61);
      this.space();
      this.print(node2.value);
    }
    this.semicolon();
  }
  function ClassAccessorProperty(node2) {
    var _node$key$loc2;
    this.printJoin(node2.decorators);
    const endLine = (_node$key$loc2 = node2.key.loc) == null || (_node$key$loc2 = _node$key$loc2.end) == null ? void 0 : _node$key$loc2.line;
    if (endLine) this.catchUp(endLine);
    this.tsPrintClassMemberModifiers(node2);
    this.word("accessor", true);
    this.space();
    if (node2.computed) {
      this.tokenChar(91);
      this.print(node2.key);
      this.tokenChar(93);
    } else {
      this._variance(node2);
      this.print(node2.key);
    }
    if (node2.optional) {
      this.tokenChar(63);
    }
    if (node2.definite) {
      this.tokenChar(33);
    }
    this.print(node2.typeAnnotation);
    if (node2.value) {
      this.space();
      this.tokenChar(61);
      this.space();
      this.print(node2.value);
    }
    this.semicolon();
  }
  function ClassPrivateProperty(node2) {
    this.printJoin(node2.decorators);
    this.tsPrintClassMemberModifiers(node2);
    this.print(node2.key);
    if (node2.optional) {
      this.tokenChar(63);
    }
    if (node2.definite) {
      this.tokenChar(33);
    }
    this.print(node2.typeAnnotation);
    if (node2.value) {
      this.space();
      this.tokenChar(61);
      this.space();
      this.print(node2.value);
    }
    this.semicolon();
  }
  function ClassMethod(node2) {
    this._classMethodHead(node2);
    this.space();
    this.print(node2.body);
  }
  function ClassPrivateMethod(node2) {
    this._classMethodHead(node2);
    this.space();
    this.print(node2.body);
  }
  function _classMethodHead(node2) {
    this.printJoin(node2.decorators);
    if (!this.format.preserveFormat) {
      var _node$key$loc3;
      const endLine = (_node$key$loc3 = node2.key.loc) == null || (_node$key$loc3 = _node$key$loc3.end) == null ? void 0 : _node$key$loc3.line;
      if (endLine) this.catchUp(endLine);
    }
    this.tsPrintClassMemberModifiers(node2);
    this._methodHead(node2);
  }
  function StaticBlock(node2) {
    this.word("static");
    this.space();
    this.tokenChar(123);
    if (node2.body.length === 0) {
      this.tokenChar(125);
    } else {
      this.newline();
      this.printSequence(node2.body, true);
      this.rightBrace(node2);
    }
  }
  return classes;
}
var methods = {};
var hasRequiredMethods;
function requireMethods() {
  if (hasRequiredMethods) return methods;
  hasRequiredMethods = 1;
  Object.defineProperty(methods, "__esModule", {
    value: true
  });
  methods.ArrowFunctionExpression = ArrowFunctionExpression;
  methods.FunctionDeclaration = methods.FunctionExpression = FunctionExpression;
  methods._functionHead = _functionHead;
  methods._methodHead = _methodHead;
  methods._param = _param;
  methods._parameters = _parameters;
  methods._params = _params;
  methods._predicate = _predicate;
  methods._shouldPrintArrowParamsParens = _shouldPrintArrowParamsParens;
  var _t = requireLib$4();
  var _index = requireNode();
  const {
    isIdentifier
  } = _t;
  function _params(node2, idNode, parentNode) {
    this.print(node2.typeParameters);
    const nameInfo = _getFuncIdName.call(this, idNode, parentNode);
    if (nameInfo) {
      this.sourceIdentifierName(nameInfo.name, nameInfo.pos);
    }
    this.tokenChar(40);
    this._parameters(node2.params, ")");
    const noLineTerminator = node2.type === "ArrowFunctionExpression";
    this.print(node2.returnType, noLineTerminator);
    this._noLineTerminator = noLineTerminator;
  }
  function _parameters(parameters, endToken) {
    const exit = this.enterDelimited();
    const trailingComma = this.shouldPrintTrailingComma(endToken);
    const paramLength = parameters.length;
    for (let i = 0; i < paramLength; i++) {
      this._param(parameters[i]);
      if (trailingComma || i < paramLength - 1) {
        this.token(",", void 0, i);
        this.space();
      }
    }
    this.token(endToken);
    exit();
  }
  function _param(parameter) {
    this.printJoin(parameter.decorators);
    this.print(parameter);
    if (parameter.optional) {
      this.tokenChar(63);
    }
    this.print(parameter.typeAnnotation);
  }
  function _methodHead(node2) {
    const kind = node2.kind;
    const key = node2.key;
    if (kind === "get" || kind === "set") {
      this.word(kind);
      this.space();
    }
    if (node2.async) {
      this.word("async", true);
      this.space();
    }
    if (kind === "method" || kind === "init") {
      if (node2.generator) {
        this.tokenChar(42);
      }
    }
    if (node2.computed) {
      this.tokenChar(91);
      this.print(key);
      this.tokenChar(93);
    } else {
      this.print(key);
    }
    if (node2.optional) {
      this.tokenChar(63);
    }
    this._params(node2, node2.computed && node2.key.type !== "StringLiteral" ? void 0 : node2.key);
  }
  function _predicate(node2, noLineTerminatorAfter) {
    if (node2.predicate) {
      if (!node2.returnType) {
        this.tokenChar(58);
      }
      this.space();
      this.print(node2.predicate, noLineTerminatorAfter);
    }
  }
  function _functionHead(node2, parent) {
    if (node2.async) {
      this.word("async");
      if (!this.format.preserveFormat) {
        this._endsWithInnerRaw = false;
      }
      this.space();
    }
    this.word("function");
    if (node2.generator) {
      if (!this.format.preserveFormat) {
        this._endsWithInnerRaw = false;
      }
      this.tokenChar(42);
    }
    this.space();
    if (node2.id) {
      this.print(node2.id);
    }
    this._params(node2, node2.id, parent);
    if (node2.type !== "TSDeclareFunction") {
      this._predicate(node2);
    }
  }
  function FunctionExpression(node2, parent) {
    this._functionHead(node2, parent);
    this.space();
    this.print(node2.body);
  }
  function ArrowFunctionExpression(node2, parent) {
    if (node2.async) {
      this.word("async", true);
      this.space();
    }
    if (this._shouldPrintArrowParamsParens(node2)) {
      this._params(node2, void 0, parent);
    } else {
      this.print(node2.params[0], true);
    }
    this._predicate(node2, true);
    this.space();
    this.printInnerComments();
    this.token("=>");
    this.space();
    this.tokenContext |= _index.TokenContext.arrowBody;
    this.print(node2.body);
  }
  function _shouldPrintArrowParamsParens(node2) {
    var _firstParam$leadingCo, _firstParam$trailingC;
    if (node2.params.length !== 1) return true;
    if (node2.typeParameters || node2.returnType || node2.predicate) {
      return true;
    }
    const firstParam = node2.params[0];
    if (!isIdentifier(firstParam) || firstParam.typeAnnotation || firstParam.optional || (_firstParam$leadingCo = firstParam.leadingComments) != null && _firstParam$leadingCo.length || (_firstParam$trailingC = firstParam.trailingComments) != null && _firstParam$trailingC.length) {
      return true;
    }
    if (this.tokenMap) {
      if (node2.loc == null) return true;
      if (this.tokenMap.findMatching(node2, "(") !== null) return true;
      const arrowToken = this.tokenMap.findMatching(node2, "=>");
      if ((arrowToken == null ? void 0 : arrowToken.loc) == null) return true;
      return arrowToken.loc.start.line !== node2.loc.start.line;
    }
    if (this.format.retainLines) return true;
    return false;
  }
  function _getFuncIdName(idNode, parent) {
    let id = idNode;
    if (!id && parent) {
      const parentType = parent.type;
      if (parentType === "VariableDeclarator") {
        id = parent.id;
      } else if (parentType === "AssignmentExpression" || parentType === "AssignmentPattern") {
        id = parent.left;
      } else if (parentType === "ObjectProperty" || parentType === "ClassProperty") {
        if (!parent.computed || parent.key.type === "StringLiteral") {
          id = parent.key;
        }
      } else if (parentType === "ClassPrivateProperty" || parentType === "ClassAccessorProperty") {
        id = parent.key;
      }
    }
    if (!id) return;
    let nameInfo;
    if (id.type === "Identifier") {
      var _id$loc, _id$loc2;
      nameInfo = {
        pos: (_id$loc = id.loc) == null ? void 0 : _id$loc.start,
        name: ((_id$loc2 = id.loc) == null ? void 0 : _id$loc2.identifierName) || id.name
      };
    } else if (id.type === "PrivateName") {
      var _id$loc3;
      nameInfo = {
        pos: (_id$loc3 = id.loc) == null ? void 0 : _id$loc3.start,
        name: "#" + id.id.name
      };
    } else if (id.type === "StringLiteral") {
      var _id$loc4;
      nameInfo = {
        pos: (_id$loc4 = id.loc) == null ? void 0 : _id$loc4.start,
        name: id.value
      };
    }
    return nameInfo;
  }
  return methods;
}
var modules = {};
var hasRequiredModules;
function requireModules() {
  if (hasRequiredModules) return modules;
  hasRequiredModules = 1;
  Object.defineProperty(modules, "__esModule", {
    value: true
  });
  modules.ExportAllDeclaration = ExportAllDeclaration;
  modules.ExportDefaultDeclaration = ExportDefaultDeclaration;
  modules.ExportDefaultSpecifier = ExportDefaultSpecifier;
  modules.ExportNamedDeclaration = ExportNamedDeclaration;
  modules.ExportNamespaceSpecifier = ExportNamespaceSpecifier;
  modules.ExportSpecifier = ExportSpecifier;
  modules.ImportAttribute = ImportAttribute;
  modules.ImportDeclaration = ImportDeclaration;
  modules.ImportDefaultSpecifier = ImportDefaultSpecifier;
  modules.ImportExpression = ImportExpression;
  modules.ImportNamespaceSpecifier = ImportNamespaceSpecifier;
  modules.ImportSpecifier = ImportSpecifier;
  modules._printAttributes = _printAttributes;
  var _t = requireLib$4();
  var _index = requireNode();
  const {
    isClassDeclaration,
    isExportDefaultSpecifier,
    isExportNamespaceSpecifier,
    isImportDefaultSpecifier,
    isImportNamespaceSpecifier,
    isStatement
  } = _t;
  function ImportSpecifier(node2) {
    if (node2.importKind === "type" || node2.importKind === "typeof") {
      this.word(node2.importKind);
      this.space();
    }
    this.print(node2.imported);
    if (node2.local && node2.local.name !== node2.imported.name) {
      this.space();
      this.word("as");
      this.space();
      this.print(node2.local);
    }
  }
  function ImportDefaultSpecifier(node2) {
    this.print(node2.local);
  }
  function ExportDefaultSpecifier(node2) {
    this.print(node2.exported);
  }
  function ExportSpecifier(node2) {
    if (node2.exportKind === "type") {
      this.word("type");
      this.space();
    }
    this.print(node2.local);
    if (node2.exported && node2.local.name !== node2.exported.name) {
      this.space();
      this.word("as");
      this.space();
      this.print(node2.exported);
    }
  }
  function ExportNamespaceSpecifier(node2) {
    this.tokenChar(42);
    this.space();
    this.word("as");
    this.space();
    this.print(node2.exported);
  }
  let warningShown = false;
  function _printAttributes(node2, hasPreviousBrace) {
    var _node$extra;
    const {
      importAttributesKeyword
    } = this.format;
    const {
      attributes,
      assertions
    } = node2;
    if (attributes && !importAttributesKeyword && node2.extra && (node2.extra.deprecatedAssertSyntax || node2.extra.deprecatedWithLegacySyntax) && !warningShown) {
      warningShown = true;
      console.warn(`You are using import attributes, without specifying the desired output syntax.
Please specify the "importAttributesKeyword" generator option, whose value can be one of:
 - "with"        : \`import { a } from "b" with { type: "json" };\`
 - "assert"      : \`import { a } from "b" assert { type: "json" };\`
 - "with-legacy" : \`import { a } from "b" with type: "json";\`
`);
    }
    const useAssertKeyword = importAttributesKeyword === "assert" || !importAttributesKeyword && assertions;
    this.word(useAssertKeyword ? "assert" : "with");
    this.space();
    if (!useAssertKeyword && (importAttributesKeyword === "with-legacy" || !importAttributesKeyword && (_node$extra = node2.extra) != null && _node$extra.deprecatedWithLegacySyntax)) {
      this.printList(attributes || assertions);
      return;
    }
    const occurrenceCount = hasPreviousBrace ? 1 : 0;
    this.token("{", void 0, occurrenceCount);
    this.space();
    this.printList(attributes || assertions, this.shouldPrintTrailingComma("}"));
    this.space();
    this.token("}", void 0, occurrenceCount);
  }
  function ExportAllDeclaration(node2) {
    var _node$attributes, _node$assertions;
    this.word("export");
    this.space();
    if (node2.exportKind === "type") {
      this.word("type");
      this.space();
    }
    this.tokenChar(42);
    this.space();
    this.word("from");
    this.space();
    if ((_node$attributes = node2.attributes) != null && _node$attributes.length || (_node$assertions = node2.assertions) != null && _node$assertions.length) {
      this.print(node2.source, true);
      this.space();
      this._printAttributes(node2, false);
    } else {
      this.print(node2.source);
    }
    this.semicolon();
  }
  function maybePrintDecoratorsBeforeExport(printer2, node2) {
    if (isClassDeclaration(node2.declaration) && printer2._shouldPrintDecoratorsBeforeExport(node2)) {
      printer2.printJoin(node2.declaration.decorators);
    }
  }
  function ExportNamedDeclaration(node2) {
    maybePrintDecoratorsBeforeExport(this, node2);
    this.word("export");
    this.space();
    if (node2.declaration) {
      const declar = node2.declaration;
      this.print(declar);
      if (!isStatement(declar)) this.semicolon();
    } else {
      if (node2.exportKind === "type") {
        this.word("type");
        this.space();
      }
      const specifiers = node2.specifiers.slice(0);
      let hasSpecial = false;
      for (; ; ) {
        const first = specifiers[0];
        if (isExportDefaultSpecifier(first) || isExportNamespaceSpecifier(first)) {
          hasSpecial = true;
          this.print(specifiers.shift());
          if (specifiers.length) {
            this.tokenChar(44);
            this.space();
          }
        } else {
          break;
        }
      }
      let hasBrace = false;
      if (specifiers.length || !specifiers.length && !hasSpecial) {
        hasBrace = true;
        this.tokenChar(123);
        if (specifiers.length) {
          this.space();
          this.printList(specifiers, this.shouldPrintTrailingComma("}"));
          this.space();
        }
        this.tokenChar(125);
      }
      if (node2.source) {
        var _node$attributes2, _node$assertions2;
        this.space();
        this.word("from");
        this.space();
        if ((_node$attributes2 = node2.attributes) != null && _node$attributes2.length || (_node$assertions2 = node2.assertions) != null && _node$assertions2.length) {
          this.print(node2.source, true);
          this.space();
          this._printAttributes(node2, hasBrace);
        } else {
          this.print(node2.source);
        }
      }
      this.semicolon();
    }
  }
  function ExportDefaultDeclaration(node2) {
    maybePrintDecoratorsBeforeExport(this, node2);
    this.word("export");
    this.noIndentInnerCommentsHere();
    this.space();
    this.word("default");
    this.space();
    this.tokenContext |= _index.TokenContext.exportDefault;
    const declar = node2.declaration;
    this.print(declar);
    if (!isStatement(declar)) this.semicolon();
  }
  function ImportDeclaration(node2) {
    var _node$attributes3, _node$assertions3;
    this.word("import");
    this.space();
    const isTypeKind = node2.importKind === "type" || node2.importKind === "typeof";
    if (isTypeKind) {
      this.noIndentInnerCommentsHere();
      this.word(node2.importKind);
      this.space();
    } else if (node2.module) {
      this.noIndentInnerCommentsHere();
      this.word("module");
      this.space();
    } else if (node2.phase) {
      this.noIndentInnerCommentsHere();
      this.word(node2.phase);
      this.space();
    }
    const specifiers = node2.specifiers.slice(0);
    const hasSpecifiers = !!specifiers.length;
    while (hasSpecifiers) {
      const first = specifiers[0];
      if (isImportDefaultSpecifier(first) || isImportNamespaceSpecifier(first)) {
        this.print(specifiers.shift());
        if (specifiers.length) {
          this.tokenChar(44);
          this.space();
        }
      } else {
        break;
      }
    }
    let hasBrace = false;
    if (specifiers.length) {
      hasBrace = true;
      this.tokenChar(123);
      this.space();
      this.printList(specifiers, this.shouldPrintTrailingComma("}"));
      this.space();
      this.tokenChar(125);
    } else if (isTypeKind && !hasSpecifiers) {
      hasBrace = true;
      this.tokenChar(123);
      this.tokenChar(125);
    }
    if (hasSpecifiers || isTypeKind) {
      this.space();
      this.word("from");
      this.space();
    }
    if ((_node$attributes3 = node2.attributes) != null && _node$attributes3.length || (_node$assertions3 = node2.assertions) != null && _node$assertions3.length) {
      this.print(node2.source, true);
      this.space();
      this._printAttributes(node2, hasBrace);
    } else {
      this.print(node2.source);
    }
    this.semicolon();
  }
  function ImportAttribute(node2) {
    this.print(node2.key);
    this.tokenChar(58);
    this.space();
    this.print(node2.value);
  }
  function ImportNamespaceSpecifier(node2) {
    this.tokenChar(42);
    this.space();
    this.word("as");
    this.space();
    this.print(node2.local);
  }
  function ImportExpression(node2) {
    this.word("import");
    if (node2.phase) {
      this.tokenChar(46);
      this.word(node2.phase);
    }
    this.tokenChar(40);
    const shouldPrintTrailingComma = this.shouldPrintTrailingComma(")");
    this.print(node2.source);
    if (node2.options != null) {
      this.tokenChar(44);
      this.space();
      this.print(node2.options);
    }
    if (shouldPrintTrailingComma) {
      this.tokenChar(44);
    }
    this.rightParens(node2);
  }
  return modules;
}
var types = {};
var jsesc_1;
var hasRequiredJsesc;
function requireJsesc() {
  if (hasRequiredJsesc) return jsesc_1;
  hasRequiredJsesc = 1;
  const object = {};
  const hasOwnProperty2 = object.hasOwnProperty;
  const forOwn = (object2, callback) => {
    for (const key in object2) {
      if (hasOwnProperty2.call(object2, key)) {
        callback(key, object2[key]);
      }
    }
  };
  const extend = (destination, source) => {
    if (!source) {
      return destination;
    }
    forOwn(source, (key, value) => {
      destination[key] = value;
    });
    return destination;
  };
  const forEach = (array, callback) => {
    const length = array.length;
    let index = -1;
    while (++index < length) {
      callback(array[index]);
    }
  };
  const fourHexEscape = (hex) => {
    return "\\u" + ("0000" + hex).slice(-4);
  };
  const hexadecimal = (code, lowercase2) => {
    let hexadecimal2 = code.toString(16);
    if (lowercase2) return hexadecimal2;
    return hexadecimal2.toUpperCase();
  };
  const toString = object.toString;
  const isArray = Array.isArray;
  const isBuffer = (value) => {
    return typeof Buffer === "function" && Buffer.isBuffer(value);
  };
  const isObject = (value) => {
    return toString.call(value) == "[object Object]";
  };
  const isString = (value) => {
    return typeof value == "string" || toString.call(value) == "[object String]";
  };
  const isNumber = (value) => {
    return typeof value == "number" || toString.call(value) == "[object Number]";
  };
  const isBigInt = (value) => {
    return typeof value == "bigint";
  };
  const isFunction = (value) => {
    return typeof value == "function";
  };
  const isMap = (value) => {
    return toString.call(value) == "[object Map]";
  };
  const isSet = (value) => {
    return toString.call(value) == "[object Set]";
  };
  const singleEscapes = {
    "\\": "\\\\",
    "\b": "\\b",
    "\f": "\\f",
    "\n": "\\n",
    "\r": "\\r",
    "	": "\\t"
    // `\v` is omitted intentionally, because in IE < 9, '\v' == 'v'.
    // '\v': '\\x0B'
  };
  const regexSingleEscape = /[\\\b\f\n\r\t]/;
  const regexDigit = /[0-9]/;
  const regexWhitespace = /[\xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;
  const escapeEverythingRegex = /([\uD800-\uDBFF][\uDC00-\uDFFF])|([\uD800-\uDFFF])|(['"`])|[^]/g;
  const escapeNonAsciiRegex = /([\uD800-\uDBFF][\uDC00-\uDFFF])|([\uD800-\uDFFF])|(['"`])|[^ !#-&\(-\[\]-_a-~]/g;
  const jsesc = (argument, options2) => {
    const increaseIndentation = () => {
      oldIndent = indent;
      ++options2.indentLevel;
      indent = options2.indent.repeat(options2.indentLevel);
    };
    const defaults = {
      "escapeEverything": false,
      "minimal": false,
      "isScriptContext": false,
      "quotes": "single",
      "wrap": false,
      "es6": false,
      "json": false,
      "compact": true,
      "lowercaseHex": false,
      "numbers": "decimal",
      "indent": "	",
      "indentLevel": 0,
      "__inline1__": false,
      "__inline2__": false
    };
    const json = options2 && options2.json;
    if (json) {
      defaults.quotes = "double";
      defaults.wrap = true;
    }
    options2 = extend(defaults, options2);
    if (options2.quotes != "single" && options2.quotes != "double" && options2.quotes != "backtick") {
      options2.quotes = "single";
    }
    const quote = options2.quotes == "double" ? '"' : options2.quotes == "backtick" ? "`" : "'";
    const compact = options2.compact;
    const lowercaseHex = options2.lowercaseHex;
    let indent = options2.indent.repeat(options2.indentLevel);
    let oldIndent = "";
    const inline1 = options2.__inline1__;
    const inline2 = options2.__inline2__;
    const newLine = compact ? "" : "\n";
    let result;
    let isEmpty = true;
    const useBinNumbers = options2.numbers == "binary";
    const useOctNumbers = options2.numbers == "octal";
    const useDecNumbers = options2.numbers == "decimal";
    const useHexNumbers = options2.numbers == "hexadecimal";
    if (json && argument && isFunction(argument.toJSON)) {
      argument = argument.toJSON();
    }
    if (!isString(argument)) {
      if (isMap(argument)) {
        if (argument.size == 0) {
          return "new Map()";
        }
        if (!compact) {
          options2.__inline1__ = true;
          options2.__inline2__ = false;
        }
        return "new Map(" + jsesc(Array.from(argument), options2) + ")";
      }
      if (isSet(argument)) {
        if (argument.size == 0) {
          return "new Set()";
        }
        return "new Set(" + jsesc(Array.from(argument), options2) + ")";
      }
      if (isBuffer(argument)) {
        if (argument.length == 0) {
          return "Buffer.from([])";
        }
        return "Buffer.from(" + jsesc(Array.from(argument), options2) + ")";
      }
      if (isArray(argument)) {
        result = [];
        options2.wrap = true;
        if (inline1) {
          options2.__inline1__ = false;
          options2.__inline2__ = true;
        }
        if (!inline2) {
          increaseIndentation();
        }
        forEach(argument, (value) => {
          isEmpty = false;
          if (inline2) {
            options2.__inline2__ = false;
          }
          result.push(
            (compact || inline2 ? "" : indent) + jsesc(value, options2)
          );
        });
        if (isEmpty) {
          return "[]";
        }
        if (inline2) {
          return "[" + result.join(", ") + "]";
        }
        return "[" + newLine + result.join("," + newLine) + newLine + (compact ? "" : oldIndent) + "]";
      } else if (isNumber(argument) || isBigInt(argument)) {
        if (json) {
          return JSON.stringify(Number(argument));
        }
        let result2;
        if (useDecNumbers) {
          result2 = String(argument);
        } else if (useHexNumbers) {
          let hexadecimal2 = argument.toString(16);
          if (!lowercaseHex) {
            hexadecimal2 = hexadecimal2.toUpperCase();
          }
          result2 = "0x" + hexadecimal2;
        } else if (useBinNumbers) {
          result2 = "0b" + argument.toString(2);
        } else if (useOctNumbers) {
          result2 = "0o" + argument.toString(8);
        }
        if (isBigInt(argument)) {
          return result2 + "n";
        }
        return result2;
      } else if (isBigInt(argument)) {
        if (json) {
          return JSON.stringify(Number(argument));
        }
        return argument + "n";
      } else if (!isObject(argument)) {
        if (json) {
          return JSON.stringify(argument) || "null";
        }
        return String(argument);
      } else {
        result = [];
        options2.wrap = true;
        increaseIndentation();
        forOwn(argument, (key, value) => {
          isEmpty = false;
          result.push(
            (compact ? "" : indent) + jsesc(key, options2) + ":" + (compact ? "" : " ") + jsesc(value, options2)
          );
        });
        if (isEmpty) {
          return "{}";
        }
        return "{" + newLine + result.join("," + newLine) + newLine + (compact ? "" : oldIndent) + "}";
      }
    }
    const regex = options2.escapeEverything ? escapeEverythingRegex : escapeNonAsciiRegex;
    result = argument.replace(regex, (char, pair, lone, quoteChar, index, string2) => {
      if (pair) {
        if (options2.minimal) return pair;
        const first = pair.charCodeAt(0);
        const second = pair.charCodeAt(1);
        if (options2.es6) {
          const codePoint = (first - 55296) * 1024 + second - 56320 + 65536;
          const hex2 = hexadecimal(codePoint, lowercaseHex);
          return "\\u{" + hex2 + "}";
        }
        return fourHexEscape(hexadecimal(first, lowercaseHex)) + fourHexEscape(hexadecimal(second, lowercaseHex));
      }
      if (lone) {
        return fourHexEscape(hexadecimal(lone.charCodeAt(0), lowercaseHex));
      }
      if (char == "\0" && !json && !regexDigit.test(string2.charAt(index + 1))) {
        return "\\0";
      }
      if (quoteChar) {
        if (quoteChar == quote || options2.escapeEverything) {
          return "\\" + quoteChar;
        }
        return quoteChar;
      }
      if (regexSingleEscape.test(char)) {
        return singleEscapes[char];
      }
      if (options2.minimal && !regexWhitespace.test(char)) {
        return char;
      }
      const hex = hexadecimal(char.charCodeAt(0), lowercaseHex);
      if (json || hex.length > 2) {
        return fourHexEscape(hex);
      }
      return "\\x" + ("00" + hex).slice(-2);
    });
    if (quote == "`") {
      result = result.replace(/\$\{/g, "\\${");
    }
    if (options2.isScriptContext) {
      result = result.replace(/<\/(script|style)/gi, "<\\/$1").replace(/<!--/g, json ? "\\u003C!--" : "\\x3C!--");
    }
    if (options2.wrap) {
      result = quote + result + quote;
    }
    return result;
  };
  jsesc.version = "3.0.2";
  jsesc_1 = jsesc;
  return jsesc_1;
}
var hasRequiredTypes;
function requireTypes() {
  if (hasRequiredTypes) return types;
  hasRequiredTypes = 1;
  Object.defineProperty(types, "__esModule", {
    value: true
  });
  types.ArgumentPlaceholder = ArgumentPlaceholder;
  types.ArrayPattern = types.ArrayExpression = ArrayExpression;
  types.BigIntLiteral = BigIntLiteral;
  types.BooleanLiteral = BooleanLiteral;
  types.Identifier = Identifier;
  types.NullLiteral = NullLiteral;
  types.NumericLiteral = NumericLiteral;
  types.ObjectPattern = types.ObjectExpression = ObjectExpression;
  types.ObjectMethod = ObjectMethod;
  types.ObjectProperty = ObjectProperty;
  types.PipelineBareFunction = PipelineBareFunction;
  types.PipelinePrimaryTopicReference = PipelinePrimaryTopicReference;
  types.PipelineTopicExpression = PipelineTopicExpression;
  types.RecordExpression = RecordExpression;
  types.RegExpLiteral = RegExpLiteral;
  types.SpreadElement = types.RestElement = RestElement;
  types.StringLiteral = StringLiteral;
  types.TopicReference = TopicReference;
  types.TupleExpression = TupleExpression;
  types.VoidPattern = VoidPattern;
  types._getRawIdentifier = _getRawIdentifier;
  var _t = requireLib$4();
  var _jsesc = requireJsesc();
  const {
    isAssignmentPattern,
    isIdentifier
  } = _t;
  let lastRawIdentNode = null;
  let lastRawIdentResult = "";
  function _getRawIdentifier(node2) {
    if (node2 === lastRawIdentNode) return lastRawIdentResult;
    lastRawIdentNode = node2;
    const {
      name
    } = node2;
    const token = this.tokenMap.find(node2, (tok) => tok.value === name);
    if (token) {
      lastRawIdentResult = this._originalCode.slice(token.start, token.end);
      return lastRawIdentResult;
    }
    return lastRawIdentResult = node2.name;
  }
  function Identifier(node2) {
    var _node$loc;
    this.sourceIdentifierName(((_node$loc = node2.loc) == null ? void 0 : _node$loc.identifierName) || node2.name);
    this.word(this.tokenMap ? this._getRawIdentifier(node2) : node2.name);
  }
  function ArgumentPlaceholder() {
    this.tokenChar(63);
  }
  function RestElement(node2) {
    this.token("...");
    this.print(node2.argument);
  }
  function ObjectExpression(node2) {
    const props = node2.properties;
    this.tokenChar(123);
    if (props.length) {
      const exit = this.enterDelimited();
      this.space();
      this.printList(props, this.shouldPrintTrailingComma("}"), true, true);
      this.space();
      exit();
    }
    this.sourceWithOffset("end", node2.loc, -1);
    this.tokenChar(125);
  }
  function ObjectMethod(node2) {
    this.printJoin(node2.decorators);
    this._methodHead(node2);
    this.space();
    this.print(node2.body);
  }
  function ObjectProperty(node2) {
    this.printJoin(node2.decorators);
    if (node2.computed) {
      this.tokenChar(91);
      this.print(node2.key);
      this.tokenChar(93);
    } else {
      if (isAssignmentPattern(node2.value) && isIdentifier(node2.key) && node2.key.name === node2.value.left.name) {
        this.print(node2.value);
        return;
      }
      this.print(node2.key);
      if (node2.shorthand && isIdentifier(node2.key) && isIdentifier(node2.value) && node2.key.name === node2.value.name) {
        return;
      }
    }
    this.tokenChar(58);
    this.space();
    this.print(node2.value);
  }
  function ArrayExpression(node2) {
    const elems = node2.elements;
    const len = elems.length;
    this.tokenChar(91);
    const exit = this.enterDelimited();
    for (let i = 0; i < elems.length; i++) {
      const elem = elems[i];
      if (elem) {
        if (i > 0) this.space();
        this.print(elem);
        if (i < len - 1 || this.shouldPrintTrailingComma("]")) {
          this.token(",", false, i);
        }
      } else {
        this.token(",", false, i);
      }
    }
    exit();
    this.tokenChar(93);
  }
  function RecordExpression(node2) {
    const props = node2.properties;
    let startToken;
    let endToken;
    {
      if (this.format.recordAndTupleSyntaxType === "bar") {
        startToken = "{|";
        endToken = "|}";
      } else if (this.format.recordAndTupleSyntaxType !== "hash" && this.format.recordAndTupleSyntaxType != null) {
        throw new Error(`The "recordAndTupleSyntaxType" generator option must be "bar" or "hash" (${JSON.stringify(this.format.recordAndTupleSyntaxType)} received).`);
      } else {
        startToken = "#{";
        endToken = "}";
      }
    }
    this.token(startToken);
    if (props.length) {
      this.space();
      this.printList(props, this.shouldPrintTrailingComma(endToken), true, true);
      this.space();
    }
    this.token(endToken);
  }
  function TupleExpression(node2) {
    const elems = node2.elements;
    const len = elems.length;
    let startToken;
    let endToken;
    {
      if (this.format.recordAndTupleSyntaxType === "bar") {
        startToken = "[|";
        endToken = "|]";
      } else if (this.format.recordAndTupleSyntaxType === "hash") {
        startToken = "#[";
        endToken = "]";
      } else {
        throw new Error(`${this.format.recordAndTupleSyntaxType} is not a valid recordAndTuple syntax type`);
      }
    }
    this.token(startToken);
    for (let i = 0; i < elems.length; i++) {
      const elem = elems[i];
      if (elem) {
        if (i > 0) this.space();
        this.print(elem);
        if (i < len - 1 || this.shouldPrintTrailingComma(endToken)) {
          this.token(",", false, i);
        }
      }
    }
    this.token(endToken);
  }
  function RegExpLiteral(node2) {
    this.word(`/${node2.pattern}/${node2.flags}`);
  }
  function BooleanLiteral(node2) {
    this.word(node2.value ? "true" : "false");
  }
  function NullLiteral() {
    this.word("null");
  }
  function NumericLiteral(node2) {
    const raw = this.getPossibleRaw(node2);
    const opts = this.format.jsescOption;
    const value = node2.value;
    const str = value + "";
    if (opts.numbers) {
      this.number(_jsesc(value, opts), value);
    } else if (raw == null) {
      this.number(str, value);
    } else if (this.format.minified) {
      this.number(raw.length < str.length ? raw : str, value);
    } else {
      this.number(raw, value);
    }
  }
  function StringLiteral(node2) {
    const raw = this.getPossibleRaw(node2);
    if (!this.format.minified && raw !== void 0) {
      this.token(raw);
      return;
    }
    const val = _jsesc(node2.value, this.format.jsescOption);
    this.token(val);
  }
  function BigIntLiteral(node2) {
    const raw = this.getPossibleRaw(node2);
    if (!this.format.minified && raw !== void 0) {
      this.word(raw);
      return;
    }
    this.word(node2.value + "n");
  }
  const validTopicTokenSet = /* @__PURE__ */ new Set(["^^", "@@", "^", "%", "#"]);
  function TopicReference() {
    const {
      topicToken
    } = this.format;
    if (validTopicTokenSet.has(topicToken)) {
      this.token(topicToken);
    } else {
      const givenTopicTokenJSON = JSON.stringify(topicToken);
      const validTopics = Array.from(validTopicTokenSet, (v) => JSON.stringify(v));
      throw new Error(`The "topicToken" generator option must be one of ${validTopics.join(", ")} (${givenTopicTokenJSON} received instead).`);
    }
  }
  function PipelineTopicExpression(node2) {
    this.print(node2.expression);
  }
  function PipelineBareFunction(node2) {
    this.print(node2.callee);
  }
  function PipelinePrimaryTopicReference() {
    this.tokenChar(35);
  }
  function VoidPattern() {
    this.word("void");
  }
  return types;
}
var flow = {};
var hasRequiredFlow;
function requireFlow() {
  if (hasRequiredFlow) return flow;
  hasRequiredFlow = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", {
      value: true
    });
    exports$1.AnyTypeAnnotation = AnyTypeAnnotation;
    exports$1.ArrayTypeAnnotation = ArrayTypeAnnotation;
    exports$1.BooleanLiteralTypeAnnotation = BooleanLiteralTypeAnnotation;
    exports$1.BooleanTypeAnnotation = BooleanTypeAnnotation;
    exports$1.DeclareClass = DeclareClass;
    exports$1.DeclareExportAllDeclaration = DeclareExportAllDeclaration;
    exports$1.DeclareExportDeclaration = DeclareExportDeclaration;
    exports$1.DeclareFunction = DeclareFunction;
    exports$1.DeclareInterface = DeclareInterface;
    exports$1.DeclareModule = DeclareModule;
    exports$1.DeclareModuleExports = DeclareModuleExports;
    exports$1.DeclareOpaqueType = DeclareOpaqueType;
    exports$1.DeclareTypeAlias = DeclareTypeAlias;
    exports$1.DeclareVariable = DeclareVariable;
    exports$1.DeclaredPredicate = DeclaredPredicate;
    exports$1.EmptyTypeAnnotation = EmptyTypeAnnotation;
    exports$1.EnumBooleanBody = EnumBooleanBody;
    exports$1.EnumBooleanMember = EnumBooleanMember;
    exports$1.EnumDeclaration = EnumDeclaration;
    exports$1.EnumDefaultedMember = EnumDefaultedMember;
    exports$1.EnumNumberBody = EnumNumberBody;
    exports$1.EnumNumberMember = EnumNumberMember;
    exports$1.EnumStringBody = EnumStringBody;
    exports$1.EnumStringMember = EnumStringMember;
    exports$1.EnumSymbolBody = EnumSymbolBody;
    exports$1.ExistsTypeAnnotation = ExistsTypeAnnotation;
    exports$1.FunctionTypeAnnotation = FunctionTypeAnnotation;
    exports$1.FunctionTypeParam = FunctionTypeParam;
    exports$1.IndexedAccessType = IndexedAccessType;
    exports$1.InferredPredicate = InferredPredicate;
    exports$1.InterfaceDeclaration = InterfaceDeclaration;
    exports$1.GenericTypeAnnotation = exports$1.ClassImplements = exports$1.InterfaceExtends = InterfaceExtends;
    exports$1.InterfaceTypeAnnotation = InterfaceTypeAnnotation;
    exports$1.IntersectionTypeAnnotation = IntersectionTypeAnnotation;
    exports$1.MixedTypeAnnotation = MixedTypeAnnotation;
    exports$1.NullLiteralTypeAnnotation = NullLiteralTypeAnnotation;
    exports$1.NullableTypeAnnotation = NullableTypeAnnotation;
    Object.defineProperty(exports$1, "NumberLiteralTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _types2.NumericLiteral;
      }
    });
    exports$1.NumberTypeAnnotation = NumberTypeAnnotation;
    exports$1.ObjectTypeAnnotation = ObjectTypeAnnotation;
    exports$1.ObjectTypeCallProperty = ObjectTypeCallProperty;
    exports$1.ObjectTypeIndexer = ObjectTypeIndexer;
    exports$1.ObjectTypeInternalSlot = ObjectTypeInternalSlot;
    exports$1.ObjectTypeProperty = ObjectTypeProperty;
    exports$1.ObjectTypeSpreadProperty = ObjectTypeSpreadProperty;
    exports$1.OpaqueType = OpaqueType;
    exports$1.OptionalIndexedAccessType = OptionalIndexedAccessType;
    exports$1.QualifiedTypeIdentifier = QualifiedTypeIdentifier;
    Object.defineProperty(exports$1, "StringLiteralTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _types2.StringLiteral;
      }
    });
    exports$1.StringTypeAnnotation = StringTypeAnnotation;
    exports$1.SymbolTypeAnnotation = SymbolTypeAnnotation;
    exports$1.ThisTypeAnnotation = ThisTypeAnnotation;
    exports$1.TupleTypeAnnotation = TupleTypeAnnotation;
    exports$1.TypeAlias = TypeAlias;
    exports$1.TypeAnnotation = TypeAnnotation;
    exports$1.TypeCastExpression = TypeCastExpression;
    exports$1.TypeParameter = TypeParameter;
    exports$1.TypeParameterDeclaration = exports$1.TypeParameterInstantiation = TypeParameterInstantiation;
    exports$1.TypeofTypeAnnotation = TypeofTypeAnnotation;
    exports$1.UnionTypeAnnotation = UnionTypeAnnotation;
    exports$1.Variance = Variance;
    exports$1.VoidTypeAnnotation = VoidTypeAnnotation;
    exports$1._interfaceish = _interfaceish;
    exports$1._variance = _variance;
    var _t = requireLib$4();
    var _modules = requireModules();
    var _index = requireNode();
    var _types2 = requireTypes();
    const {
      isDeclareExportDeclaration,
      isStatement
    } = _t;
    function AnyTypeAnnotation() {
      this.word("any");
    }
    function ArrayTypeAnnotation(node2) {
      this.print(node2.elementType, true);
      this.tokenChar(91);
      this.tokenChar(93);
    }
    function BooleanTypeAnnotation() {
      this.word("boolean");
    }
    function BooleanLiteralTypeAnnotation(node2) {
      this.word(node2.value ? "true" : "false");
    }
    function NullLiteralTypeAnnotation() {
      this.word("null");
    }
    function DeclareClass(node2, parent) {
      if (!isDeclareExportDeclaration(parent)) {
        this.word("declare");
        this.space();
      }
      this.word("class");
      this.space();
      this._interfaceish(node2);
    }
    function DeclareFunction(node2, parent) {
      if (!isDeclareExportDeclaration(parent)) {
        this.word("declare");
        this.space();
      }
      this.word("function");
      this.space();
      this.print(node2.id);
      this.print(node2.id.typeAnnotation.typeAnnotation);
      if (node2.predicate) {
        this.space();
        this.print(node2.predicate);
      }
      this.semicolon();
    }
    function InferredPredicate() {
      this.tokenChar(37);
      this.word("checks");
    }
    function DeclaredPredicate(node2) {
      this.tokenChar(37);
      this.word("checks");
      this.tokenChar(40);
      this.print(node2.value);
      this.tokenChar(41);
    }
    function DeclareInterface(node2) {
      this.word("declare");
      this.space();
      this.InterfaceDeclaration(node2);
    }
    function DeclareModule(node2) {
      this.word("declare");
      this.space();
      this.word("module");
      this.space();
      this.print(node2.id);
      this.space();
      this.print(node2.body);
    }
    function DeclareModuleExports(node2) {
      this.word("declare");
      this.space();
      this.word("module");
      this.tokenChar(46);
      this.word("exports");
      this.print(node2.typeAnnotation);
    }
    function DeclareTypeAlias(node2) {
      this.word("declare");
      this.space();
      this.TypeAlias(node2);
    }
    function DeclareOpaqueType(node2, parent) {
      if (!isDeclareExportDeclaration(parent)) {
        this.word("declare");
        this.space();
      }
      this.OpaqueType(node2);
    }
    function DeclareVariable(node2, parent) {
      if (!isDeclareExportDeclaration(parent)) {
        this.word("declare");
        this.space();
      }
      this.word("var");
      this.space();
      this.print(node2.id);
      this.print(node2.id.typeAnnotation);
      this.semicolon();
    }
    function DeclareExportDeclaration(node2) {
      this.word("declare");
      this.space();
      this.word("export");
      this.space();
      if (node2.default) {
        this.word("default");
        this.space();
      }
      FlowExportDeclaration.call(this, node2);
    }
    function DeclareExportAllDeclaration(node2) {
      this.word("declare");
      this.space();
      _modules.ExportAllDeclaration.call(this, node2);
    }
    function EnumDeclaration(node2) {
      const {
        id,
        body
      } = node2;
      this.word("enum");
      this.space();
      this.print(id);
      this.print(body);
    }
    function enumExplicitType(context2, name, hasExplicitType) {
      if (hasExplicitType) {
        context2.space();
        context2.word("of");
        context2.space();
        context2.word(name);
      }
      context2.space();
    }
    function enumBody(context2, node2) {
      const {
        members
      } = node2;
      context2.token("{");
      context2.indent();
      context2.newline();
      for (const member of members) {
        context2.print(member);
        context2.newline();
      }
      if (node2.hasUnknownMembers) {
        context2.token("...");
        context2.newline();
      }
      context2.dedent();
      context2.token("}");
    }
    function EnumBooleanBody(node2) {
      const {
        explicitType
      } = node2;
      enumExplicitType(this, "boolean", explicitType);
      enumBody(this, node2);
    }
    function EnumNumberBody(node2) {
      const {
        explicitType
      } = node2;
      enumExplicitType(this, "number", explicitType);
      enumBody(this, node2);
    }
    function EnumStringBody(node2) {
      const {
        explicitType
      } = node2;
      enumExplicitType(this, "string", explicitType);
      enumBody(this, node2);
    }
    function EnumSymbolBody(node2) {
      enumExplicitType(this, "symbol", true);
      enumBody(this, node2);
    }
    function EnumDefaultedMember(node2) {
      const {
        id
      } = node2;
      this.print(id);
      this.tokenChar(44);
    }
    function enumInitializedMember(context2, node2) {
      context2.print(node2.id);
      context2.space();
      context2.token("=");
      context2.space();
      context2.print(node2.init);
      context2.token(",");
    }
    function EnumBooleanMember(node2) {
      enumInitializedMember(this, node2);
    }
    function EnumNumberMember(node2) {
      enumInitializedMember(this, node2);
    }
    function EnumStringMember(node2) {
      enumInitializedMember(this, node2);
    }
    function FlowExportDeclaration(node2) {
      if (node2.declaration) {
        const declar = node2.declaration;
        this.print(declar);
        if (!isStatement(declar)) this.semicolon();
      } else {
        this.tokenChar(123);
        if (node2.specifiers.length) {
          this.space();
          this.printList(node2.specifiers);
          this.space();
        }
        this.tokenChar(125);
        if (node2.source) {
          this.space();
          this.word("from");
          this.space();
          this.print(node2.source);
        }
        this.semicolon();
      }
    }
    function ExistsTypeAnnotation() {
      this.tokenChar(42);
    }
    function FunctionTypeAnnotation(node2, parent) {
      this.print(node2.typeParameters);
      this.tokenChar(40);
      if (node2.this) {
        this.word("this");
        this.tokenChar(58);
        this.space();
        this.print(node2.this.typeAnnotation);
        if (node2.params.length || node2.rest) {
          this.tokenChar(44);
          this.space();
        }
      }
      this.printList(node2.params);
      if (node2.rest) {
        if (node2.params.length) {
          this.tokenChar(44);
          this.space();
        }
        this.token("...");
        this.print(node2.rest);
      }
      this.tokenChar(41);
      const type = parent == null ? void 0 : parent.type;
      if (type != null && (type === "ObjectTypeCallProperty" || type === "ObjectTypeInternalSlot" || type === "DeclareFunction" || type === "ObjectTypeProperty" && parent.method)) {
        this.tokenChar(58);
      } else {
        this.space();
        this.token("=>");
      }
      this.space();
      this.print(node2.returnType);
    }
    function FunctionTypeParam(node2) {
      this.print(node2.name);
      if (node2.optional) this.tokenChar(63);
      if (node2.name) {
        this.tokenChar(58);
        this.space();
      }
      this.print(node2.typeAnnotation);
    }
    function InterfaceExtends(node2) {
      this.print(node2.id);
      this.print(node2.typeParameters, true);
    }
    function _interfaceish(node2) {
      var _node$extends;
      this.print(node2.id);
      this.print(node2.typeParameters);
      if ((_node$extends = node2.extends) != null && _node$extends.length) {
        this.space();
        this.word("extends");
        this.space();
        this.printList(node2.extends);
      }
      if (node2.type === "DeclareClass") {
        var _node$mixins, _node$implements;
        if ((_node$mixins = node2.mixins) != null && _node$mixins.length) {
          this.space();
          this.word("mixins");
          this.space();
          this.printList(node2.mixins);
        }
        if ((_node$implements = node2.implements) != null && _node$implements.length) {
          this.space();
          this.word("implements");
          this.space();
          this.printList(node2.implements);
        }
      }
      this.space();
      this.print(node2.body);
    }
    function _variance(node2) {
      var _node$variance;
      const kind = (_node$variance = node2.variance) == null ? void 0 : _node$variance.kind;
      if (kind != null) {
        if (kind === "plus") {
          this.tokenChar(43);
        } else if (kind === "minus") {
          this.tokenChar(45);
        }
      }
    }
    function InterfaceDeclaration(node2) {
      this.word("interface");
      this.space();
      this._interfaceish(node2);
    }
    function andSeparator(occurrenceCount) {
      this.space();
      this.token("&", false, occurrenceCount);
      this.space();
    }
    function InterfaceTypeAnnotation(node2) {
      var _node$extends2;
      this.word("interface");
      if ((_node$extends2 = node2.extends) != null && _node$extends2.length) {
        this.space();
        this.word("extends");
        this.space();
        this.printList(node2.extends);
      }
      this.space();
      this.print(node2.body);
    }
    function IntersectionTypeAnnotation(node2) {
      this.printJoin(node2.types, void 0, void 0, andSeparator);
    }
    function MixedTypeAnnotation() {
      this.word("mixed");
    }
    function EmptyTypeAnnotation() {
      this.word("empty");
    }
    function NullableTypeAnnotation(node2) {
      this.tokenChar(63);
      this.print(node2.typeAnnotation);
    }
    function NumberTypeAnnotation() {
      this.word("number");
    }
    function StringTypeAnnotation() {
      this.word("string");
    }
    function ThisTypeAnnotation() {
      this.word("this");
    }
    function TupleTypeAnnotation(node2) {
      this.tokenChar(91);
      this.printList(node2.types);
      this.tokenChar(93);
    }
    function TypeofTypeAnnotation(node2) {
      this.word("typeof");
      this.space();
      this.print(node2.argument);
    }
    function TypeAlias(node2) {
      this.word("type");
      this.space();
      this.print(node2.id);
      this.print(node2.typeParameters);
      this.space();
      this.tokenChar(61);
      this.space();
      this.print(node2.right);
      this.semicolon();
    }
    function TypeAnnotation(node2, parent) {
      this.tokenChar(58);
      this.space();
      if (parent.type === "ArrowFunctionExpression") {
        this.tokenContext |= _index.TokenContext.arrowFlowReturnType;
      } else if (node2.optional) {
        this.tokenChar(63);
      }
      this.print(node2.typeAnnotation);
    }
    function TypeParameterInstantiation(node2) {
      this.tokenChar(60);
      this.printList(node2.params);
      this.tokenChar(62);
    }
    function TypeParameter(node2) {
      this._variance(node2);
      this.word(node2.name);
      if (node2.bound) {
        this.print(node2.bound);
      }
      if (node2.default) {
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(node2.default);
      }
    }
    function OpaqueType(node2) {
      this.word("opaque");
      this.space();
      this.word("type");
      this.space();
      this.print(node2.id);
      this.print(node2.typeParameters);
      if (node2.supertype) {
        this.tokenChar(58);
        this.space();
        this.print(node2.supertype);
      }
      if (node2.impltype) {
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(node2.impltype);
      }
      this.semicolon();
    }
    function ObjectTypeAnnotation(node2) {
      if (node2.exact) {
        this.token("{|");
      } else {
        this.tokenChar(123);
      }
      const props = [...node2.properties, ...node2.callProperties || [], ...node2.indexers || [], ...node2.internalSlots || []];
      if (props.length) {
        this.newline();
        this.space();
        this.printJoin(props, true, true, void 0, void 0, () => {
          if (props.length !== 1 || node2.inexact) {
            this.tokenChar(44);
            this.space();
          }
        });
        this.space();
      }
      if (node2.inexact) {
        this.indent();
        this.token("...");
        if (props.length) {
          this.newline();
        }
        this.dedent();
      }
      if (node2.exact) {
        this.token("|}");
      } else {
        this.tokenChar(125);
      }
    }
    function ObjectTypeInternalSlot(node2) {
      if (node2.static) {
        this.word("static");
        this.space();
      }
      this.tokenChar(91);
      this.tokenChar(91);
      this.print(node2.id);
      this.tokenChar(93);
      this.tokenChar(93);
      if (node2.optional) this.tokenChar(63);
      if (!node2.method) {
        this.tokenChar(58);
        this.space();
      }
      this.print(node2.value);
    }
    function ObjectTypeCallProperty(node2) {
      if (node2.static) {
        this.word("static");
        this.space();
      }
      this.print(node2.value);
    }
    function ObjectTypeIndexer(node2) {
      if (node2.static) {
        this.word("static");
        this.space();
      }
      this._variance(node2);
      this.tokenChar(91);
      if (node2.id) {
        this.print(node2.id);
        this.tokenChar(58);
        this.space();
      }
      this.print(node2.key);
      this.tokenChar(93);
      this.tokenChar(58);
      this.space();
      this.print(node2.value);
    }
    function ObjectTypeProperty(node2) {
      if (node2.proto) {
        this.word("proto");
        this.space();
      }
      if (node2.static) {
        this.word("static");
        this.space();
      }
      if (node2.kind === "get" || node2.kind === "set") {
        this.word(node2.kind);
        this.space();
      }
      this._variance(node2);
      this.print(node2.key);
      if (node2.optional) this.tokenChar(63);
      if (!node2.method) {
        this.tokenChar(58);
        this.space();
      }
      this.print(node2.value);
    }
    function ObjectTypeSpreadProperty(node2) {
      this.token("...");
      this.print(node2.argument);
    }
    function QualifiedTypeIdentifier(node2) {
      this.print(node2.qualification);
      this.tokenChar(46);
      this.print(node2.id);
    }
    function SymbolTypeAnnotation() {
      this.word("symbol");
    }
    function orSeparator(occurrenceCount) {
      this.space();
      this.token("|", false, occurrenceCount);
      this.space();
    }
    function UnionTypeAnnotation(node2) {
      this.printJoin(node2.types, void 0, void 0, orSeparator);
    }
    function TypeCastExpression(node2) {
      this.tokenChar(40);
      this.print(node2.expression);
      this.print(node2.typeAnnotation);
      this.tokenChar(41);
    }
    function Variance(node2) {
      if (node2.kind === "plus") {
        this.tokenChar(43);
      } else {
        this.tokenChar(45);
      }
    }
    function VoidTypeAnnotation() {
      this.word("void");
    }
    function IndexedAccessType(node2) {
      this.print(node2.objectType, true);
      this.tokenChar(91);
      this.print(node2.indexType);
      this.tokenChar(93);
    }
    function OptionalIndexedAccessType(node2) {
      this.print(node2.objectType);
      if (node2.optional) {
        this.token("?.");
      }
      this.tokenChar(91);
      this.print(node2.indexType);
      this.tokenChar(93);
    }
  })(flow);
  return flow;
}
var base = {};
var hasRequiredBase;
function requireBase() {
  if (hasRequiredBase) return base;
  hasRequiredBase = 1;
  Object.defineProperty(base, "__esModule", {
    value: true
  });
  base.BlockStatement = BlockStatement;
  base.Directive = Directive;
  base.DirectiveLiteral = DirectiveLiteral;
  base.File = File;
  base.InterpreterDirective = InterpreterDirective;
  base.Placeholder = Placeholder;
  base.Program = Program;
  function File(node2) {
    if (node2.program) {
      this.print(node2.program.interpreter);
    }
    this.print(node2.program);
  }
  function Program(node2) {
    var _node$directives;
    this.noIndentInnerCommentsHere();
    this.printInnerComments();
    const directivesLen = (_node$directives = node2.directives) == null ? void 0 : _node$directives.length;
    if (directivesLen) {
      var _node$directives$trai;
      const newline = node2.body.length ? 2 : 1;
      this.printSequence(node2.directives, void 0, newline);
      if (!((_node$directives$trai = node2.directives[directivesLen - 1].trailingComments) != null && _node$directives$trai.length)) {
        this.newline(newline);
      }
    }
    this.printSequence(node2.body);
  }
  function BlockStatement(node2) {
    var _node$directives2;
    this.tokenChar(123);
    const exit = this.enterDelimited();
    const directivesLen = (_node$directives2 = node2.directives) == null ? void 0 : _node$directives2.length;
    if (directivesLen) {
      var _node$directives$trai2;
      const newline = node2.body.length ? 2 : 1;
      this.printSequence(node2.directives, true, newline);
      if (!((_node$directives$trai2 = node2.directives[directivesLen - 1].trailingComments) != null && _node$directives$trai2.length)) {
        this.newline(newline);
      }
    }
    this.printSequence(node2.body, true);
    exit();
    this.rightBrace(node2);
  }
  function Directive(node2) {
    this.print(node2.value);
    this.semicolon();
  }
  const unescapedSingleQuoteRE = /(?:^|[^\\])(?:\\\\)*'/;
  const unescapedDoubleQuoteRE = /(?:^|[^\\])(?:\\\\)*"/;
  function DirectiveLiteral(node2) {
    const raw = this.getPossibleRaw(node2);
    if (!this.format.minified && raw !== void 0) {
      this.token(raw);
      return;
    }
    const {
      value
    } = node2;
    if (!unescapedDoubleQuoteRE.test(value)) {
      this.token(`"${value}"`);
    } else if (!unescapedSingleQuoteRE.test(value)) {
      this.token(`'${value}'`);
    } else {
      throw new Error("Malformed AST: it is not possible to print a directive containing both unescaped single and double quotes.");
    }
  }
  function InterpreterDirective(node2) {
    this.token(`#!${node2.value}`);
    this.newline(1, true);
  }
  function Placeholder(node2) {
    this.token("%%");
    this.print(node2.name);
    this.token("%%");
    if (node2.expectedNode === "Statement") {
      this.semicolon();
    }
  }
  return base;
}
var jsx = {};
var hasRequiredJsx;
function requireJsx() {
  if (hasRequiredJsx) return jsx;
  hasRequiredJsx = 1;
  Object.defineProperty(jsx, "__esModule", {
    value: true
  });
  jsx.JSXAttribute = JSXAttribute;
  jsx.JSXClosingElement = JSXClosingElement;
  jsx.JSXClosingFragment = JSXClosingFragment;
  jsx.JSXElement = JSXElement;
  jsx.JSXEmptyExpression = JSXEmptyExpression;
  jsx.JSXExpressionContainer = JSXExpressionContainer;
  jsx.JSXFragment = JSXFragment;
  jsx.JSXIdentifier = JSXIdentifier;
  jsx.JSXMemberExpression = JSXMemberExpression;
  jsx.JSXNamespacedName = JSXNamespacedName;
  jsx.JSXOpeningElement = JSXOpeningElement;
  jsx.JSXOpeningFragment = JSXOpeningFragment;
  jsx.JSXSpreadAttribute = JSXSpreadAttribute;
  jsx.JSXSpreadChild = JSXSpreadChild;
  jsx.JSXText = JSXText;
  function JSXAttribute(node2) {
    this.print(node2.name);
    if (node2.value) {
      this.tokenChar(61);
      this.print(node2.value);
    }
  }
  function JSXIdentifier(node2) {
    this.word(node2.name);
  }
  function JSXNamespacedName(node2) {
    this.print(node2.namespace);
    this.tokenChar(58);
    this.print(node2.name);
  }
  function JSXMemberExpression(node2) {
    this.print(node2.object);
    this.tokenChar(46);
    this.print(node2.property);
  }
  function JSXSpreadAttribute(node2) {
    this.tokenChar(123);
    this.token("...");
    this.print(node2.argument);
    this.rightBrace(node2);
  }
  function JSXExpressionContainer(node2) {
    this.tokenChar(123);
    this.print(node2.expression);
    this.rightBrace(node2);
  }
  function JSXSpreadChild(node2) {
    this.tokenChar(123);
    this.token("...");
    this.print(node2.expression);
    this.rightBrace(node2);
  }
  function JSXText(node2) {
    const raw = this.getPossibleRaw(node2);
    if (raw !== void 0) {
      this.token(raw, true);
    } else {
      this.token(node2.value, true);
    }
  }
  function JSXElement(node2) {
    const open = node2.openingElement;
    this.print(open);
    if (open.selfClosing) return;
    this.indent();
    for (const child of node2.children) {
      this.print(child);
    }
    this.dedent();
    this.print(node2.closingElement);
  }
  function spaceSeparator() {
    this.space();
  }
  function JSXOpeningElement(node2) {
    this.tokenChar(60);
    this.print(node2.name);
    {
      if (node2.typeArguments) {
        this.print(node2.typeArguments);
      }
      this.print(node2.typeParameters);
    }
    if (node2.attributes.length > 0) {
      this.space();
      this.printJoin(node2.attributes, void 0, void 0, spaceSeparator);
    }
    if (node2.selfClosing) {
      this.space();
      this.tokenChar(47);
    }
    this.tokenChar(62);
  }
  function JSXClosingElement(node2) {
    this.tokenChar(60);
    this.tokenChar(47);
    this.print(node2.name);
    this.tokenChar(62);
  }
  function JSXEmptyExpression() {
    this.printInnerComments();
  }
  function JSXFragment(node2) {
    this.print(node2.openingFragment);
    this.indent();
    for (const child of node2.children) {
      this.print(child);
    }
    this.dedent();
    this.print(node2.closingFragment);
  }
  function JSXOpeningFragment() {
    this.tokenChar(60);
    this.tokenChar(62);
  }
  function JSXClosingFragment() {
    this.token("</");
    this.tokenChar(62);
  }
  return jsx;
}
var typescript = {};
var hasRequiredTypescript;
function requireTypescript() {
  if (hasRequiredTypescript) return typescript;
  hasRequiredTypescript = 1;
  Object.defineProperty(typescript, "__esModule", {
    value: true
  });
  typescript.TSAnyKeyword = TSAnyKeyword;
  typescript.TSArrayType = TSArrayType;
  typescript.TSSatisfiesExpression = typescript.TSAsExpression = TSTypeExpression;
  typescript.TSBigIntKeyword = TSBigIntKeyword;
  typescript.TSBooleanKeyword = TSBooleanKeyword;
  typescript.TSCallSignatureDeclaration = TSCallSignatureDeclaration;
  typescript.TSInterfaceHeritage = typescript.TSClassImplements = TSClassImplements;
  typescript.TSConditionalType = TSConditionalType;
  typescript.TSConstructSignatureDeclaration = TSConstructSignatureDeclaration;
  typescript.TSConstructorType = TSConstructorType;
  typescript.TSDeclareFunction = TSDeclareFunction;
  typescript.TSDeclareMethod = TSDeclareMethod;
  typescript.TSEnumBody = TSEnumBody;
  typescript.TSEnumDeclaration = TSEnumDeclaration;
  typescript.TSEnumMember = TSEnumMember;
  typescript.TSExportAssignment = TSExportAssignment;
  typescript.TSExternalModuleReference = TSExternalModuleReference;
  typescript.TSFunctionType = TSFunctionType;
  typescript.TSImportEqualsDeclaration = TSImportEqualsDeclaration;
  typescript.TSImportType = TSImportType;
  typescript.TSIndexSignature = TSIndexSignature;
  typescript.TSIndexedAccessType = TSIndexedAccessType;
  typescript.TSInferType = TSInferType;
  typescript.TSInstantiationExpression = TSInstantiationExpression;
  typescript.TSInterfaceBody = TSInterfaceBody;
  typescript.TSInterfaceDeclaration = TSInterfaceDeclaration;
  typescript.TSIntersectionType = TSIntersectionType;
  typescript.TSIntrinsicKeyword = TSIntrinsicKeyword;
  typescript.TSLiteralType = TSLiteralType;
  typescript.TSMappedType = TSMappedType;
  typescript.TSMethodSignature = TSMethodSignature;
  typescript.TSModuleBlock = TSModuleBlock;
  typescript.TSModuleDeclaration = TSModuleDeclaration;
  typescript.TSNamedTupleMember = TSNamedTupleMember;
  typescript.TSNamespaceExportDeclaration = TSNamespaceExportDeclaration;
  typescript.TSNeverKeyword = TSNeverKeyword;
  typescript.TSNonNullExpression = TSNonNullExpression;
  typescript.TSNullKeyword = TSNullKeyword;
  typescript.TSNumberKeyword = TSNumberKeyword;
  typescript.TSObjectKeyword = TSObjectKeyword;
  typescript.TSOptionalType = TSOptionalType;
  typescript.TSParameterProperty = TSParameterProperty;
  typescript.TSParenthesizedType = TSParenthesizedType;
  typescript.TSPropertySignature = TSPropertySignature;
  typescript.TSQualifiedName = TSQualifiedName;
  typescript.TSRestType = TSRestType;
  typescript.TSStringKeyword = TSStringKeyword;
  typescript.TSSymbolKeyword = TSSymbolKeyword;
  typescript.TSTemplateLiteralType = TSTemplateLiteralType;
  typescript.TSThisType = TSThisType;
  typescript.TSTupleType = TSTupleType;
  typescript.TSTypeAliasDeclaration = TSTypeAliasDeclaration;
  typescript.TSTypeAnnotation = TSTypeAnnotation;
  typescript.TSTypeAssertion = TSTypeAssertion;
  typescript.TSTypeLiteral = TSTypeLiteral;
  typescript.TSTypeOperator = TSTypeOperator;
  typescript.TSTypeParameter = TSTypeParameter;
  typescript.TSTypeParameterDeclaration = typescript.TSTypeParameterInstantiation = TSTypeParameterInstantiation;
  typescript.TSTypePredicate = TSTypePredicate;
  typescript.TSTypeQuery = TSTypeQuery;
  typescript.TSTypeReference = TSTypeReference;
  typescript.TSUndefinedKeyword = TSUndefinedKeyword;
  typescript.TSUnionType = TSUnionType;
  typescript.TSUnknownKeyword = TSUnknownKeyword;
  typescript.TSVoidKeyword = TSVoidKeyword;
  typescript.tsPrintClassMemberModifiers = tsPrintClassMemberModifiers;
  typescript.tsPrintFunctionOrConstructorType = tsPrintFunctionOrConstructorType;
  typescript.tsPrintPropertyOrMethodName = tsPrintPropertyOrMethodName;
  typescript.tsPrintSignatureDeclarationBase = tsPrintSignatureDeclarationBase;
  function TSTypeAnnotation(node2, parent) {
    this.token((parent.type === "TSFunctionType" || parent.type === "TSConstructorType") && parent.typeAnnotation === node2 ? "=>" : ":");
    this.space();
    if (node2.optional) this.tokenChar(63);
    this.print(node2.typeAnnotation);
  }
  function TSTypeParameterInstantiation(node2, parent) {
    this.tokenChar(60);
    let printTrailingSeparator = parent.type === "ArrowFunctionExpression" && node2.params.length === 1;
    if (this.tokenMap && node2.start != null && node2.end != null) {
      printTrailingSeparator && (printTrailingSeparator = !!this.tokenMap.find(node2, (t) => this.tokenMap.matchesOriginal(t, ",")));
      printTrailingSeparator || (printTrailingSeparator = this.shouldPrintTrailingComma(">"));
    }
    this.printList(node2.params, printTrailingSeparator);
    this.tokenChar(62);
  }
  function TSTypeParameter(node2) {
    if (node2.const) {
      this.word("const");
      this.space();
    }
    if (node2.in) {
      this.word("in");
      this.space();
    }
    if (node2.out) {
      this.word("out");
      this.space();
    }
    this.word(node2.name);
    if (node2.constraint) {
      this.space();
      this.word("extends");
      this.space();
      this.print(node2.constraint);
    }
    if (node2.default) {
      this.space();
      this.tokenChar(61);
      this.space();
      this.print(node2.default);
    }
  }
  function TSParameterProperty(node2) {
    if (node2.accessibility) {
      this.word(node2.accessibility);
      this.space();
    }
    if (node2.readonly) {
      this.word("readonly");
      this.space();
    }
    this._param(node2.parameter);
  }
  function TSDeclareFunction(node2, parent) {
    if (node2.declare) {
      this.word("declare");
      this.space();
    }
    this._functionHead(node2, parent);
    this.semicolon();
  }
  function TSDeclareMethod(node2) {
    this._classMethodHead(node2);
    this.semicolon();
  }
  function TSQualifiedName(node2) {
    this.print(node2.left);
    this.tokenChar(46);
    this.print(node2.right);
  }
  function TSCallSignatureDeclaration(node2) {
    this.tsPrintSignatureDeclarationBase(node2);
    maybePrintTrailingCommaOrSemicolon(this, node2);
  }
  function maybePrintTrailingCommaOrSemicolon(printer2, node2) {
    if (!printer2.tokenMap || !node2.start || !node2.end) {
      printer2.semicolon();
      return;
    }
    if (printer2.tokenMap.endMatches(node2, ",")) {
      printer2.token(",");
    } else if (printer2.tokenMap.endMatches(node2, ";")) {
      printer2.semicolon();
    }
  }
  function TSConstructSignatureDeclaration(node2) {
    this.word("new");
    this.space();
    this.tsPrintSignatureDeclarationBase(node2);
    maybePrintTrailingCommaOrSemicolon(this, node2);
  }
  function TSPropertySignature(node2) {
    const {
      readonly
    } = node2;
    if (readonly) {
      this.word("readonly");
      this.space();
    }
    this.tsPrintPropertyOrMethodName(node2);
    this.print(node2.typeAnnotation);
    maybePrintTrailingCommaOrSemicolon(this, node2);
  }
  function tsPrintPropertyOrMethodName(node2) {
    if (node2.computed) {
      this.tokenChar(91);
    }
    this.print(node2.key);
    if (node2.computed) {
      this.tokenChar(93);
    }
    if (node2.optional) {
      this.tokenChar(63);
    }
  }
  function TSMethodSignature(node2) {
    const {
      kind
    } = node2;
    if (kind === "set" || kind === "get") {
      this.word(kind);
      this.space();
    }
    this.tsPrintPropertyOrMethodName(node2);
    this.tsPrintSignatureDeclarationBase(node2);
    maybePrintTrailingCommaOrSemicolon(this, node2);
  }
  function TSIndexSignature(node2) {
    const {
      readonly,
      static: isStatic
    } = node2;
    if (isStatic) {
      this.word("static");
      this.space();
    }
    if (readonly) {
      this.word("readonly");
      this.space();
    }
    this.tokenChar(91);
    this._parameters(node2.parameters, "]");
    this.print(node2.typeAnnotation);
    maybePrintTrailingCommaOrSemicolon(this, node2);
  }
  function TSAnyKeyword() {
    this.word("any");
  }
  function TSBigIntKeyword() {
    this.word("bigint");
  }
  function TSUnknownKeyword() {
    this.word("unknown");
  }
  function TSNumberKeyword() {
    this.word("number");
  }
  function TSObjectKeyword() {
    this.word("object");
  }
  function TSBooleanKeyword() {
    this.word("boolean");
  }
  function TSStringKeyword() {
    this.word("string");
  }
  function TSSymbolKeyword() {
    this.word("symbol");
  }
  function TSVoidKeyword() {
    this.word("void");
  }
  function TSUndefinedKeyword() {
    this.word("undefined");
  }
  function TSNullKeyword() {
    this.word("null");
  }
  function TSNeverKeyword() {
    this.word("never");
  }
  function TSIntrinsicKeyword() {
    this.word("intrinsic");
  }
  function TSThisType() {
    this.word("this");
  }
  function TSFunctionType(node2) {
    this.tsPrintFunctionOrConstructorType(node2);
  }
  function TSConstructorType(node2) {
    if (node2.abstract) {
      this.word("abstract");
      this.space();
    }
    this.word("new");
    this.space();
    this.tsPrintFunctionOrConstructorType(node2);
  }
  function tsPrintFunctionOrConstructorType(node2) {
    const {
      typeParameters
    } = node2;
    const parameters = node2.parameters;
    this.print(typeParameters);
    this.tokenChar(40);
    this._parameters(parameters, ")");
    this.space();
    const returnType = node2.typeAnnotation;
    this.print(returnType);
  }
  function TSTypeReference(node2) {
    const typeArguments = node2.typeParameters;
    this.print(node2.typeName, !!typeArguments);
    this.print(typeArguments);
  }
  function TSTypePredicate(node2) {
    if (node2.asserts) {
      this.word("asserts");
      this.space();
    }
    this.print(node2.parameterName);
    if (node2.typeAnnotation) {
      this.space();
      this.word("is");
      this.space();
      this.print(node2.typeAnnotation.typeAnnotation);
    }
  }
  function TSTypeQuery(node2) {
    this.word("typeof");
    this.space();
    this.print(node2.exprName);
    const typeArguments = node2.typeParameters;
    if (typeArguments) {
      this.print(typeArguments);
    }
  }
  function TSTypeLiteral(node2) {
    printBraced(this, node2, () => this.printJoin(node2.members, true, true));
  }
  function TSArrayType(node2) {
    this.print(node2.elementType, true);
    this.tokenChar(91);
    this.tokenChar(93);
  }
  function TSTupleType(node2) {
    this.tokenChar(91);
    this.printList(node2.elementTypes, this.shouldPrintTrailingComma("]"));
    this.tokenChar(93);
  }
  function TSOptionalType(node2) {
    this.print(node2.typeAnnotation);
    this.tokenChar(63);
  }
  function TSRestType(node2) {
    this.token("...");
    this.print(node2.typeAnnotation);
  }
  function TSNamedTupleMember(node2) {
    this.print(node2.label);
    if (node2.optional) this.tokenChar(63);
    this.tokenChar(58);
    this.space();
    this.print(node2.elementType);
  }
  function TSUnionType(node2) {
    tsPrintUnionOrIntersectionType(this, node2, "|");
  }
  function TSIntersectionType(node2) {
    tsPrintUnionOrIntersectionType(this, node2, "&");
  }
  function tsPrintUnionOrIntersectionType(printer2, node2, sep) {
    var _printer$tokenMap;
    let hasLeadingToken = 0;
    if ((_printer$tokenMap = printer2.tokenMap) != null && _printer$tokenMap.startMatches(node2, sep)) {
      hasLeadingToken = 1;
      printer2.token(sep);
    }
    printer2.printJoin(node2.types, void 0, void 0, function(i) {
      this.space();
      this.token(sep, void 0, i + hasLeadingToken);
      this.space();
    });
  }
  function TSConditionalType(node2) {
    this.print(node2.checkType);
    this.space();
    this.word("extends");
    this.space();
    this.print(node2.extendsType);
    this.space();
    this.tokenChar(63);
    this.space();
    this.print(node2.trueType);
    this.space();
    this.tokenChar(58);
    this.space();
    this.print(node2.falseType);
  }
  function TSInferType(node2) {
    this.word("infer");
    this.print(node2.typeParameter);
  }
  function TSParenthesizedType(node2) {
    this.tokenChar(40);
    this.print(node2.typeAnnotation);
    this.tokenChar(41);
  }
  function TSTypeOperator(node2) {
    this.word(node2.operator);
    this.space();
    this.print(node2.typeAnnotation);
  }
  function TSIndexedAccessType(node2) {
    this.print(node2.objectType, true);
    this.tokenChar(91);
    this.print(node2.indexType);
    this.tokenChar(93);
  }
  function TSMappedType(node2) {
    const {
      nameType,
      optional,
      readonly,
      typeAnnotation
    } = node2;
    this.tokenChar(123);
    const exit = this.enterDelimited();
    this.space();
    if (readonly) {
      tokenIfPlusMinus(this, readonly);
      this.word("readonly");
      this.space();
    }
    this.tokenChar(91);
    {
      this.word(node2.typeParameter.name);
    }
    this.space();
    this.word("in");
    this.space();
    {
      this.print(node2.typeParameter.constraint);
    }
    if (nameType) {
      this.space();
      this.word("as");
      this.space();
      this.print(nameType);
    }
    this.tokenChar(93);
    if (optional) {
      tokenIfPlusMinus(this, optional);
      this.tokenChar(63);
    }
    if (typeAnnotation) {
      this.tokenChar(58);
      this.space();
      this.print(typeAnnotation);
    }
    this.space();
    exit();
    this.tokenChar(125);
  }
  function tokenIfPlusMinus(self2, tok) {
    if (tok !== true) {
      self2.token(tok);
    }
  }
  function TSTemplateLiteralType(node2) {
    this._printTemplate(node2, node2.types);
  }
  function TSLiteralType(node2) {
    this.print(node2.literal);
  }
  function TSClassImplements(node2) {
    this.print(node2.expression);
    this.print(node2.typeArguments);
  }
  function TSInterfaceDeclaration(node2) {
    const {
      declare,
      id,
      typeParameters,
      extends: extendz,
      body
    } = node2;
    if (declare) {
      this.word("declare");
      this.space();
    }
    this.word("interface");
    this.space();
    this.print(id);
    this.print(typeParameters);
    if (extendz != null && extendz.length) {
      this.space();
      this.word("extends");
      this.space();
      this.printList(extendz);
    }
    this.space();
    this.print(body);
  }
  function TSInterfaceBody(node2) {
    printBraced(this, node2, () => this.printJoin(node2.body, true, true));
  }
  function TSTypeAliasDeclaration(node2) {
    const {
      declare,
      id,
      typeParameters,
      typeAnnotation
    } = node2;
    if (declare) {
      this.word("declare");
      this.space();
    }
    this.word("type");
    this.space();
    this.print(id);
    this.print(typeParameters);
    this.space();
    this.tokenChar(61);
    this.space();
    this.print(typeAnnotation);
    this.semicolon();
  }
  function TSTypeExpression(node2) {
    const {
      type,
      expression,
      typeAnnotation
    } = node2;
    this.print(expression, true);
    this.space();
    this.word(type === "TSAsExpression" ? "as" : "satisfies");
    this.space();
    this.print(typeAnnotation);
  }
  function TSTypeAssertion(node2) {
    const {
      typeAnnotation,
      expression
    } = node2;
    this.tokenChar(60);
    this.print(typeAnnotation);
    this.tokenChar(62);
    this.space();
    this.print(expression);
  }
  function TSInstantiationExpression(node2) {
    this.print(node2.expression);
    {
      this.print(node2.typeParameters);
    }
  }
  function TSEnumDeclaration(node2) {
    const {
      declare,
      const: isConst,
      id
    } = node2;
    if (declare) {
      this.word("declare");
      this.space();
    }
    if (isConst) {
      this.word("const");
      this.space();
    }
    this.word("enum");
    this.space();
    this.print(id);
    this.space();
    {
      TSEnumBody.call(this, node2);
    }
  }
  function TSEnumBody(node2) {
    printBraced(this, node2, () => {
      var _this$shouldPrintTrai;
      return this.printList(node2.members, (_this$shouldPrintTrai = this.shouldPrintTrailingComma("}")) != null ? _this$shouldPrintTrai : true, true, true);
    });
  }
  function TSEnumMember(node2) {
    const {
      id,
      initializer
    } = node2;
    this.print(id);
    if (initializer) {
      this.space();
      this.tokenChar(61);
      this.space();
      this.print(initializer);
    }
  }
  function TSModuleDeclaration(node2) {
    const {
      declare,
      id,
      kind
    } = node2;
    if (declare) {
      this.word("declare");
      this.space();
    }
    {
      if (!node2.global) {
        this.word(kind != null ? kind : id.type === "Identifier" ? "namespace" : "module");
        this.space();
      }
      this.print(id);
      if (!node2.body) {
        this.semicolon();
        return;
      }
      let body = node2.body;
      while (body.type === "TSModuleDeclaration") {
        this.tokenChar(46);
        this.print(body.id);
        body = body.body;
      }
      this.space();
      this.print(body);
    }
  }
  function TSModuleBlock(node2) {
    printBraced(this, node2, () => this.printSequence(node2.body, true));
  }
  function TSImportType(node2) {
    const {
      argument,
      qualifier,
      options: options2
    } = node2;
    this.word("import");
    this.tokenChar(40);
    this.print(argument);
    if (options2) {
      this.tokenChar(44);
      this.print(options2);
    }
    this.tokenChar(41);
    if (qualifier) {
      this.tokenChar(46);
      this.print(qualifier);
    }
    const typeArguments = node2.typeParameters;
    if (typeArguments) {
      this.print(typeArguments);
    }
  }
  function TSImportEqualsDeclaration(node2) {
    const {
      id,
      moduleReference
    } = node2;
    if (node2.isExport) {
      this.word("export");
      this.space();
    }
    this.word("import");
    this.space();
    this.print(id);
    this.space();
    this.tokenChar(61);
    this.space();
    this.print(moduleReference);
    this.semicolon();
  }
  function TSExternalModuleReference(node2) {
    this.token("require(");
    this.print(node2.expression);
    this.tokenChar(41);
  }
  function TSNonNullExpression(node2) {
    this.print(node2.expression);
    this.tokenChar(33);
  }
  function TSExportAssignment(node2) {
    this.word("export");
    this.space();
    this.tokenChar(61);
    this.space();
    this.print(node2.expression);
    this.semicolon();
  }
  function TSNamespaceExportDeclaration(node2) {
    this.word("export");
    this.space();
    this.word("as");
    this.space();
    this.word("namespace");
    this.space();
    this.print(node2.id);
    this.semicolon();
  }
  function tsPrintSignatureDeclarationBase(node2) {
    const {
      typeParameters
    } = node2;
    const parameters = node2.parameters;
    this.print(typeParameters);
    this.tokenChar(40);
    this._parameters(parameters, ")");
    const returnType = node2.typeAnnotation;
    this.print(returnType);
  }
  function tsPrintClassMemberModifiers(node2) {
    const isPrivateField = node2.type === "ClassPrivateProperty";
    const isPublicField = node2.type === "ClassAccessorProperty" || node2.type === "ClassProperty";
    printModifiersList(this, node2, [isPublicField && node2.declare && "declare", !isPrivateField && node2.accessibility]);
    if (node2.static) {
      this.word("static");
      this.space();
    }
    printModifiersList(this, node2, [!isPrivateField && node2.abstract && "abstract", !isPrivateField && node2.override && "override", (isPublicField || isPrivateField) && node2.readonly && "readonly"]);
  }
  function printBraced(printer2, node2, cb) {
    printer2.token("{");
    const exit = printer2.enterDelimited();
    cb();
    exit();
    printer2.rightBrace(node2);
  }
  function printModifiersList(printer2, node2, modifiers) {
    var _printer$tokenMap2;
    const modifiersSet = /* @__PURE__ */ new Set();
    for (const modifier of modifiers) {
      if (modifier) modifiersSet.add(modifier);
    }
    (_printer$tokenMap2 = printer2.tokenMap) == null || _printer$tokenMap2.find(node2, (tok) => {
      if (modifiersSet.has(tok.value)) {
        printer2.token(tok.value);
        printer2.space();
        modifiersSet.delete(tok.value);
        return modifiersSet.size === 0;
      }
      return false;
    });
    for (const modifier of modifiersSet) {
      printer2.word(modifier);
      printer2.space();
    }
  }
  return typescript;
}
var hasRequiredGenerators;
function requireGenerators() {
  if (hasRequiredGenerators) return generators;
  hasRequiredGenerators = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", {
      value: true
    });
    var _templateLiterals = requireTemplateLiterals();
    Object.keys(_templateLiterals).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports$1 && exports$1[key] === _templateLiterals[key]) return;
      Object.defineProperty(exports$1, key, {
        enumerable: true,
        get: function() {
          return _templateLiterals[key];
        }
      });
    });
    var _expressions = requireExpressions();
    Object.keys(_expressions).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports$1 && exports$1[key] === _expressions[key]) return;
      Object.defineProperty(exports$1, key, {
        enumerable: true,
        get: function() {
          return _expressions[key];
        }
      });
    });
    var _statements = requireStatements();
    Object.keys(_statements).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports$1 && exports$1[key] === _statements[key]) return;
      Object.defineProperty(exports$1, key, {
        enumerable: true,
        get: function() {
          return _statements[key];
        }
      });
    });
    var _classes = requireClasses();
    Object.keys(_classes).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports$1 && exports$1[key] === _classes[key]) return;
      Object.defineProperty(exports$1, key, {
        enumerable: true,
        get: function() {
          return _classes[key];
        }
      });
    });
    var _methods = requireMethods();
    Object.keys(_methods).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports$1 && exports$1[key] === _methods[key]) return;
      Object.defineProperty(exports$1, key, {
        enumerable: true,
        get: function() {
          return _methods[key];
        }
      });
    });
    var _modules = requireModules();
    Object.keys(_modules).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports$1 && exports$1[key] === _modules[key]) return;
      Object.defineProperty(exports$1, key, {
        enumerable: true,
        get: function() {
          return _modules[key];
        }
      });
    });
    var _types = requireTypes();
    Object.keys(_types).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports$1 && exports$1[key] === _types[key]) return;
      Object.defineProperty(exports$1, key, {
        enumerable: true,
        get: function() {
          return _types[key];
        }
      });
    });
    var _flow = requireFlow();
    Object.keys(_flow).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports$1 && exports$1[key] === _flow[key]) return;
      Object.defineProperty(exports$1, key, {
        enumerable: true,
        get: function() {
          return _flow[key];
        }
      });
    });
    var _base = requireBase();
    Object.keys(_base).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports$1 && exports$1[key] === _base[key]) return;
      Object.defineProperty(exports$1, key, {
        enumerable: true,
        get: function() {
          return _base[key];
        }
      });
    });
    var _jsx = requireJsx();
    Object.keys(_jsx).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports$1 && exports$1[key] === _jsx[key]) return;
      Object.defineProperty(exports$1, key, {
        enumerable: true,
        get: function() {
          return _jsx[key];
        }
      });
    });
    var _typescript = requireTypescript();
    Object.keys(_typescript).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports$1 && exports$1[key] === _typescript[key]) return;
      Object.defineProperty(exports$1, key, {
        enumerable: true,
        get: function() {
          return _typescript[key];
        }
      });
    });
  })(generators);
  return generators;
}
var deprecated = {};
var hasRequiredDeprecated;
function requireDeprecated() {
  if (hasRequiredDeprecated) return deprecated;
  hasRequiredDeprecated = 1;
  Object.defineProperty(deprecated, "__esModule", {
    value: true
  });
  deprecated.addDeprecatedGenerators = addDeprecatedGenerators;
  function addDeprecatedGenerators(PrinterClass) {
    {
      const deprecatedBabel7Generators = {
        Noop() {
        },
        TSExpressionWithTypeArguments(node2) {
          this.print(node2.expression);
          this.print(node2.typeParameters);
        },
        DecimalLiteral(node2) {
          const raw = this.getPossibleRaw(node2);
          if (!this.format.minified && raw !== void 0) {
            this.word(raw);
            return;
          }
          this.word(node2.value + "m");
        }
      };
      Object.assign(PrinterClass.prototype, deprecatedBabel7Generators);
    }
  }
  return deprecated;
}
var hasRequiredPrinter;
function requirePrinter() {
  if (hasRequiredPrinter) return printer;
  hasRequiredPrinter = 1;
  Object.defineProperty(printer, "__esModule", {
    value: true
  });
  printer.default = void 0;
  var _buffer = requireBuffer();
  var _index = requireNode();
  var n = _index;
  var _t = requireLib$4();
  var _tokenMap = requireTokenMap();
  var generatorFunctions = requireGenerators();
  var _deprecated = requireDeprecated();
  const {
    isExpression,
    isFunction,
    isStatement,
    isClassBody,
    isTSInterfaceBody,
    isTSEnumMember
  } = _t;
  const SCIENTIFIC_NOTATION = /e/i;
  const ZERO_DECIMAL_INTEGER = /\.0+$/;
  const HAS_NEWLINE = /[\n\r\u2028\u2029]/;
  const HAS_NEWLINE_OR_BlOCK_COMMENT_END = /[\n\r\u2028\u2029]|\*\//;
  function commentIsNewline(c) {
    return c.type === "CommentLine" || HAS_NEWLINE.test(c.value);
  }
  const {
    needsParens
  } = n;
  class Printer {
    constructor(format, map, tokens = null, originalCode = null) {
      this.tokenContext = _index.TokenContext.normal;
      this._tokens = null;
      this._originalCode = null;
      this._currentNode = null;
      this._indent = 0;
      this._indentRepeat = 0;
      this._insideAux = false;
      this._noLineTerminator = false;
      this._noLineTerminatorAfterNode = null;
      this._printAuxAfterOnNextUserNode = false;
      this._printedComments = /* @__PURE__ */ new Set();
      this._endsWithInteger = false;
      this._endsWithWord = false;
      this._endsWithDiv = false;
      this._lastCommentLine = 0;
      this._endsWithInnerRaw = false;
      this._indentInnerComments = true;
      this.tokenMap = null;
      this._boundGetRawIdentifier = this._getRawIdentifier.bind(this);
      this._printSemicolonBeforeNextNode = -1;
      this._printSemicolonBeforeNextToken = -1;
      this.format = format;
      this._tokens = tokens;
      this._originalCode = originalCode;
      this._indentRepeat = format.indent.style.length;
      this._inputMap = (map == null ? void 0 : map._inputMap) || null;
      this._buf = new _buffer.default(map, format.indent.style[0]);
    }
    enterForStatementInit() {
      this.tokenContext |= _index.TokenContext.forInitHead | _index.TokenContext.forInOrInitHeadAccumulate;
      return () => this.tokenContext = _index.TokenContext.normal;
    }
    enterForXStatementInit(isForOf) {
      if (isForOf) {
        this.tokenContext |= _index.TokenContext.forOfHead;
        return null;
      } else {
        this.tokenContext |= _index.TokenContext.forInHead | _index.TokenContext.forInOrInitHeadAccumulate;
        return () => this.tokenContext = _index.TokenContext.normal;
      }
    }
    enterDelimited() {
      const oldTokenContext = this.tokenContext;
      const oldNoLineTerminatorAfterNode = this._noLineTerminatorAfterNode;
      if (!(oldTokenContext & _index.TokenContext.forInOrInitHeadAccumulate) && oldNoLineTerminatorAfterNode === null) {
        return () => {
        };
      }
      this._noLineTerminatorAfterNode = null;
      this.tokenContext = _index.TokenContext.normal;
      return () => {
        this._noLineTerminatorAfterNode = oldNoLineTerminatorAfterNode;
        this.tokenContext = oldTokenContext;
      };
    }
    generate(ast) {
      if (this.format.preserveFormat) {
        this.tokenMap = new _tokenMap.TokenMap(ast, this._tokens, this._originalCode);
      }
      this.print(ast);
      this._maybeAddAuxComment();
      return this._buf.get();
    }
    indent() {
      const {
        format
      } = this;
      if (format.preserveFormat || format.compact || format.concise) {
        return;
      }
      this._indent++;
    }
    dedent() {
      const {
        format
      } = this;
      if (format.preserveFormat || format.compact || format.concise) {
        return;
      }
      this._indent--;
    }
    semicolon(force = false) {
      this._maybeAddAuxComment();
      if (force) {
        this._appendChar(59);
        this._noLineTerminator = false;
        return;
      }
      if (this.tokenMap) {
        const node2 = this._currentNode;
        if (node2.start != null && node2.end != null) {
          if (!this.tokenMap.endMatches(node2, ";")) {
            this._printSemicolonBeforeNextNode = this._buf.getCurrentLine();
            return;
          }
          const indexes = this.tokenMap.getIndexes(this._currentNode);
          this._catchUpTo(this._tokens[indexes[indexes.length - 1]].loc.start);
        }
      }
      this._queue(59);
      this._noLineTerminator = false;
    }
    rightBrace(node2) {
      if (this.format.minified) {
        this._buf.removeLastSemicolon();
      }
      this.sourceWithOffset("end", node2.loc, -1);
      this.tokenChar(125);
    }
    rightParens(node2) {
      this.sourceWithOffset("end", node2.loc, -1);
      this.tokenChar(41);
    }
    space(force = false) {
      const {
        format
      } = this;
      if (format.compact || format.preserveFormat) return;
      if (force) {
        this._space();
      } else if (this._buf.hasContent()) {
        const lastCp = this.getLastChar();
        if (lastCp !== 32 && lastCp !== 10) {
          this._space();
        }
      }
    }
    word(str, noLineTerminatorAfter = false) {
      this.tokenContext &= _index.TokenContext.forInOrInitHeadAccumulatePassThroughMask;
      this._maybePrintInnerComments(str);
      this._maybeAddAuxComment();
      if (this.tokenMap) this._catchUpToCurrentToken(str);
      if (this._endsWithWord || this._endsWithDiv && str.charCodeAt(0) === 47) {
        this._space();
      }
      this._append(str, false);
      this._endsWithWord = true;
      this._noLineTerminator = noLineTerminatorAfter;
    }
    number(str, number) {
      function isNonDecimalLiteral(str2) {
        if (str2.length > 2 && str2.charCodeAt(0) === 48) {
          const secondChar = str2.charCodeAt(1);
          return secondChar === 98 || secondChar === 111 || secondChar === 120;
        }
        return false;
      }
      this.word(str);
      this._endsWithInteger = Number.isInteger(number) && !isNonDecimalLiteral(str) && !SCIENTIFIC_NOTATION.test(str) && !ZERO_DECIMAL_INTEGER.test(str) && str.charCodeAt(str.length - 1) !== 46;
    }
    token(str, maybeNewline = false, occurrenceCount = 0) {
      this.tokenContext &= _index.TokenContext.forInOrInitHeadAccumulatePassThroughMask;
      this._maybePrintInnerComments(str, occurrenceCount);
      this._maybeAddAuxComment();
      if (this.tokenMap) this._catchUpToCurrentToken(str, occurrenceCount);
      const lastChar = this.getLastChar();
      const strFirst = str.charCodeAt(0);
      if (lastChar === 33 && (str === "--" || strFirst === 61) || strFirst === 43 && lastChar === 43 || strFirst === 45 && lastChar === 45 || strFirst === 46 && this._endsWithInteger) {
        this._space();
      }
      this._append(str, maybeNewline);
      this._noLineTerminator = false;
    }
    tokenChar(char) {
      this.tokenContext &= _index.TokenContext.forInOrInitHeadAccumulatePassThroughMask;
      const str = String.fromCharCode(char);
      this._maybePrintInnerComments(str);
      this._maybeAddAuxComment();
      if (this.tokenMap) this._catchUpToCurrentToken(str);
      const lastChar = this.getLastChar();
      if (char === 43 && lastChar === 43 || char === 45 && lastChar === 45 || char === 46 && this._endsWithInteger) {
        this._space();
      }
      this._appendChar(char);
      this._noLineTerminator = false;
    }
    newline(i = 1, force) {
      if (i <= 0) return;
      if (!force) {
        if (this.format.retainLines || this.format.compact) return;
        if (this.format.concise) {
          this.space();
          return;
        }
      }
      if (i > 2) i = 2;
      i -= this._buf.getNewlineCount();
      for (let j = 0; j < i; j++) {
        this._newline();
      }
      return;
    }
    endsWith(char) {
      return this.getLastChar() === char;
    }
    getLastChar() {
      return this._buf.getLastChar();
    }
    endsWithCharAndNewline() {
      return this._buf.endsWithCharAndNewline();
    }
    removeTrailingNewline() {
      this._buf.removeTrailingNewline();
    }
    exactSource(loc, cb) {
      if (!loc) {
        cb();
        return;
      }
      this._catchUp("start", loc);
      this._buf.exactSource(loc, cb);
    }
    source(prop, loc) {
      if (!loc) return;
      this._catchUp(prop, loc);
      this._buf.source(prop, loc);
    }
    sourceWithOffset(prop, loc, columnOffset) {
      if (!loc || this.format.preserveFormat) return;
      this._catchUp(prop, loc);
      this._buf.sourceWithOffset(prop, loc, columnOffset);
    }
    sourceIdentifierName(identifierName, pos) {
      if (!this._buf._canMarkIdName) return;
      const sourcePosition = this._buf._sourcePosition;
      sourcePosition.identifierNamePos = pos;
      sourcePosition.identifierName = identifierName;
    }
    _space() {
      this._queue(32);
    }
    _newline() {
      this._queue(10);
    }
    _catchUpToCurrentToken(str, occurrenceCount = 0) {
      const token = this.tokenMap.findMatching(this._currentNode, str, occurrenceCount);
      if (token) this._catchUpTo(token.loc.start);
      if (this._printSemicolonBeforeNextToken !== -1 && this._printSemicolonBeforeNextToken === this._buf.getCurrentLine()) {
        this._buf.appendChar(59);
        this._endsWithWord = false;
        this._endsWithInteger = false;
        this._endsWithDiv = false;
      }
      this._printSemicolonBeforeNextToken = -1;
      this._printSemicolonBeforeNextNode = -1;
    }
    _append(str, maybeNewline) {
      this._maybeIndent(str.charCodeAt(0));
      this._buf.append(str, maybeNewline);
      this._endsWithWord = false;
      this._endsWithInteger = false;
      this._endsWithDiv = false;
    }
    _appendChar(char) {
      this._maybeIndent(char);
      this._buf.appendChar(char);
      this._endsWithWord = false;
      this._endsWithInteger = false;
      this._endsWithDiv = false;
    }
    _queue(char) {
      this._maybeIndent(char);
      this._buf.queue(char);
      this._endsWithWord = false;
      this._endsWithInteger = false;
    }
    _maybeIndent(firstChar) {
      if (this._indent && firstChar !== 10 && this.endsWith(10)) {
        this._buf.queueIndentation(this._getIndent());
      }
    }
    _shouldIndent(firstChar) {
      if (this._indent && firstChar !== 10 && this.endsWith(10)) {
        return true;
      }
    }
    catchUp(line) {
      if (!this.format.retainLines) return;
      const count = line - this._buf.getCurrentLine();
      for (let i = 0; i < count; i++) {
        this._newline();
      }
    }
    _catchUp(prop, loc) {
      const {
        format
      } = this;
      if (!format.preserveFormat) {
        if (format.retainLines && loc != null && loc[prop]) {
          this.catchUp(loc[prop].line);
        }
        return;
      }
      const pos = loc == null ? void 0 : loc[prop];
      if (pos != null) this._catchUpTo(pos);
    }
    _catchUpTo({
      line,
      column,
      index
    }) {
      const count = line - this._buf.getCurrentLine();
      if (count > 0 && this._noLineTerminator) {
        return;
      }
      for (let i = 0; i < count; i++) {
        this._newline();
      }
      const spacesCount = count > 0 ? column : column - this._buf.getCurrentColumn();
      if (spacesCount > 0) {
        const spaces = this._originalCode ? this._originalCode.slice(index - spacesCount, index).replace(/[^\t\x0B\f \xA0\u1680\u2000-\u200A\u202F\u205F\u3000\uFEFF]/gu, " ") : " ".repeat(spacesCount);
        this._append(spaces, false);
      }
    }
    _getIndent() {
      return this._indentRepeat * this._indent;
    }
    printTerminatorless(node2) {
      this._noLineTerminator = true;
      this.print(node2);
    }
    print(node2, noLineTerminatorAfter = false, trailingCommentsLineOffset) {
      var _node$extra, _node$leadingComments, _node$leadingComments2;
      if (!node2) return;
      this._endsWithInnerRaw = false;
      const nodeType = node2.type;
      const format = this.format;
      const oldConcise = format.concise;
      if (node2._compact) {
        format.concise = true;
      }
      const printMethod = this[nodeType];
      if (printMethod === void 0) {
        throw new ReferenceError(`unknown node of type ${JSON.stringify(nodeType)} with constructor ${JSON.stringify(node2.constructor.name)}`);
      }
      const parent = this._currentNode;
      this._currentNode = node2;
      if (this.tokenMap) {
        this._printSemicolonBeforeNextToken = this._printSemicolonBeforeNextNode;
      }
      const oldInAux = this._insideAux;
      this._insideAux = node2.loc == null;
      this._maybeAddAuxComment(this._insideAux && !oldInAux);
      const parenthesized = (_node$extra = node2.extra) == null ? void 0 : _node$extra.parenthesized;
      let shouldPrintParens = parenthesized && format.preserveFormat || parenthesized && format.retainFunctionParens && nodeType === "FunctionExpression" || needsParens(node2, parent, this.tokenContext, format.preserveFormat ? this._boundGetRawIdentifier : void 0);
      if (!shouldPrintParens && parenthesized && (_node$leadingComments = node2.leadingComments) != null && _node$leadingComments.length && node2.leadingComments[0].type === "CommentBlock") {
        const parentType = parent == null ? void 0 : parent.type;
        switch (parentType) {
          case "ExpressionStatement":
          case "VariableDeclarator":
          case "AssignmentExpression":
          case "ReturnStatement":
            break;
          case "CallExpression":
          case "OptionalCallExpression":
          case "NewExpression":
            if (parent.callee !== node2) break;
          default:
            shouldPrintParens = true;
        }
      }
      let indentParenthesized = false;
      if (!shouldPrintParens && this._noLineTerminator && ((_node$leadingComments2 = node2.leadingComments) != null && _node$leadingComments2.some(commentIsNewline) || this.format.retainLines && node2.loc && node2.loc.start.line > this._buf.getCurrentLine())) {
        shouldPrintParens = true;
        indentParenthesized = true;
      }
      let oldNoLineTerminatorAfterNode;
      let oldTokenContext;
      if (!shouldPrintParens) {
        noLineTerminatorAfter || (noLineTerminatorAfter = !!parent && this._noLineTerminatorAfterNode === parent && n.isLastChild(parent, node2));
        if (noLineTerminatorAfter) {
          var _node$trailingComment;
          if ((_node$trailingComment = node2.trailingComments) != null && _node$trailingComment.some(commentIsNewline)) {
            if (isExpression(node2)) shouldPrintParens = true;
          } else {
            oldNoLineTerminatorAfterNode = this._noLineTerminatorAfterNode;
            this._noLineTerminatorAfterNode = node2;
          }
        }
      }
      if (shouldPrintParens) {
        this.tokenChar(40);
        if (indentParenthesized) this.indent();
        this._endsWithInnerRaw = false;
        if (this.tokenContext & _index.TokenContext.forInOrInitHeadAccumulate) {
          oldTokenContext = this.tokenContext;
          this.tokenContext = _index.TokenContext.normal;
        }
        oldNoLineTerminatorAfterNode = this._noLineTerminatorAfterNode;
        this._noLineTerminatorAfterNode = null;
      }
      this._lastCommentLine = 0;
      this._printLeadingComments(node2, parent);
      const loc = nodeType === "Program" || nodeType === "File" ? null : node2.loc;
      this.exactSource(loc, printMethod.bind(this, node2, parent));
      if (shouldPrintParens) {
        this._printTrailingComments(node2, parent);
        if (indentParenthesized) {
          this.dedent();
          this.newline();
        }
        this.tokenChar(41);
        this._noLineTerminator = noLineTerminatorAfter;
        if (oldTokenContext) this.tokenContext = oldTokenContext;
      } else if (noLineTerminatorAfter && !this._noLineTerminator) {
        this._noLineTerminator = true;
        this._printTrailingComments(node2, parent);
      } else {
        this._printTrailingComments(node2, parent, trailingCommentsLineOffset);
      }
      this._currentNode = parent;
      format.concise = oldConcise;
      this._insideAux = oldInAux;
      if (oldNoLineTerminatorAfterNode !== void 0) {
        this._noLineTerminatorAfterNode = oldNoLineTerminatorAfterNode;
      }
      this._endsWithInnerRaw = false;
    }
    _maybeAddAuxComment(enteredPositionlessNode) {
      if (enteredPositionlessNode) this._printAuxBeforeComment();
      if (!this._insideAux) this._printAuxAfterComment();
    }
    _printAuxBeforeComment() {
      if (this._printAuxAfterOnNextUserNode) return;
      this._printAuxAfterOnNextUserNode = true;
      const comment = this.format.auxiliaryCommentBefore;
      if (comment) {
        this._printComment({
          type: "CommentBlock",
          value: comment
        }, 0);
      }
    }
    _printAuxAfterComment() {
      if (!this._printAuxAfterOnNextUserNode) return;
      this._printAuxAfterOnNextUserNode = false;
      const comment = this.format.auxiliaryCommentAfter;
      if (comment) {
        this._printComment({
          type: "CommentBlock",
          value: comment
        }, 0);
      }
    }
    getPossibleRaw(node2) {
      const extra = node2.extra;
      if ((extra == null ? void 0 : extra.raw) != null && extra.rawValue != null && node2.value === extra.rawValue) {
        return extra.raw;
      }
    }
    printJoin(nodes, statement, indent, separator, printTrailingSeparator, iterator, trailingCommentsLineOffset) {
      if (!(nodes != null && nodes.length)) return;
      if (indent == null && this.format.retainLines) {
        var _nodes$0$loc;
        const startLine = (_nodes$0$loc = nodes[0].loc) == null ? void 0 : _nodes$0$loc.start.line;
        if (startLine != null && startLine !== this._buf.getCurrentLine()) {
          indent = true;
        }
      }
      if (indent) this.indent();
      const newlineOpts = {
        nextNodeStartLine: 0
      };
      const boundSeparator = separator == null ? void 0 : separator.bind(this);
      const len = nodes.length;
      for (let i = 0; i < len; i++) {
        const node2 = nodes[i];
        if (!node2) continue;
        if (statement) this._printNewline(i === 0, newlineOpts);
        this.print(node2, void 0, trailingCommentsLineOffset || 0);
        iterator == null || iterator(node2, i);
        if (boundSeparator != null) {
          if (i < len - 1) boundSeparator(i, false);
          else if (printTrailingSeparator) boundSeparator(i, true);
        }
        if (statement) {
          var _node$trailingComment2;
          if (!((_node$trailingComment2 = node2.trailingComments) != null && _node$trailingComment2.length)) {
            this._lastCommentLine = 0;
          }
          if (i + 1 === len) {
            this.newline(1);
          } else {
            var _nextNode$loc;
            const nextNode = nodes[i + 1];
            newlineOpts.nextNodeStartLine = ((_nextNode$loc = nextNode.loc) == null ? void 0 : _nextNode$loc.start.line) || 0;
            this._printNewline(true, newlineOpts);
          }
        }
      }
      if (indent) this.dedent();
    }
    printAndIndentOnComments(node2) {
      const indent = node2.leadingComments && node2.leadingComments.length > 0;
      if (indent) this.indent();
      this.print(node2);
      if (indent) this.dedent();
    }
    printBlock(parent) {
      const node2 = parent.body;
      if (node2.type !== "EmptyStatement") {
        this.space();
      }
      this.print(node2);
    }
    _printTrailingComments(node2, parent, lineOffset) {
      const {
        innerComments,
        trailingComments
      } = node2;
      if (innerComments != null && innerComments.length) {
        this._printComments(2, innerComments, node2, parent, lineOffset);
      }
      if (trailingComments != null && trailingComments.length) {
        this._printComments(2, trailingComments, node2, parent, lineOffset);
      }
    }
    _printLeadingComments(node2, parent) {
      const comments2 = node2.leadingComments;
      if (!(comments2 != null && comments2.length)) return;
      this._printComments(0, comments2, node2, parent);
    }
    _maybePrintInnerComments(nextTokenStr, nextTokenOccurrenceCount) {
      if (this._endsWithInnerRaw) {
        var _this$tokenMap;
        this.printInnerComments((_this$tokenMap = this.tokenMap) == null ? void 0 : _this$tokenMap.findMatching(this._currentNode, nextTokenStr, nextTokenOccurrenceCount));
      }
      this._endsWithInnerRaw = true;
      this._indentInnerComments = true;
    }
    printInnerComments(nextToken) {
      const node2 = this._currentNode;
      const comments2 = node2.innerComments;
      if (!(comments2 != null && comments2.length)) return;
      const hasSpace = this.endsWith(32);
      const indent = this._indentInnerComments;
      const printedCommentsCount = this._printedComments.size;
      if (indent) this.indent();
      this._printComments(1, comments2, node2, void 0, void 0, nextToken);
      if (hasSpace && printedCommentsCount !== this._printedComments.size) {
        this.space();
      }
      if (indent) this.dedent();
    }
    noIndentInnerCommentsHere() {
      this._indentInnerComments = false;
    }
    printSequence(nodes, indent, trailingCommentsLineOffset) {
      this.printJoin(nodes, true, indent != null ? indent : false, void 0, void 0, void 0, trailingCommentsLineOffset);
    }
    printList(items, printTrailingSeparator, statement, indent, separator, iterator) {
      this.printJoin(items, statement, indent, separator != null ? separator : commaSeparator, printTrailingSeparator, iterator);
    }
    shouldPrintTrailingComma(listEnd) {
      if (!this.tokenMap) return null;
      const listEndIndex = this.tokenMap.findLastIndex(this._currentNode, (token) => this.tokenMap.matchesOriginal(token, listEnd));
      if (listEndIndex <= 0) return null;
      return this.tokenMap.matchesOriginal(this._tokens[listEndIndex - 1], ",");
    }
    _printNewline(newLine, opts) {
      const format = this.format;
      if (format.retainLines || format.compact) return;
      if (format.concise) {
        this.space();
        return;
      }
      if (!newLine) {
        return;
      }
      const startLine = opts.nextNodeStartLine;
      const lastCommentLine = this._lastCommentLine;
      if (startLine > 0 && lastCommentLine > 0) {
        const offset = startLine - lastCommentLine;
        if (offset >= 0) {
          this.newline(offset || 1);
          return;
        }
      }
      if (this._buf.hasContent()) {
        this.newline(1);
      }
    }
    _shouldPrintComment(comment, nextToken) {
      if (comment.ignore) return 0;
      if (this._printedComments.has(comment)) return 0;
      if (this._noLineTerminator && HAS_NEWLINE_OR_BlOCK_COMMENT_END.test(comment.value)) {
        return 2;
      }
      if (nextToken && this.tokenMap) {
        const commentTok = this.tokenMap.find(this._currentNode, (token) => token.value === comment.value);
        if (commentTok && commentTok.start > nextToken.start) {
          return 2;
        }
      }
      this._printedComments.add(comment);
      if (!this.format.shouldPrintComment(comment.value)) {
        return 0;
      }
      return 1;
    }
    _printComment(comment, skipNewLines) {
      const noLineTerminator = this._noLineTerminator;
      const isBlockComment = comment.type === "CommentBlock";
      const printNewLines = isBlockComment && skipNewLines !== 1 && !this._noLineTerminator;
      if (printNewLines && this._buf.hasContent() && skipNewLines !== 2) {
        this.newline(1);
      }
      const lastCharCode = this.getLastChar();
      if (lastCharCode !== 91 && lastCharCode !== 123 && lastCharCode !== 40) {
        this.space();
      }
      let val;
      if (isBlockComment) {
        val = `/*${comment.value}*/`;
        if (this.format.indent.adjustMultilineComment) {
          var _comment$loc;
          const offset = (_comment$loc = comment.loc) == null ? void 0 : _comment$loc.start.column;
          if (offset) {
            const newlineRegex = new RegExp("\\n\\s{1," + offset + "}", "g");
            val = val.replace(newlineRegex, "\n");
          }
          if (this.format.concise) {
            val = val.replace(/\n(?!$)/g, `
`);
          } else {
            let indentSize = this.format.retainLines ? 0 : this._buf.getCurrentColumn();
            if (this._shouldIndent(47) || this.format.retainLines) {
              indentSize += this._getIndent();
            }
            val = val.replace(/\n(?!$)/g, `
${" ".repeat(indentSize)}`);
          }
        }
      } else if (!noLineTerminator) {
        val = `//${comment.value}`;
      } else {
        val = `/*${comment.value}*/`;
      }
      if (this._endsWithDiv) this._space();
      if (this.tokenMap) {
        const {
          _printSemicolonBeforeNextToken,
          _printSemicolonBeforeNextNode
        } = this;
        this._printSemicolonBeforeNextToken = -1;
        this._printSemicolonBeforeNextNode = -1;
        this.source("start", comment.loc);
        this._append(val, isBlockComment);
        this._printSemicolonBeforeNextNode = _printSemicolonBeforeNextNode;
        this._printSemicolonBeforeNextToken = _printSemicolonBeforeNextToken;
      } else {
        this.source("start", comment.loc);
        this._append(val, isBlockComment);
      }
      if (!isBlockComment && !noLineTerminator) {
        this.newline(1, true);
      }
      if (printNewLines && skipNewLines !== 3) {
        this.newline(1);
      }
    }
    _printComments(type, comments2, node2, parent, lineOffset = 0, nextToken) {
      const nodeLoc = node2.loc;
      const len = comments2.length;
      let hasLoc = !!nodeLoc;
      const nodeStartLine = hasLoc ? nodeLoc.start.line : 0;
      const nodeEndLine = hasLoc ? nodeLoc.end.line : 0;
      let lastLine = 0;
      let leadingCommentNewline = 0;
      const maybeNewline = this._noLineTerminator ? function() {
      } : this.newline.bind(this);
      for (let i = 0; i < len; i++) {
        const comment = comments2[i];
        const shouldPrint = this._shouldPrintComment(comment, nextToken);
        if (shouldPrint === 2) {
          hasLoc = false;
          break;
        }
        if (hasLoc && comment.loc && shouldPrint === 1) {
          const commentStartLine = comment.loc.start.line;
          const commentEndLine = comment.loc.end.line;
          if (type === 0) {
            let offset = 0;
            if (i === 0) {
              if (this._buf.hasContent() && (comment.type === "CommentLine" || commentStartLine !== commentEndLine)) {
                offset = leadingCommentNewline = 1;
              }
            } else {
              offset = commentStartLine - lastLine;
            }
            lastLine = commentEndLine;
            maybeNewline(offset);
            this._printComment(comment, 1);
            if (i + 1 === len) {
              maybeNewline(Math.max(nodeStartLine - lastLine, leadingCommentNewline));
              lastLine = nodeStartLine;
            }
          } else if (type === 1) {
            const offset = commentStartLine - (i === 0 ? nodeStartLine : lastLine);
            lastLine = commentEndLine;
            maybeNewline(offset);
            this._printComment(comment, 1);
            if (i + 1 === len) {
              maybeNewline(Math.min(1, nodeEndLine - lastLine));
              lastLine = nodeEndLine;
            }
          } else {
            const offset = commentStartLine - (i === 0 ? nodeEndLine - lineOffset : lastLine);
            lastLine = commentEndLine;
            maybeNewline(offset);
            this._printComment(comment, 1);
          }
        } else {
          hasLoc = false;
          if (shouldPrint !== 1) {
            continue;
          }
          if (len === 1) {
            const singleLine = comment.loc ? comment.loc.start.line === comment.loc.end.line : !HAS_NEWLINE.test(comment.value);
            const shouldSkipNewline = singleLine && !isStatement(node2) && !isClassBody(parent) && !isTSInterfaceBody(parent) && !isTSEnumMember(node2);
            if (type === 0) {
              this._printComment(comment, shouldSkipNewline && node2.type !== "ObjectExpression" || singleLine && isFunction(parent, {
                body: node2
              }) ? 1 : 0);
            } else if (shouldSkipNewline && type === 2) {
              this._printComment(comment, 1);
            } else {
              this._printComment(comment, 0);
            }
          } else if (type === 1 && !(node2.type === "ObjectExpression" && node2.properties.length > 1) && node2.type !== "ClassBody" && node2.type !== "TSInterfaceBody") {
            this._printComment(comment, i === 0 ? 2 : i === len - 1 ? 3 : 0);
          } else {
            this._printComment(comment, 0);
          }
        }
      }
      if (type === 2 && hasLoc && lastLine) {
        this._lastCommentLine = lastLine;
      }
    }
  }
  Object.assign(Printer.prototype, generatorFunctions);
  {
    (0, _deprecated.addDeprecatedGenerators)(Printer);
  }
  printer.default = Printer;
  function commaSeparator(occurrenceCount, last) {
    this.token(",", false, occurrenceCount);
    if (!last) this.space();
  }
  return printer;
}
var hasRequiredLib$3;
function requireLib$3() {
  if (hasRequiredLib$3) return lib$2;
  hasRequiredLib$3 = 1;
  Object.defineProperty(lib$2, "__esModule", {
    value: true
  });
  lib$2.default = void 0;
  lib$2.generate = generate;
  var _sourceMap = requireSourceMap();
  var _printer = requirePrinter();
  function normalizeOptions(code, opts, ast) {
    if (opts.experimental_preserveFormat) {
      if (typeof code !== "string") {
        throw new Error("`experimental_preserveFormat` requires the original `code` to be passed to @babel/generator as a string");
      }
      if (!opts.retainLines) {
        throw new Error("`experimental_preserveFormat` requires `retainLines` to be set to `true`");
      }
      if (opts.compact && opts.compact !== "auto") {
        throw new Error("`experimental_preserveFormat` is not compatible with the `compact` option");
      }
      if (opts.minified) {
        throw new Error("`experimental_preserveFormat` is not compatible with the `minified` option");
      }
      if (opts.jsescOption) {
        throw new Error("`experimental_preserveFormat` is not compatible with the `jsescOption` option");
      }
      if (!Array.isArray(ast.tokens)) {
        throw new Error("`experimental_preserveFormat` requires the AST to have attached the token of the input code. Make sure to enable the `tokens: true` parser option.");
      }
    }
    const format = {
      auxiliaryCommentBefore: opts.auxiliaryCommentBefore,
      auxiliaryCommentAfter: opts.auxiliaryCommentAfter,
      shouldPrintComment: opts.shouldPrintComment,
      preserveFormat: opts.experimental_preserveFormat,
      retainLines: opts.retainLines,
      retainFunctionParens: opts.retainFunctionParens,
      comments: opts.comments == null || opts.comments,
      compact: opts.compact,
      minified: opts.minified,
      concise: opts.concise,
      indent: {
        adjustMultilineComment: true,
        style: "  "
      },
      jsescOption: Object.assign({
        quotes: "double",
        wrap: true,
        minimal: false
      }, opts.jsescOption),
      topicToken: opts.topicToken,
      importAttributesKeyword: opts.importAttributesKeyword
    };
    {
      var _opts$recordAndTupleS;
      format.decoratorsBeforeExport = opts.decoratorsBeforeExport;
      format.jsescOption.json = opts.jsonCompatibleStrings;
      format.recordAndTupleSyntaxType = (_opts$recordAndTupleS = opts.recordAndTupleSyntaxType) != null ? _opts$recordAndTupleS : "hash";
    }
    if (format.minified) {
      format.compact = true;
      format.shouldPrintComment = format.shouldPrintComment || (() => format.comments);
    } else {
      format.shouldPrintComment = format.shouldPrintComment || ((value) => format.comments || value.includes("@license") || value.includes("@preserve"));
    }
    if (format.compact === "auto") {
      format.compact = typeof code === "string" && code.length > 5e5;
      if (format.compact) {
        console.error(`[BABEL] Note: The code generator has deoptimised the styling of ${opts.filename} as it exceeds the max of ${"500KB"}.`);
      }
    }
    if (format.compact || format.preserveFormat) {
      format.indent.adjustMultilineComment = false;
    }
    const {
      auxiliaryCommentBefore,
      auxiliaryCommentAfter,
      shouldPrintComment
    } = format;
    if (auxiliaryCommentBefore && !shouldPrintComment(auxiliaryCommentBefore)) {
      format.auxiliaryCommentBefore = void 0;
    }
    if (auxiliaryCommentAfter && !shouldPrintComment(auxiliaryCommentAfter)) {
      format.auxiliaryCommentAfter = void 0;
    }
    return format;
  }
  {
    lib$2.CodeGenerator = class CodeGenerator {
      constructor(ast, opts = {}, code) {
        this._ast = void 0;
        this._format = void 0;
        this._map = void 0;
        this._ast = ast;
        this._format = normalizeOptions(code, opts, ast);
        this._map = opts.sourceMaps ? new _sourceMap.default(opts, code) : null;
      }
      generate() {
        const printer2 = new _printer.default(this._format, this._map);
        return printer2.generate(this._ast);
      }
    };
  }
  function generate(ast, opts = {}, code) {
    const format = normalizeOptions(code, opts, ast);
    const map = opts.sourceMaps ? new _sourceMap.default(opts, code) : null;
    const printer2 = new _printer.default(format, map, ast.tokens, typeof code === "string" ? code : null);
    return printer2.generate(ast);
  }
  lib$2.default = generate;
  return lib$2;
}
var ancestry = {};
var hasRequiredAncestry;
function requireAncestry() {
  if (hasRequiredAncestry) return ancestry;
  hasRequiredAncestry = 1;
  Object.defineProperty(ancestry, "__esModule", {
    value: true
  });
  ancestry.find = find;
  ancestry.findParent = findParent;
  ancestry.getAncestry = getAncestry;
  ancestry.getDeepestCommonAncestorFrom = getDeepestCommonAncestorFrom;
  ancestry.getEarliestCommonAncestorFrom = getEarliestCommonAncestorFrom;
  ancestry.getFunctionParent = getFunctionParent;
  ancestry.getStatementParent = getStatementParent;
  ancestry.inType = inType;
  ancestry.isAncestor = isAncestor;
  ancestry.isDescendant = isDescendant;
  var _t = requireLib$4();
  const {
    VISITOR_KEYS
  } = _t;
  function findParent(callback) {
    let path2 = this;
    while (path2 = path2.parentPath) {
      if (callback(path2)) return path2;
    }
    return null;
  }
  function find(callback) {
    let path2 = this;
    do {
      if (callback(path2)) return path2;
    } while (path2 = path2.parentPath);
    return null;
  }
  function getFunctionParent() {
    return this.findParent((p) => p.isFunction());
  }
  function getStatementParent() {
    let path2 = this;
    do {
      if (!path2.parentPath || Array.isArray(path2.container) && path2.isStatement()) {
        break;
      } else {
        path2 = path2.parentPath;
      }
    } while (path2);
    if (path2 && (path2.isProgram() || path2.isFile())) {
      throw new Error("File/Program node, we can't possibly find a statement parent to this");
    }
    return path2;
  }
  function getEarliestCommonAncestorFrom(paths) {
    return this.getDeepestCommonAncestorFrom(paths, function(deepest, i, ancestries) {
      let earliest;
      const keys = VISITOR_KEYS[deepest.type];
      for (const ancestry2 of ancestries) {
        const path2 = ancestry2[i + 1];
        if (!earliest) {
          earliest = path2;
          continue;
        }
        if (path2.listKey && earliest.listKey === path2.listKey) {
          if (path2.key < earliest.key) {
            earliest = path2;
            continue;
          }
        }
        const earliestKeyIndex = keys.indexOf(earliest.parentKey);
        const currentKeyIndex = keys.indexOf(path2.parentKey);
        if (earliestKeyIndex > currentKeyIndex) {
          earliest = path2;
        }
      }
      return earliest;
    });
  }
  function getDeepestCommonAncestorFrom(paths, filter) {
    if (!paths.length) {
      return this;
    }
    if (paths.length === 1) {
      return paths[0];
    }
    let minDepth = Infinity;
    let lastCommonIndex, lastCommon;
    const ancestries = paths.map((path2) => {
      const ancestry2 = [];
      do {
        ancestry2.unshift(path2);
      } while ((path2 = path2.parentPath) && path2 !== this);
      if (ancestry2.length < minDepth) {
        minDepth = ancestry2.length;
      }
      return ancestry2;
    });
    const first = ancestries[0];
    depthLoop: for (let i = 0; i < minDepth; i++) {
      const shouldMatch = first[i];
      for (const ancestry2 of ancestries) {
        if (ancestry2[i] !== shouldMatch) {
          break depthLoop;
        }
      }
      lastCommonIndex = i;
      lastCommon = shouldMatch;
    }
    if (lastCommon) {
      if (filter) {
        return filter(lastCommon, lastCommonIndex, ancestries);
      } else {
        return lastCommon;
      }
    } else {
      throw new Error("Couldn't find intersection");
    }
  }
  function getAncestry() {
    let path2 = this;
    const paths = [];
    do {
      paths.push(path2);
    } while (path2 = path2.parentPath);
    return paths;
  }
  function isAncestor(maybeDescendant) {
    return maybeDescendant.isDescendant(this);
  }
  function isDescendant(maybeAncestor) {
    return !!this.findParent((parent) => parent === maybeAncestor);
  }
  function inType(...candidateTypes) {
    let path2 = this;
    while (path2) {
      if (candidateTypes.includes(path2.node.type)) return true;
      path2 = path2.parentPath;
    }
    return false;
  }
  return ancestry;
}
var inference = {};
var inferers = {};
var infererReference = {};
var util = {};
var hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil) return util;
  hasRequiredUtil = 1;
  Object.defineProperty(util, "__esModule", {
    value: true
  });
  util.createUnionType = createUnionType;
  var _t = requireLib$4();
  const {
    createFlowUnionType: createFlowUnionType2,
    createTSUnionType: createTSUnionType2,
    createUnionTypeAnnotation,
    isFlowType,
    isTSType
  } = _t;
  function createUnionType(types2) {
    {
      if (types2.every((v) => isFlowType(v))) {
        if (createFlowUnionType2) {
          return createFlowUnionType2(types2);
        }
        return createUnionTypeAnnotation(types2);
      } else if (types2.every((v) => isTSType(v))) {
        if (createTSUnionType2) {
          return createTSUnionType2(types2);
        }
      }
    }
  }
  return util;
}
var hasRequiredInfererReference;
function requireInfererReference() {
  if (hasRequiredInfererReference) return infererReference;
  hasRequiredInfererReference = 1;
  Object.defineProperty(infererReference, "__esModule", {
    value: true
  });
  infererReference.default = _default;
  var _t = requireLib$4();
  var _util = requireUtil();
  const {
    BOOLEAN_NUMBER_BINARY_OPERATORS,
    createTypeAnnotationBasedOnTypeof: createTypeAnnotationBasedOnTypeof2,
    numberTypeAnnotation,
    voidTypeAnnotation
  } = _t;
  function _default(node2) {
    if (!this.isReferenced()) return;
    const binding2 = this.scope.getBinding(node2.name);
    if (binding2) {
      if (binding2.identifier.typeAnnotation) {
        return binding2.identifier.typeAnnotation;
      } else {
        return getTypeAnnotationBindingConstantViolations(binding2, this, node2.name);
      }
    }
    if (node2.name === "undefined") {
      return voidTypeAnnotation();
    } else if (node2.name === "NaN" || node2.name === "Infinity") {
      return numberTypeAnnotation();
    } else if (node2.name === "arguments") ;
  }
  function getTypeAnnotationBindingConstantViolations(binding2, path2, name) {
    const types2 = [];
    const functionConstantViolations = [];
    let constantViolations = getConstantViolationsBefore(binding2, path2, functionConstantViolations);
    const testType = getConditionalAnnotation(binding2, path2, name);
    if (testType) {
      const testConstantViolations = getConstantViolationsBefore(binding2, testType.ifStatement);
      constantViolations = constantViolations.filter((path3) => !testConstantViolations.includes(path3));
      types2.push(testType.typeAnnotation);
    }
    if (constantViolations.length) {
      constantViolations.push(...functionConstantViolations);
      for (const violation of constantViolations) {
        types2.push(violation.getTypeAnnotation());
      }
    }
    if (!types2.length) {
      return;
    }
    return (0, _util.createUnionType)(types2);
  }
  function getConstantViolationsBefore(binding2, path2, functions) {
    const violations = binding2.constantViolations.slice();
    violations.unshift(binding2.path);
    return violations.filter((violation) => {
      violation = violation.resolve();
      const status = violation._guessExecutionStatusRelativeTo(path2);
      if (functions && status === "unknown") functions.push(violation);
      return status === "before";
    });
  }
  function inferAnnotationFromBinaryExpression(name, path2) {
    const operator = path2.node.operator;
    const right = path2.get("right").resolve();
    const left = path2.get("left").resolve();
    let target;
    if (left.isIdentifier({
      name
    })) {
      target = right;
    } else if (right.isIdentifier({
      name
    })) {
      target = left;
    }
    if (target) {
      if (operator === "===") {
        return target.getTypeAnnotation();
      }
      if (BOOLEAN_NUMBER_BINARY_OPERATORS.includes(operator)) {
        return numberTypeAnnotation();
      }
      return;
    }
    if (operator !== "===" && operator !== "==") return;
    let typeofPath;
    let typePath;
    if (left.isUnaryExpression({
      operator: "typeof"
    })) {
      typeofPath = left;
      typePath = right;
    } else if (right.isUnaryExpression({
      operator: "typeof"
    })) {
      typeofPath = right;
      typePath = left;
    }
    if (!typeofPath) return;
    if (!typeofPath.get("argument").isIdentifier({
      name
    })) return;
    typePath = typePath.resolve();
    if (!typePath.isLiteral()) return;
    const typeValue = typePath.node.value;
    if (typeof typeValue !== "string") return;
    return createTypeAnnotationBasedOnTypeof2(typeValue);
  }
  function getParentConditionalPath(binding2, path2, name) {
    let parentPath;
    while (parentPath = path2.parentPath) {
      if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) {
        if (path2.key === "test") {
          return;
        }
        return parentPath;
      }
      if (parentPath.isFunction()) {
        if (name == null || parentPath.parentPath.scope.getBinding(name) !== binding2) return;
      }
      path2 = parentPath;
    }
  }
  function getConditionalAnnotation(binding2, path2, name) {
    const ifStatement = getParentConditionalPath(binding2, path2, name);
    if (!ifStatement) return;
    const test = ifStatement.get("test");
    const paths = [test];
    const types2 = [];
    for (let i = 0; i < paths.length; i++) {
      const path3 = paths[i];
      if (path3.isLogicalExpression()) {
        if (path3.node.operator === "&&") {
          paths.push(path3.get("left"));
          paths.push(path3.get("right"));
        }
      } else if (path3.isBinaryExpression()) {
        const type = inferAnnotationFromBinaryExpression(name, path3);
        if (type) types2.push(type);
      }
    }
    if (types2.length) {
      return {
        typeAnnotation: (0, _util.createUnionType)(types2),
        ifStatement
      };
    }
    return getConditionalAnnotation(binding2, ifStatement, name);
  }
  return infererReference;
}
var hasRequiredInferers;
function requireInferers() {
  if (hasRequiredInferers) return inferers;
  hasRequiredInferers = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", {
      value: true
    });
    exports$1.ArrayExpression = ArrayExpression;
    exports$1.AssignmentExpression = AssignmentExpression;
    exports$1.BinaryExpression = BinaryExpression;
    exports$1.BooleanLiteral = BooleanLiteral;
    exports$1.CallExpression = CallExpression;
    exports$1.ConditionalExpression = ConditionalExpression;
    exports$1.ClassDeclaration = exports$1.ClassExpression = exports$1.FunctionDeclaration = exports$1.ArrowFunctionExpression = exports$1.FunctionExpression = Func;
    Object.defineProperty(exports$1, "Identifier", {
      enumerable: true,
      get: function() {
        return _infererReference.default;
      }
    });
    exports$1.LogicalExpression = LogicalExpression;
    exports$1.NewExpression = NewExpression;
    exports$1.NullLiteral = NullLiteral;
    exports$1.NumericLiteral = NumericLiteral;
    exports$1.ObjectExpression = ObjectExpression;
    exports$1.ParenthesizedExpression = ParenthesizedExpression;
    exports$1.RegExpLiteral = RegExpLiteral;
    exports$1.RestElement = RestElement;
    exports$1.SequenceExpression = SequenceExpression;
    exports$1.StringLiteral = StringLiteral;
    exports$1.TSAsExpression = TSAsExpression;
    exports$1.TSNonNullExpression = TSNonNullExpression;
    exports$1.TaggedTemplateExpression = TaggedTemplateExpression;
    exports$1.TemplateLiteral = TemplateLiteral;
    exports$1.TypeCastExpression = TypeCastExpression;
    exports$1.UnaryExpression = UnaryExpression;
    exports$1.UpdateExpression = UpdateExpression;
    exports$1.VariableDeclarator = VariableDeclarator;
    var _t = requireLib$4();
    var _infererReference = requireInfererReference();
    var _util = requireUtil();
    const {
      BOOLEAN_BINARY_OPERATORS,
      BOOLEAN_UNARY_OPERATORS,
      NUMBER_BINARY_OPERATORS,
      NUMBER_UNARY_OPERATORS,
      STRING_UNARY_OPERATORS,
      anyTypeAnnotation,
      arrayTypeAnnotation,
      booleanTypeAnnotation,
      buildMatchMemberExpression: buildMatchMemberExpression2,
      genericTypeAnnotation,
      identifier: identifier2,
      nullLiteralTypeAnnotation,
      numberTypeAnnotation,
      stringTypeAnnotation,
      tupleTypeAnnotation,
      unionTypeAnnotation,
      voidTypeAnnotation,
      isIdentifier
    } = _t;
    function VariableDeclarator() {
      if (!this.get("id").isIdentifier()) return;
      return this.get("init").getTypeAnnotation();
    }
    function TypeCastExpression(node2) {
      return node2.typeAnnotation;
    }
    TypeCastExpression.validParent = true;
    function TSAsExpression(node2) {
      return node2.typeAnnotation;
    }
    TSAsExpression.validParent = true;
    function TSNonNullExpression() {
      return this.get("expression").getTypeAnnotation();
    }
    function NewExpression(node2) {
      if (node2.callee.type === "Identifier") {
        return genericTypeAnnotation(node2.callee);
      }
    }
    function TemplateLiteral() {
      return stringTypeAnnotation();
    }
    function UnaryExpression(node2) {
      const operator = node2.operator;
      if (operator === "void") {
        return voidTypeAnnotation();
      } else if (NUMBER_UNARY_OPERATORS.includes(operator)) {
        return numberTypeAnnotation();
      } else if (STRING_UNARY_OPERATORS.includes(operator)) {
        return stringTypeAnnotation();
      } else if (BOOLEAN_UNARY_OPERATORS.includes(operator)) {
        return booleanTypeAnnotation();
      }
    }
    function BinaryExpression(node2) {
      const operator = node2.operator;
      if (NUMBER_BINARY_OPERATORS.includes(operator)) {
        return numberTypeAnnotation();
      } else if (BOOLEAN_BINARY_OPERATORS.includes(operator)) {
        return booleanTypeAnnotation();
      } else if (operator === "+") {
        const right = this.get("right");
        const left = this.get("left");
        if (left.isBaseType("number") && right.isBaseType("number")) {
          return numberTypeAnnotation();
        } else if (left.isBaseType("string") || right.isBaseType("string")) {
          return stringTypeAnnotation();
        }
        return unionTypeAnnotation([stringTypeAnnotation(), numberTypeAnnotation()]);
      }
    }
    function LogicalExpression() {
      const argumentTypes = [this.get("left").getTypeAnnotation(), this.get("right").getTypeAnnotation()];
      return (0, _util.createUnionType)(argumentTypes);
    }
    function ConditionalExpression() {
      const argumentTypes = [this.get("consequent").getTypeAnnotation(), this.get("alternate").getTypeAnnotation()];
      return (0, _util.createUnionType)(argumentTypes);
    }
    function SequenceExpression() {
      return this.get("expressions").pop().getTypeAnnotation();
    }
    function ParenthesizedExpression() {
      return this.get("expression").getTypeAnnotation();
    }
    function AssignmentExpression() {
      return this.get("right").getTypeAnnotation();
    }
    function UpdateExpression(node2) {
      const operator = node2.operator;
      if (operator === "++" || operator === "--") {
        return numberTypeAnnotation();
      }
    }
    function StringLiteral() {
      return stringTypeAnnotation();
    }
    function NumericLiteral() {
      return numberTypeAnnotation();
    }
    function BooleanLiteral() {
      return booleanTypeAnnotation();
    }
    function NullLiteral() {
      return nullLiteralTypeAnnotation();
    }
    function RegExpLiteral() {
      return genericTypeAnnotation(identifier2("RegExp"));
    }
    function ObjectExpression() {
      return genericTypeAnnotation(identifier2("Object"));
    }
    function ArrayExpression() {
      return genericTypeAnnotation(identifier2("Array"));
    }
    function RestElement() {
      return ArrayExpression();
    }
    RestElement.validParent = true;
    function Func() {
      return genericTypeAnnotation(identifier2("Function"));
    }
    const isArrayFrom = buildMatchMemberExpression2("Array.from");
    const isObjectKeys = buildMatchMemberExpression2("Object.keys");
    const isObjectValues = buildMatchMemberExpression2("Object.values");
    const isObjectEntries = buildMatchMemberExpression2("Object.entries");
    function CallExpression() {
      const {
        callee
      } = this.node;
      if (isObjectKeys(callee)) {
        return arrayTypeAnnotation(stringTypeAnnotation());
      } else if (isArrayFrom(callee) || isObjectValues(callee) || isIdentifier(callee, {
        name: "Array"
      })) {
        return arrayTypeAnnotation(anyTypeAnnotation());
      } else if (isObjectEntries(callee)) {
        return arrayTypeAnnotation(tupleTypeAnnotation([stringTypeAnnotation(), anyTypeAnnotation()]));
      }
      return resolveCall(this.get("callee"));
    }
    function TaggedTemplateExpression() {
      return resolveCall(this.get("tag"));
    }
    function resolveCall(callee) {
      callee = callee.resolve();
      if (callee.isFunction()) {
        const {
          node: node2
        } = callee;
        if (node2.async) {
          if (node2.generator) {
            return genericTypeAnnotation(identifier2("AsyncIterator"));
          } else {
            return genericTypeAnnotation(identifier2("Promise"));
          }
        } else {
          if (node2.generator) {
            return genericTypeAnnotation(identifier2("Iterator"));
          } else if (callee.node.returnType) {
            return callee.node.returnType;
          } else ;
        }
      }
    }
  })(inferers);
  return inferers;
}
var hasRequiredInference;
function requireInference() {
  if (hasRequiredInference) return inference;
  hasRequiredInference = 1;
  Object.defineProperty(inference, "__esModule", {
    value: true
  });
  inference._getTypeAnnotation = _getTypeAnnotation;
  inference.baseTypeStrictlyMatches = baseTypeStrictlyMatches;
  inference.couldBeBaseType = couldBeBaseType;
  inference.getTypeAnnotation = getTypeAnnotation;
  inference.isBaseType = isBaseType;
  inference.isGenericType = isGenericType;
  var inferers2 = requireInferers();
  var _t = requireLib$4();
  const {
    anyTypeAnnotation,
    isAnyTypeAnnotation,
    isArrayTypeAnnotation,
    isBooleanTypeAnnotation,
    isEmptyTypeAnnotation,
    isFlowBaseAnnotation,
    isGenericTypeAnnotation,
    isIdentifier,
    isMixedTypeAnnotation,
    isNumberTypeAnnotation,
    isStringTypeAnnotation,
    isTSArrayType,
    isTSTypeAnnotation,
    isTSTypeReference,
    isTupleTypeAnnotation,
    isTypeAnnotation,
    isUnionTypeAnnotation,
    isVoidTypeAnnotation,
    stringTypeAnnotation,
    voidTypeAnnotation
  } = _t;
  function getTypeAnnotation() {
    let type = this.getData("typeAnnotation");
    if (type != null) {
      return type;
    }
    type = _getTypeAnnotation.call(this) || anyTypeAnnotation();
    if (isTypeAnnotation(type) || isTSTypeAnnotation(type)) {
      type = type.typeAnnotation;
    }
    this.setData("typeAnnotation", type);
    return type;
  }
  const typeAnnotationInferringNodes = /* @__PURE__ */ new WeakSet();
  function _getTypeAnnotation() {
    const node2 = this.node;
    if (!node2) {
      if (this.key === "init" && this.parentPath.isVariableDeclarator()) {
        const declar = this.parentPath.parentPath;
        const declarParent = declar.parentPath;
        if (declar.key === "left" && declarParent.isForInStatement()) {
          return stringTypeAnnotation();
        }
        if (declar.key === "left" && declarParent.isForOfStatement()) {
          return anyTypeAnnotation();
        }
        return voidTypeAnnotation();
      } else {
        return;
      }
    }
    if (node2.typeAnnotation) {
      return node2.typeAnnotation;
    }
    if (typeAnnotationInferringNodes.has(node2)) {
      return;
    }
    typeAnnotationInferringNodes.add(node2);
    try {
      var _inferer;
      let inferer = inferers2[node2.type];
      if (inferer) {
        return inferer.call(this, node2);
      }
      inferer = inferers2[this.parentPath.type];
      if ((_inferer = inferer) != null && _inferer.validParent) {
        return this.parentPath.getTypeAnnotation();
      }
    } finally {
      typeAnnotationInferringNodes.delete(node2);
    }
  }
  function isBaseType(baseName, soft) {
    return _isBaseType(baseName, this.getTypeAnnotation(), soft);
  }
  function _isBaseType(baseName, type, soft) {
    if (baseName === "string") {
      return isStringTypeAnnotation(type);
    } else if (baseName === "number") {
      return isNumberTypeAnnotation(type);
    } else if (baseName === "boolean") {
      return isBooleanTypeAnnotation(type);
    } else if (baseName === "any") {
      return isAnyTypeAnnotation(type);
    } else if (baseName === "mixed") {
      return isMixedTypeAnnotation(type);
    } else if (baseName === "empty") {
      return isEmptyTypeAnnotation(type);
    } else if (baseName === "void") {
      return isVoidTypeAnnotation(type);
    } else {
      if (soft) {
        return false;
      } else {
        throw new Error(`Unknown base type ${baseName}`);
      }
    }
  }
  function couldBeBaseType(name) {
    const type = this.getTypeAnnotation();
    if (isAnyTypeAnnotation(type)) return true;
    if (isUnionTypeAnnotation(type)) {
      for (const type2 of type.types) {
        if (isAnyTypeAnnotation(type2) || _isBaseType(name, type2, true)) {
          return true;
        }
      }
      return false;
    } else {
      return _isBaseType(name, type, true);
    }
  }
  function baseTypeStrictlyMatches(rightArg) {
    const left = this.getTypeAnnotation();
    const right = rightArg.getTypeAnnotation();
    if (!isAnyTypeAnnotation(left) && isFlowBaseAnnotation(left)) {
      return right.type === left.type;
    }
    return false;
  }
  function isGenericType(genericName) {
    const type = this.getTypeAnnotation();
    if (genericName === "Array") {
      if (isTSArrayType(type) || isArrayTypeAnnotation(type) || isTupleTypeAnnotation(type)) {
        return true;
      }
    }
    return isGenericTypeAnnotation(type) && isIdentifier(type.id, {
      name: genericName
    }) || isTSTypeReference(type) && isIdentifier(type.typeName, {
      name: genericName
    });
  }
  return inference;
}
var replacement = {};
var lib$1 = {};
var picocolors = { exports: {} };
var hasRequiredPicocolors;
function requirePicocolors() {
  if (hasRequiredPicocolors) return picocolors.exports;
  hasRequiredPicocolors = 1;
  let p = process || {}, argv = p.argv || [], env = p.env || {};
  let isColorSupported = !(!!env.NO_COLOR || argv.includes("--no-color")) && (!!env.FORCE_COLOR || argv.includes("--color") || p.platform === "win32" || (p.stdout || {}).isTTY && env.TERM !== "dumb" || !!env.CI);
  let formatter = (open, close, replace = open) => (input) => {
    let string2 = "" + input, index = string2.indexOf(close, open.length);
    return ~index ? open + replaceClose(string2, close, replace, index) + close : open + string2 + close;
  };
  let replaceClose = (string2, close, replace, index) => {
    let result = "", cursor = 0;
    do {
      result += string2.substring(cursor, index) + replace;
      cursor = index + close.length;
      index = string2.indexOf(close, cursor);
    } while (~index);
    return result + string2.substring(cursor);
  };
  let createColors = (enabled = isColorSupported) => {
    let f = enabled ? formatter : () => String;
    return {
      isColorSupported: enabled,
      reset: f("\x1B[0m", "\x1B[0m"),
      bold: f("\x1B[1m", "\x1B[22m", "\x1B[22m\x1B[1m"),
      dim: f("\x1B[2m", "\x1B[22m", "\x1B[22m\x1B[2m"),
      italic: f("\x1B[3m", "\x1B[23m"),
      underline: f("\x1B[4m", "\x1B[24m"),
      inverse: f("\x1B[7m", "\x1B[27m"),
      hidden: f("\x1B[8m", "\x1B[28m"),
      strikethrough: f("\x1B[9m", "\x1B[29m"),
      black: f("\x1B[30m", "\x1B[39m"),
      red: f("\x1B[31m", "\x1B[39m"),
      green: f("\x1B[32m", "\x1B[39m"),
      yellow: f("\x1B[33m", "\x1B[39m"),
      blue: f("\x1B[34m", "\x1B[39m"),
      magenta: f("\x1B[35m", "\x1B[39m"),
      cyan: f("\x1B[36m", "\x1B[39m"),
      white: f("\x1B[37m", "\x1B[39m"),
      gray: f("\x1B[90m", "\x1B[39m"),
      bgBlack: f("\x1B[40m", "\x1B[49m"),
      bgRed: f("\x1B[41m", "\x1B[49m"),
      bgGreen: f("\x1B[42m", "\x1B[49m"),
      bgYellow: f("\x1B[43m", "\x1B[49m"),
      bgBlue: f("\x1B[44m", "\x1B[49m"),
      bgMagenta: f("\x1B[45m", "\x1B[49m"),
      bgCyan: f("\x1B[46m", "\x1B[49m"),
      bgWhite: f("\x1B[47m", "\x1B[49m"),
      blackBright: f("\x1B[90m", "\x1B[39m"),
      redBright: f("\x1B[91m", "\x1B[39m"),
      greenBright: f("\x1B[92m", "\x1B[39m"),
      yellowBright: f("\x1B[93m", "\x1B[39m"),
      blueBright: f("\x1B[94m", "\x1B[39m"),
      magentaBright: f("\x1B[95m", "\x1B[39m"),
      cyanBright: f("\x1B[96m", "\x1B[39m"),
      whiteBright: f("\x1B[97m", "\x1B[39m"),
      bgBlackBright: f("\x1B[100m", "\x1B[49m"),
      bgRedBright: f("\x1B[101m", "\x1B[49m"),
      bgGreenBright: f("\x1B[102m", "\x1B[49m"),
      bgYellowBright: f("\x1B[103m", "\x1B[49m"),
      bgBlueBright: f("\x1B[104m", "\x1B[49m"),
      bgMagentaBright: f("\x1B[105m", "\x1B[49m"),
      bgCyanBright: f("\x1B[106m", "\x1B[49m"),
      bgWhiteBright: f("\x1B[107m", "\x1B[49m")
    };
  };
  picocolors.exports = createColors();
  picocolors.exports.createColors = createColors;
  return picocolors.exports;
}
var jsTokens = {};
var hasRequiredJsTokens;
function requireJsTokens() {
  if (hasRequiredJsTokens) return jsTokens;
  hasRequiredJsTokens = 1;
  Object.defineProperty(jsTokens, "__esModule", {
    value: true
  });
  jsTokens.default = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g;
  jsTokens.matchToToken = function(match) {
    var token = { type: "invalid", value: match[0], closed: void 0 };
    if (match[1]) token.type = "string", token.closed = !!(match[3] || match[4]);
    else if (match[5]) token.type = "comment";
    else if (match[6]) token.type = "comment", token.closed = !!match[7];
    else if (match[8]) token.type = "regex";
    else if (match[9]) token.type = "number";
    else if (match[10]) token.type = "name";
    else if (match[11]) token.type = "punctuator";
    else if (match[12]) token.type = "whitespace";
    return token;
  };
  return jsTokens;
}
var hasRequiredLib$2;
function requireLib$2() {
  if (hasRequiredLib$2) return lib$1;
  hasRequiredLib$2 = 1;
  Object.defineProperty(lib$1, "__esModule", { value: true });
  var picocolors2 = /* @__PURE__ */ requirePicocolors();
  var jsTokens2 = requireJsTokens();
  var helperValidatorIdentifier = requireLib$6();
  function isColorSupported() {
    return typeof process === "object" && (process.env.FORCE_COLOR === "0" || process.env.FORCE_COLOR === "false") ? false : picocolors2.isColorSupported;
  }
  const compose = (f, g) => (v) => f(g(v));
  function buildDefs(colors) {
    return {
      keyword: colors.cyan,
      capitalized: colors.yellow,
      jsxIdentifier: colors.yellow,
      punctuator: colors.yellow,
      number: colors.magenta,
      string: colors.green,
      regex: colors.magenta,
      comment: colors.gray,
      invalid: compose(compose(colors.white, colors.bgRed), colors.bold),
      gutter: colors.gray,
      marker: compose(colors.red, colors.bold),
      message: compose(colors.red, colors.bold),
      reset: colors.reset
    };
  }
  const defsOn = buildDefs(picocolors2.createColors(true));
  const defsOff = buildDefs(picocolors2.createColors(false));
  function getDefs(enabled) {
    return enabled ? defsOn : defsOff;
  }
  const sometimesKeywords = /* @__PURE__ */ new Set(["as", "async", "from", "get", "of", "set"]);
  const NEWLINE$1 = /\r\n|[\n\r\u2028\u2029]/;
  const BRACKET = /^[()[\]{}]$/;
  let tokenize;
  {
    const JSX_TAG = /^[a-z][\w-]*$/i;
    const getTokenType = function(token, offset, text) {
      if (token.type === "name") {
        if (helperValidatorIdentifier.isKeyword(token.value) || helperValidatorIdentifier.isStrictReservedWord(token.value, true) || sometimesKeywords.has(token.value)) {
          return "keyword";
        }
        if (JSX_TAG.test(token.value) && (text[offset - 1] === "<" || text.slice(offset - 2, offset) === "</")) {
          return "jsxIdentifier";
        }
        if (token.value[0] !== token.value[0].toLowerCase()) {
          return "capitalized";
        }
      }
      if (token.type === "punctuator" && BRACKET.test(token.value)) {
        return "bracket";
      }
      if (token.type === "invalid" && (token.value === "@" || token.value === "#")) {
        return "punctuator";
      }
      return token.type;
    };
    tokenize = function* (text) {
      let match;
      while (match = jsTokens2.default.exec(text)) {
        const token = jsTokens2.matchToToken(match);
        yield {
          type: getTokenType(token, match.index, text),
          value: token.value
        };
      }
    };
  }
  function highlight(text) {
    if (text === "") return "";
    const defs = getDefs(true);
    let highlighted = "";
    for (const {
      type,
      value
    } of tokenize(text)) {
      if (type in defs) {
        highlighted += value.split(NEWLINE$1).map((str) => defs[type](str)).join("\n");
      } else {
        highlighted += value;
      }
    }
    return highlighted;
  }
  let deprecationWarningShown = false;
  const NEWLINE = /\r\n|[\n\r\u2028\u2029]/;
  function getMarkerLines(loc, source, opts) {
    const startLoc = Object.assign({
      column: 0,
      line: -1
    }, loc.start);
    const endLoc = Object.assign({}, startLoc, loc.end);
    const {
      linesAbove = 2,
      linesBelow = 3
    } = opts || {};
    const startLine = startLoc.line;
    const startColumn = startLoc.column;
    const endLine = endLoc.line;
    const endColumn = endLoc.column;
    let start = Math.max(startLine - (linesAbove + 1), 0);
    let end = Math.min(source.length, endLine + linesBelow);
    if (startLine === -1) {
      start = 0;
    }
    if (endLine === -1) {
      end = source.length;
    }
    const lineDiff = endLine - startLine;
    const markerLines = {};
    if (lineDiff) {
      for (let i = 0; i <= lineDiff; i++) {
        const lineNumber = i + startLine;
        if (!startColumn) {
          markerLines[lineNumber] = true;
        } else if (i === 0) {
          const sourceLength = source[lineNumber - 1].length;
          markerLines[lineNumber] = [startColumn, sourceLength - startColumn + 1];
        } else if (i === lineDiff) {
          markerLines[lineNumber] = [0, endColumn];
        } else {
          const sourceLength = source[lineNumber - i].length;
          markerLines[lineNumber] = [0, sourceLength];
        }
      }
    } else {
      if (startColumn === endColumn) {
        if (startColumn) {
          markerLines[startLine] = [startColumn, 0];
        } else {
          markerLines[startLine] = true;
        }
      } else {
        markerLines[startLine] = [startColumn, endColumn - startColumn];
      }
    }
    return {
      start,
      end,
      markerLines
    };
  }
  function codeFrameColumns(rawLines, loc, opts = {}) {
    const shouldHighlight = opts.forceColor || isColorSupported() && opts.highlightCode;
    const defs = getDefs(shouldHighlight);
    const lines = rawLines.split(NEWLINE);
    const {
      start,
      end,
      markerLines
    } = getMarkerLines(loc, lines, opts);
    const hasColumns = loc.start && typeof loc.start.column === "number";
    const numberMaxWidth = String(end).length;
    const highlightedLines = shouldHighlight ? highlight(rawLines) : rawLines;
    let frame = highlightedLines.split(NEWLINE, end).slice(start, end).map((line, index2) => {
      const number = start + 1 + index2;
      const paddedNumber = ` ${number}`.slice(-numberMaxWidth);
      const gutter = ` ${paddedNumber} |`;
      const hasMarker = markerLines[number];
      const lastMarkerLine = !markerLines[number + 1];
      if (hasMarker) {
        let markerLine = "";
        if (Array.isArray(hasMarker)) {
          const markerSpacing = line.slice(0, Math.max(hasMarker[0] - 1, 0)).replace(/[^\t]/g, " ");
          const numberOfMarkers = hasMarker[1] || 1;
          markerLine = ["\n ", defs.gutter(gutter.replace(/\d/g, " ")), " ", markerSpacing, defs.marker("^").repeat(numberOfMarkers)].join("");
          if (lastMarkerLine && opts.message) {
            markerLine += " " + defs.message(opts.message);
          }
        }
        return [defs.marker(">"), defs.gutter(gutter), line.length > 0 ? ` ${line}` : "", markerLine].join("");
      } else {
        return ` ${defs.gutter(gutter)}${line.length > 0 ? ` ${line}` : ""}`;
      }
    }).join("\n");
    if (opts.message && !hasColumns) {
      frame = `${" ".repeat(numberMaxWidth + 1)}${opts.message}
${frame}`;
    }
    if (shouldHighlight) {
      return defs.reset(frame);
    } else {
      return frame;
    }
  }
  function index(rawLines, lineNumber, colNumber, opts = {}) {
    if (!deprecationWarningShown) {
      deprecationWarningShown = true;
      const message = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
      if (process.emitWarning) {
        process.emitWarning(message, "DeprecationWarning");
      } else {
        const deprecationError = new Error(message);
        deprecationError.name = "DeprecationWarning";
        console.warn(new Error(message));
      }
    }
    colNumber = Math.max(colNumber, 0);
    const location = {
      start: {
        column: colNumber,
        line: lineNumber
      }
    };
    return codeFrameColumns(rawLines, location, opts);
  }
  lib$1.codeFrameColumns = codeFrameColumns;
  lib$1.default = index;
  lib$1.highlight = highlight;
  return lib$1;
}
var modification = {};
var removal = {};
var removalHooks = {};
var hasRequiredRemovalHooks;
function requireRemovalHooks() {
  if (hasRequiredRemovalHooks) return removalHooks;
  hasRequiredRemovalHooks = 1;
  Object.defineProperty(removalHooks, "__esModule", {
    value: true
  });
  removalHooks.hooks = void 0;
  removalHooks.hooks = [function(self2, parent) {
    const removeParent = self2.key === "test" && (parent.isWhile() || parent.isSwitchCase()) || self2.key === "declaration" && parent.isExportDeclaration() || self2.key === "body" && parent.isLabeledStatement() || self2.listKey === "declarations" && parent.isVariableDeclaration() && parent.node.declarations.length === 1 || self2.key === "expression" && parent.isExpressionStatement();
    if (removeParent) {
      parent.remove();
      return true;
    }
  }, function(self2, parent) {
    if (parent.isSequenceExpression() && parent.node.expressions.length === 1) {
      parent.replaceWith(parent.node.expressions[0]);
      return true;
    }
  }, function(self2, parent) {
    if (parent.isBinary()) {
      if (self2.key === "left") {
        parent.replaceWith(parent.node.right);
      } else {
        parent.replaceWith(parent.node.left);
      }
      return true;
    }
  }, function(self2, parent) {
    if (parent.isIfStatement() && self2.key === "consequent" || self2.key === "body" && (parent.isLoop() || parent.isArrowFunctionExpression())) {
      self2.replaceWith({
        type: "BlockStatement",
        directives: [],
        body: []
      });
      return true;
    }
  }];
  return removalHooks;
}
var hasRequiredRemoval;
function requireRemoval() {
  if (hasRequiredRemoval) return removal;
  hasRequiredRemoval = 1;
  Object.defineProperty(removal, "__esModule", {
    value: true
  });
  removal._assertUnremoved = _assertUnremoved;
  removal._callRemovalHooks = _callRemovalHooks;
  removal._markRemoved = _markRemoved;
  removal._remove = _remove;
  removal._removeFromScope = _removeFromScope;
  removal.remove = remove;
  var _removalHooks = requireRemovalHooks();
  var _cache = requireCache();
  var _replacement = requireReplacement();
  var _index = requirePath();
  var t = requireLib$4();
  var _modification = requireModification();
  var _context = requireContext();
  function remove() {
    var _this$opts;
    _assertUnremoved.call(this);
    _context.resync.call(this);
    if (_callRemovalHooks.call(this)) {
      _markRemoved.call(this);
      return;
    }
    if (!((_this$opts = this.opts) != null && _this$opts.noScope)) {
      _removeFromScope.call(this);
    }
    this.shareCommentsWithSiblings();
    _remove.call(this);
    _markRemoved.call(this);
  }
  function _removeFromScope() {
    const bindings = t.getBindingIdentifiers(this.node, false, false, true);
    Object.keys(bindings).forEach((name) => this.scope.removeBinding(name));
  }
  function _callRemovalHooks() {
    if (this.parentPath) {
      for (const fn of _removalHooks.hooks) {
        if (fn(this, this.parentPath)) return true;
      }
    }
  }
  function _remove() {
    if (Array.isArray(this.container)) {
      this.container.splice(this.key, 1);
      _modification.updateSiblingKeys.call(this, this.key, -1);
    } else {
      _replacement._replaceWith.call(this, null);
    }
  }
  function _markRemoved() {
    this._traverseFlags |= _index.SHOULD_SKIP | _index.REMOVED;
    if (this.parent) {
      var _getCachedPaths;
      (_getCachedPaths = (0, _cache.getCachedPaths)(this)) == null || _getCachedPaths.delete(this.node);
    }
    this.node = null;
  }
  function _assertUnremoved() {
    if (this.removed) {
      throw this.buildCodeFrameError("NodePath has been removed so is read-only.");
    }
  }
  return removal;
}
var hoister = {};
var hasRequiredHoister;
function requireHoister() {
  if (hasRequiredHoister) return hoister;
  hasRequiredHoister = 1;
  Object.defineProperty(hoister, "__esModule", {
    value: true
  });
  hoister.default = void 0;
  var _t = requireLib$4();
  var _t2 = _t;
  const {
    react
  } = _t;
  const {
    cloneNode: cloneNode2,
    jsxExpressionContainer,
    variableDeclaration,
    variableDeclarator
  } = _t2;
  const referenceVisitor = {
    ReferencedIdentifier(path2, state) {
      if (path2.isJSXIdentifier() && react.isCompatTag(path2.node.name) && !path2.parentPath.isJSXMemberExpression()) {
        return;
      }
      if (path2.node.name === "this") {
        let scope2 = path2.scope;
        do {
          if (scope2.path.isFunction() && !scope2.path.isArrowFunctionExpression()) {
            break;
          }
        } while (scope2 = scope2.parent);
        if (scope2) state.breakOnScopePaths.push(scope2.path);
      }
      const binding2 = path2.scope.getBinding(path2.node.name);
      if (!binding2) return;
      for (const violation of binding2.constantViolations) {
        if (violation.scope !== binding2.path.scope) {
          state.mutableBinding = true;
          path2.stop();
          return;
        }
      }
      if (binding2 !== state.scope.getBinding(path2.node.name)) return;
      state.bindings[path2.node.name] = binding2;
    }
  };
  class PathHoister {
    constructor(path2, scope2) {
      this.breakOnScopePaths = void 0;
      this.bindings = void 0;
      this.mutableBinding = void 0;
      this.scopes = void 0;
      this.scope = void 0;
      this.path = void 0;
      this.attachAfter = void 0;
      this.breakOnScopePaths = [];
      this.bindings = {};
      this.mutableBinding = false;
      this.scopes = [];
      this.scope = scope2;
      this.path = path2;
      this.attachAfter = false;
    }
    isCompatibleScope(scope2) {
      for (const key of Object.keys(this.bindings)) {
        const binding2 = this.bindings[key];
        if (!scope2.bindingIdentifierEquals(key, binding2.identifier)) {
          return false;
        }
      }
      return true;
    }
    getCompatibleScopes() {
      let scope2 = this.path.scope;
      do {
        if (this.isCompatibleScope(scope2)) {
          this.scopes.push(scope2);
        } else {
          break;
        }
        if (this.breakOnScopePaths.includes(scope2.path)) {
          break;
        }
      } while (scope2 = scope2.parent);
    }
    getAttachmentPath() {
      let path2 = this._getAttachmentPath();
      if (!path2) return;
      let targetScope = path2.scope;
      if (targetScope.path === path2) {
        targetScope = path2.scope.parent;
      }
      if (targetScope.path.isProgram() || targetScope.path.isFunction()) {
        for (const name of Object.keys(this.bindings)) {
          if (!targetScope.hasOwnBinding(name)) continue;
          const binding2 = this.bindings[name];
          if (binding2.kind === "param" || binding2.path.parentKey === "params") {
            continue;
          }
          const bindingParentPath = this.getAttachmentParentForPath(binding2.path);
          if (bindingParentPath.key >= path2.key) {
            this.attachAfter = true;
            path2 = binding2.path;
            for (const violationPath of binding2.constantViolations) {
              if (this.getAttachmentParentForPath(violationPath).key > path2.key) {
                path2 = violationPath;
              }
            }
          }
        }
      }
      return path2;
    }
    _getAttachmentPath() {
      const scopes = this.scopes;
      const scope2 = scopes.pop();
      if (!scope2) return;
      if (scope2.path.isFunction()) {
        if (this.hasOwnParamBindings(scope2)) {
          if (this.scope === scope2) return;
          const bodies = scope2.path.get("body").get("body");
          for (let i = 0; i < bodies.length; i++) {
            if (bodies[i].node._blockHoist) continue;
            return bodies[i];
          }
        } else {
          return this.getNextScopeAttachmentParent();
        }
      } else if (scope2.path.isProgram()) {
        return this.getNextScopeAttachmentParent();
      }
    }
    getNextScopeAttachmentParent() {
      const scope2 = this.scopes.pop();
      if (scope2) return this.getAttachmentParentForPath(scope2.path);
    }
    getAttachmentParentForPath(path2) {
      do {
        if (!path2.parentPath || Array.isArray(path2.container) && path2.isStatement()) {
          return path2;
        }
      } while (path2 = path2.parentPath);
      return path2;
    }
    hasOwnParamBindings(scope2) {
      for (const name of Object.keys(this.bindings)) {
        if (!scope2.hasOwnBinding(name)) continue;
        const binding2 = this.bindings[name];
        if (binding2.kind === "param" && binding2.constant) return true;
      }
      return false;
    }
    run() {
      this.path.traverse(referenceVisitor, this);
      if (this.mutableBinding) return;
      this.getCompatibleScopes();
      const attachTo = this.getAttachmentPath();
      if (!attachTo) return;
      if (attachTo.getFunctionParent() === this.path.getFunctionParent()) return;
      let uid = attachTo.scope.generateUidIdentifier("ref");
      const declarator = variableDeclarator(uid, this.path.node);
      const insertFn = this.attachAfter ? "insertAfter" : "insertBefore";
      const [attached] = attachTo[insertFn]([attachTo.isVariableDeclarator() ? declarator : variableDeclaration("var", [declarator])]);
      const parent = this.path.parentPath;
      if (parent.isJSXElement() && this.path.container === parent.node.children) {
        uid = jsxExpressionContainer(uid);
      }
      this.path.replaceWith(cloneNode2(uid));
      return attached.isVariableDeclarator() ? attached.get("init") : attached.get("declarations.0.init");
    }
  }
  hoister.default = PathHoister;
  return hoister;
}
var hasRequiredModification;
function requireModification() {
  if (hasRequiredModification) return modification;
  hasRequiredModification = 1;
  Object.defineProperty(modification, "__esModule", {
    value: true
  });
  modification._containerInsert = _containerInsert;
  modification._containerInsertAfter = _containerInsertAfter;
  modification._containerInsertBefore = _containerInsertBefore;
  modification._verifyNodeList = _verifyNodeList;
  modification.insertAfter = insertAfter;
  modification.insertBefore = insertBefore;
  modification.pushContainer = pushContainer;
  modification.unshiftContainer = unshiftContainer;
  modification.updateSiblingKeys = updateSiblingKeys;
  var _cache = requireCache();
  var _index = requirePath();
  var _context = requireContext();
  var _removal = requireRemoval();
  var _t = requireLib$4();
  var _hoister = requireHoister();
  const {
    arrowFunctionExpression,
    assertExpression,
    assignmentExpression,
    blockStatement,
    callExpression,
    cloneNode: cloneNode2,
    expressionStatement,
    isAssignmentExpression,
    isCallExpression,
    isExportNamedDeclaration,
    isExpression,
    isIdentifier,
    isSequenceExpression,
    isSuper,
    thisExpression
  } = _t;
  function insertBefore(nodes_) {
    _removal._assertUnremoved.call(this);
    const nodes = _verifyNodeList.call(this, nodes_);
    const {
      parentPath,
      parent
    } = this;
    if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || isExportNamedDeclaration(parent) || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {
      return parentPath.insertBefore(nodes);
    } else if (this.isNodeType("Expression") && !this.isJSXElement() || parentPath.isForStatement() && this.key === "init") {
      if (this.node) nodes.push(this.node);
      return this.replaceExpressionWithStatements(nodes);
    } else if (Array.isArray(this.container)) {
      return _containerInsertBefore.call(this, nodes);
    } else if (this.isStatementOrBlock()) {
      const node2 = this.node;
      const shouldInsertCurrentNode = node2 && (!this.isExpressionStatement() || node2.expression != null);
      const [blockPath] = this.replaceWith(blockStatement(shouldInsertCurrentNode ? [node2] : []));
      return blockPath.unshiftContainer("body", nodes);
    } else {
      throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
    }
  }
  function _containerInsert(from, nodes) {
    updateSiblingKeys.call(this, from, nodes.length);
    const paths = [];
    this.container.splice(from, 0, ...nodes);
    for (let i = 0; i < nodes.length; i++) {
      var _this$context;
      const to = from + i;
      const path2 = this.getSibling(to);
      paths.push(path2);
      if ((_this$context = this.context) != null && _this$context.queue) {
        _context.pushContext.call(path2, this.context);
      }
    }
    const contexts = _context._getQueueContexts.call(this);
    for (const path2 of paths) {
      _context.setScope.call(path2);
      path2.debug("Inserted.");
      for (const context2 of contexts) {
        context2.maybeQueue(path2, true);
      }
    }
    return paths;
  }
  function _containerInsertBefore(nodes) {
    return _containerInsert.call(this, this.key, nodes);
  }
  function _containerInsertAfter(nodes) {
    return _containerInsert.call(this, this.key + 1, nodes);
  }
  const last = (arr) => arr[arr.length - 1];
  function isHiddenInSequenceExpression(path2) {
    return isSequenceExpression(path2.parent) && (last(path2.parent.expressions) !== path2.node || isHiddenInSequenceExpression(path2.parentPath));
  }
  function isAlmostConstantAssignment(node2, scope2) {
    if (!isAssignmentExpression(node2) || !isIdentifier(node2.left)) {
      return false;
    }
    const blockScope = scope2.getBlockParent();
    return blockScope.hasOwnBinding(node2.left.name) && blockScope.getOwnBinding(node2.left.name).constantViolations.length <= 1;
  }
  function insertAfter(nodes_) {
    _removal._assertUnremoved.call(this);
    if (this.isSequenceExpression()) {
      return last(this.get("expressions")).insertAfter(nodes_);
    }
    const nodes = _verifyNodeList.call(this, nodes_);
    const {
      parentPath,
      parent
    } = this;
    if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || isExportNamedDeclaration(parent) || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {
      return parentPath.insertAfter(nodes.map((node2) => {
        return isExpression(node2) ? expressionStatement(node2) : node2;
      }));
    } else if (this.isNodeType("Expression") && !this.isJSXElement() && !parentPath.isJSXElement() || parentPath.isForStatement() && this.key === "init") {
      const self2 = this;
      if (self2.node) {
        const node2 = self2.node;
        let {
          scope: scope2
        } = this;
        if (scope2.path.isPattern()) {
          assertExpression(node2);
          self2.replaceWith(callExpression(arrowFunctionExpression([], node2), []));
          self2.get("callee.body").insertAfter(nodes);
          return [self2];
        }
        if (isHiddenInSequenceExpression(self2)) {
          nodes.unshift(node2);
        } else if (isCallExpression(node2) && isSuper(node2.callee)) {
          nodes.unshift(node2);
          nodes.push(thisExpression());
        } else if (isAlmostConstantAssignment(node2, scope2)) {
          nodes.unshift(node2);
          nodes.push(cloneNode2(node2.left));
        } else if (scope2.isPure(node2, true)) {
          nodes.push(node2);
        } else {
          if (parentPath.isMethod({
            computed: true,
            key: node2
          })) {
            scope2 = scope2.parent;
          }
          const temp = scope2.generateDeclaredUidIdentifier();
          nodes.unshift(expressionStatement(assignmentExpression("=", cloneNode2(temp), node2)));
          nodes.push(expressionStatement(cloneNode2(temp)));
        }
      }
      return this.replaceExpressionWithStatements(nodes);
    } else if (Array.isArray(this.container)) {
      return _containerInsertAfter.call(this, nodes);
    } else if (this.isStatementOrBlock()) {
      const node2 = this.node;
      const shouldInsertCurrentNode = node2 && (!this.isExpressionStatement() || node2.expression != null);
      const [blockPath] = this.replaceWith(blockStatement(shouldInsertCurrentNode ? [node2] : []));
      return blockPath.pushContainer("body", nodes);
    } else {
      throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
    }
  }
  function updateSiblingKeys(fromIndex, incrementBy) {
    if (!this.parent) return;
    const paths = (0, _cache.getCachedPaths)(this);
    if (!paths) return;
    for (const [, path2] of paths) {
      if (typeof path2.key === "number" && path2.container === this.container && path2.key >= fromIndex) {
        path2.key += incrementBy;
      }
    }
  }
  function _verifyNodeList(nodes) {
    if (!nodes) {
      return [];
    }
    if (!Array.isArray(nodes)) {
      nodes = [nodes];
    }
    for (let i = 0; i < nodes.length; i++) {
      const node2 = nodes[i];
      let msg;
      if (!node2) {
        msg = "has falsy node";
      } else if (typeof node2 !== "object") {
        msg = "contains a non-object node";
      } else if (!node2.type) {
        msg = "without a type";
      } else if (node2 instanceof _index.default) {
        msg = "has a NodePath when it expected a raw object";
      }
      if (msg) {
        const type = Array.isArray(node2) ? "array" : typeof node2;
        throw new Error(`Node list ${msg} with the index of ${i} and type of ${type}`);
      }
    }
    return nodes;
  }
  function unshiftContainer(listKey, nodes) {
    _removal._assertUnremoved.call(this);
    const verifiedNodes = _verifyNodeList.call(this, nodes);
    const container = this.node[listKey];
    const path2 = _index.default.get({
      parentPath: this,
      parent: this.node,
      container,
      listKey,
      key: 0
    }).setContext(this.context);
    return _containerInsertBefore.call(path2, verifiedNodes);
  }
  function pushContainer(listKey, nodes) {
    _removal._assertUnremoved.call(this);
    const verifiedNodes = _verifyNodeList.call(this, nodes);
    const container = this.node[listKey];
    const path2 = _index.default.get({
      parentPath: this,
      parent: this.node,
      container,
      listKey,
      key: container.length
    }).setContext(this.context);
    return path2.replaceWithMultiple(verifiedNodes);
  }
  {
    modification.hoist = function hoist(scope2 = this.scope) {
      const hoister2 = new _hoister.default(this, scope2);
      return hoister2.run();
    };
  }
  return modification;
}
var hasRequiredReplacement;
function requireReplacement() {
  if (hasRequiredReplacement) return replacement;
  hasRequiredReplacement = 1;
  Object.defineProperty(replacement, "__esModule", {
    value: true
  });
  replacement._replaceWith = _replaceWith;
  replacement.replaceExpressionWithStatements = replaceExpressionWithStatements;
  replacement.replaceInline = replaceInline;
  replacement.replaceWith = replaceWith;
  replacement.replaceWithMultiple = replaceWithMultiple;
  replacement.replaceWithSourceString = replaceWithSourceString;
  var _codeFrame = requireLib$2();
  var _index = requireLib();
  var _index2 = requirePath();
  var _cache = requireCache();
  var _modification = requireModification();
  var _parser = require$$5;
  var _t = requireLib$4();
  var _context = requireContext();
  const {
    FUNCTION_TYPES,
    arrowFunctionExpression,
    assignmentExpression,
    awaitExpression,
    blockStatement,
    buildUndefinedNode,
    callExpression,
    cloneNode: cloneNode2,
    conditionalExpression,
    expressionStatement,
    getBindingIdentifiers: getBindingIdentifiers2,
    identifier: identifier2,
    inheritLeadingComments: inheritLeadingComments2,
    inheritTrailingComments: inheritTrailingComments2,
    inheritsComments: inheritsComments2,
    isBlockStatement,
    isEmptyStatement,
    isExpression,
    isExpressionStatement,
    isIfStatement,
    isProgram,
    isStatement,
    isVariableDeclaration,
    removeComments: removeComments2,
    returnStatement,
    sequenceExpression,
    validate: validate2,
    yieldExpression
  } = _t;
  function replaceWithMultiple(nodes) {
    var _getCachedPaths;
    _context.resync.call(this);
    const verifiedNodes = _modification._verifyNodeList.call(this, nodes);
    inheritLeadingComments2(verifiedNodes[0], this.node);
    inheritTrailingComments2(verifiedNodes[verifiedNodes.length - 1], this.node);
    (_getCachedPaths = (0, _cache.getCachedPaths)(this)) == null || _getCachedPaths.delete(this.node);
    this.node = this.container[this.key] = null;
    const paths = this.insertAfter(nodes);
    if (this.node) {
      this.requeue();
    } else {
      this.remove();
    }
    return paths;
  }
  function replaceWithSourceString(replacement2) {
    _context.resync.call(this);
    let ast;
    try {
      replacement2 = `(${replacement2})`;
      ast = (0, _parser.parse)(replacement2);
    } catch (err) {
      const loc = err.loc;
      if (loc) {
        err.message += " - make sure this is an expression.\n" + (0, _codeFrame.codeFrameColumns)(replacement2, {
          start: {
            line: loc.line,
            column: loc.column + 1
          }
        });
        err.code = "BABEL_REPLACE_SOURCE_ERROR";
      }
      throw err;
    }
    const expressionAST = ast.program.body[0].expression;
    _index.default.removeProperties(expressionAST);
    return this.replaceWith(expressionAST);
  }
  function replaceWith(replacementPath) {
    _context.resync.call(this);
    if (this.removed) {
      throw new Error("You can't replace this node, we've already removed it");
    }
    let replacement2 = replacementPath instanceof _index2.default ? replacementPath.node : replacementPath;
    if (!replacement2) {
      throw new Error("You passed `path.replaceWith()` a falsy node, use `path.remove()` instead");
    }
    if (this.node === replacement2) {
      return [this];
    }
    if (this.isProgram() && !isProgram(replacement2)) {
      throw new Error("You can only replace a Program root node with another Program node");
    }
    if (Array.isArray(replacement2)) {
      throw new Error("Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`");
    }
    if (typeof replacement2 === "string") {
      throw new Error("Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`");
    }
    let nodePath = "";
    if (this.isNodeType("Statement") && isExpression(replacement2)) {
      if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement2) && !this.parentPath.isExportDefaultDeclaration()) {
        replacement2 = expressionStatement(replacement2);
        nodePath = "expression";
      }
    }
    if (this.isNodeType("Expression") && isStatement(replacement2)) {
      if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement2)) {
        return this.replaceExpressionWithStatements([replacement2]);
      }
    }
    const oldNode = this.node;
    if (oldNode) {
      inheritsComments2(replacement2, oldNode);
      removeComments2(oldNode);
    }
    _replaceWith.call(this, replacement2);
    this.type = replacement2.type;
    _context.setScope.call(this);
    this.requeue();
    return [nodePath ? this.get(nodePath) : this];
  }
  function _replaceWith(node2) {
    var _getCachedPaths2;
    if (!this.container) {
      throw new ReferenceError("Container is falsy");
    }
    if (this.inList) {
      validate2(this.parent, this.key, [node2]);
    } else {
      validate2(this.parent, this.key, node2);
    }
    this.debug(`Replace with ${node2 == null ? void 0 : node2.type}`);
    (_getCachedPaths2 = (0, _cache.getCachedPaths)(this)) == null || _getCachedPaths2.set(node2, this).delete(this.node);
    this.node = node2;
    this.container[this.key] = node2;
  }
  function replaceExpressionWithStatements(nodes) {
    _context.resync.call(this);
    const declars = [];
    const nodesAsSingleExpression = gatherSequenceExpressions2(nodes, declars);
    if (nodesAsSingleExpression) {
      for (const id of declars) this.scope.push({
        id
      });
      return this.replaceWith(nodesAsSingleExpression)[0].get("expressions");
    }
    const functionParent = this.getFunctionParent();
    const isParentAsync = functionParent == null ? void 0 : functionParent.node.async;
    const isParentGenerator = functionParent == null ? void 0 : functionParent.node.generator;
    const container = arrowFunctionExpression([], blockStatement(nodes));
    this.replaceWith(callExpression(container, []));
    const callee = this.get("callee");
    callee.get("body").scope.hoistVariables((id) => this.scope.push({
      id
    }));
    const completionRecords = callee.getCompletionRecords();
    for (const path2 of completionRecords) {
      if (!path2.isExpressionStatement()) continue;
      const loop = path2.findParent((path3) => path3.isLoop());
      if (loop) {
        let uid = loop.getData("expressionReplacementReturnUid");
        if (!uid) {
          uid = callee.scope.generateDeclaredUidIdentifier("ret");
          callee.get("body").pushContainer("body", returnStatement(cloneNode2(uid)));
          loop.setData("expressionReplacementReturnUid", uid);
        } else {
          uid = identifier2(uid.name);
        }
        path2.get("expression").replaceWith(assignmentExpression("=", cloneNode2(uid), path2.node.expression));
      } else {
        path2.replaceWith(returnStatement(path2.node.expression));
      }
    }
    callee.arrowFunctionToExpression();
    const newCallee = callee;
    const needToAwaitFunction = isParentAsync && _index.default.hasType(this.get("callee.body").node, "AwaitExpression", FUNCTION_TYPES);
    const needToYieldFunction = isParentGenerator && _index.default.hasType(this.get("callee.body").node, "YieldExpression", FUNCTION_TYPES);
    if (needToAwaitFunction) {
      newCallee.set("async", true);
      if (!needToYieldFunction) {
        this.replaceWith(awaitExpression(this.node));
      }
    }
    if (needToYieldFunction) {
      newCallee.set("generator", true);
      this.replaceWith(yieldExpression(this.node, true));
    }
    return newCallee.get("body.body");
  }
  function gatherSequenceExpressions2(nodes, declars) {
    const exprs = [];
    let ensureLastUndefined = true;
    for (const node2 of nodes) {
      if (!isEmptyStatement(node2)) {
        ensureLastUndefined = false;
      }
      if (isExpression(node2)) {
        exprs.push(node2);
      } else if (isExpressionStatement(node2)) {
        exprs.push(node2.expression);
      } else if (isVariableDeclaration(node2)) {
        if (node2.kind !== "var") return;
        for (const declar of node2.declarations) {
          const bindings = getBindingIdentifiers2(declar);
          for (const key of Object.keys(bindings)) {
            declars.push(cloneNode2(bindings[key]));
          }
          if (declar.init) {
            exprs.push(assignmentExpression("=", declar.id, declar.init));
          }
        }
        ensureLastUndefined = true;
      } else if (isIfStatement(node2)) {
        const consequent = node2.consequent ? gatherSequenceExpressions2([node2.consequent], declars) : buildUndefinedNode();
        const alternate = node2.alternate ? gatherSequenceExpressions2([node2.alternate], declars) : buildUndefinedNode();
        if (!consequent || !alternate) return;
        exprs.push(conditionalExpression(node2.test, consequent, alternate));
      } else if (isBlockStatement(node2)) {
        const body = gatherSequenceExpressions2(node2.body, declars);
        if (!body) return;
        exprs.push(body);
      } else if (isEmptyStatement(node2)) {
        if (nodes.indexOf(node2) === 0) {
          ensureLastUndefined = true;
        }
      } else {
        return;
      }
    }
    if (ensureLastUndefined) exprs.push(buildUndefinedNode());
    if (exprs.length === 1) {
      return exprs[0];
    } else {
      return sequenceExpression(exprs);
    }
  }
  function replaceInline(nodes) {
    _context.resync.call(this);
    if (Array.isArray(nodes)) {
      if (Array.isArray(this.container)) {
        nodes = _modification._verifyNodeList.call(this, nodes);
        const paths = _modification._containerInsertAfter.call(this, nodes);
        this.remove();
        return paths;
      } else {
        return this.replaceWithMultiple(nodes);
      }
    } else {
      return this.replaceWith(nodes);
    }
  }
  return replacement;
}
var evaluation = {};
var hasRequiredEvaluation;
function requireEvaluation() {
  if (hasRequiredEvaluation) return evaluation;
  hasRequiredEvaluation = 1;
  Object.defineProperty(evaluation, "__esModule", {
    value: true
  });
  evaluation.evaluate = evaluate;
  evaluation.evaluateTruthy = evaluateTruthy;
  const VALID_OBJECT_CALLEES = ["Number", "String", "Math"];
  const VALID_IDENTIFIER_CALLEES = ["isFinite", "isNaN", "parseFloat", "parseInt", "decodeURI", "decodeURIComponent", "encodeURI", "encodeURIComponent", null, null];
  const INVALID_METHODS = ["random"];
  function isValidObjectCallee(val) {
    return VALID_OBJECT_CALLEES.includes(val);
  }
  function isValidIdentifierCallee(val) {
    return VALID_IDENTIFIER_CALLEES.includes(val);
  }
  function isInvalidMethod(val) {
    return INVALID_METHODS.includes(val);
  }
  function evaluateTruthy() {
    const res = this.evaluate();
    if (res.confident) return !!res.value;
  }
  function deopt(path2, state) {
    if (!state.confident) return;
    state.deoptPath = path2;
    state.confident = false;
  }
  const Globals = /* @__PURE__ */ new Map([["undefined", void 0], ["Infinity", Infinity], ["NaN", NaN]]);
  function evaluateCached(path2, state) {
    const {
      node: node2
    } = path2;
    const {
      seen
    } = state;
    if (seen.has(node2)) {
      const existing = seen.get(node2);
      if (existing.resolved) {
        return existing.value;
      } else {
        deopt(path2, state);
        return;
      }
    } else {
      const item = {
        resolved: false
      };
      seen.set(node2, item);
      const val = _evaluate(path2, state);
      if (state.confident) {
        item.resolved = true;
        item.value = val;
      }
      return val;
    }
  }
  function _evaluate(path2, state) {
    if (!state.confident) return;
    if (path2.isSequenceExpression()) {
      const exprs = path2.get("expressions");
      return evaluateCached(exprs[exprs.length - 1], state);
    }
    if (path2.isStringLiteral() || path2.isNumericLiteral() || path2.isBooleanLiteral()) {
      return path2.node.value;
    }
    if (path2.isNullLiteral()) {
      return null;
    }
    if (path2.isTemplateLiteral()) {
      return evaluateQuasis(path2, path2.node.quasis, state);
    }
    if (path2.isTaggedTemplateExpression() && path2.get("tag").isMemberExpression()) {
      const object = path2.get("tag.object");
      const {
        node: {
          name
        }
      } = object;
      const property = path2.get("tag.property");
      if (object.isIdentifier() && name === "String" && !path2.scope.getBinding(name) && property.isIdentifier() && property.node.name === "raw") {
        return evaluateQuasis(path2, path2.node.quasi.quasis, state, true);
      }
    }
    if (path2.isConditionalExpression()) {
      const testResult = evaluateCached(path2.get("test"), state);
      if (!state.confident) return;
      if (testResult) {
        return evaluateCached(path2.get("consequent"), state);
      } else {
        return evaluateCached(path2.get("alternate"), state);
      }
    }
    if (path2.isExpressionWrapper()) {
      return evaluateCached(path2.get("expression"), state);
    }
    if (path2.isMemberExpression() && !path2.parentPath.isCallExpression({
      callee: path2.node
    })) {
      const property = path2.get("property");
      const object = path2.get("object");
      if (object.isLiteral()) {
        const value = object.node.value;
        const type = typeof value;
        let key = null;
        if (path2.node.computed) {
          key = evaluateCached(property, state);
          if (!state.confident) return;
        } else if (property.isIdentifier()) {
          key = property.node.name;
        }
        if ((type === "number" || type === "string") && key != null && (typeof key === "number" || typeof key === "string")) {
          return value[key];
        }
      }
    }
    if (path2.isReferencedIdentifier()) {
      const binding2 = path2.scope.getBinding(path2.node.name);
      if (binding2) {
        if (binding2.constantViolations.length > 0 || path2.node.start < binding2.path.node.end) {
          deopt(binding2.path, state);
          return;
        }
        const bindingPathScope = binding2.path.scope;
        if (binding2.kind === "var" && bindingPathScope !== binding2.scope) {
          let hasUnsafeBlock = !bindingPathScope.path.parentPath.isBlockStatement();
          for (let scope2 = bindingPathScope.parent; scope2; scope2 = scope2.parent) {
            var _scope$path$parentPat;
            if (scope2 === path2.scope) {
              if (hasUnsafeBlock) {
                deopt(binding2.path, state);
                return;
              }
              break;
            }
            if ((_scope$path$parentPat = scope2.path.parentPath) != null && _scope$path$parentPat.isBlockStatement()) {
              hasUnsafeBlock = true;
            }
          }
        }
        if (binding2.hasValue) {
          return binding2.value;
        }
      }
      const name = path2.node.name;
      if (Globals.has(name)) {
        if (!binding2) {
          return Globals.get(name);
        }
        deopt(binding2.path, state);
        return;
      }
      const resolved = path2.resolve();
      if (resolved === path2) {
        deopt(path2, state);
        return;
      }
      const value = evaluateCached(resolved, state);
      if (typeof value === "object" && value !== null && binding2.references > 1) {
        deopt(resolved, state);
        return;
      }
      return value;
    }
    if (path2.isUnaryExpression({
      prefix: true
    })) {
      if (path2.node.operator === "void") {
        return void 0;
      }
      const argument = path2.get("argument");
      if (path2.node.operator === "typeof" && (argument.isFunction() || argument.isClass())) {
        return "function";
      }
      const arg = evaluateCached(argument, state);
      if (!state.confident) return;
      switch (path2.node.operator) {
        case "!":
          return !arg;
        case "+":
          return +arg;
        case "-":
          return -arg;
        case "~":
          return ~arg;
        case "typeof":
          return typeof arg;
      }
    }
    if (path2.isArrayExpression()) {
      const arr = [];
      const elems = path2.get("elements");
      for (const elem of elems) {
        const elemValue = elem.evaluate();
        if (elemValue.confident) {
          arr.push(elemValue.value);
        } else {
          deopt(elemValue.deopt, state);
          return;
        }
      }
      return arr;
    }
    if (path2.isObjectExpression()) {
      const obj = {};
      const props = path2.get("properties");
      for (const prop of props) {
        if (prop.isObjectMethod() || prop.isSpreadElement()) {
          deopt(prop, state);
          return;
        }
        const keyPath = prop.get("key");
        let key;
        if (prop.node.computed) {
          key = keyPath.evaluate();
          if (!key.confident) {
            deopt(key.deopt, state);
            return;
          }
          key = key.value;
        } else if (keyPath.isIdentifier()) {
          key = keyPath.node.name;
        } else {
          key = keyPath.node.value;
        }
        const valuePath = prop.get("value");
        let value = valuePath.evaluate();
        if (!value.confident) {
          deopt(value.deopt, state);
          return;
        }
        value = value.value;
        obj[key] = value;
      }
      return obj;
    }
    if (path2.isLogicalExpression()) {
      const wasConfident = state.confident;
      const left = evaluateCached(path2.get("left"), state);
      const leftConfident = state.confident;
      state.confident = wasConfident;
      const right = evaluateCached(path2.get("right"), state);
      const rightConfident = state.confident;
      switch (path2.node.operator) {
        case "||":
          state.confident = leftConfident && (!!left || rightConfident);
          if (!state.confident) return;
          return left || right;
        case "&&":
          state.confident = leftConfident && (!left || rightConfident);
          if (!state.confident) return;
          return left && right;
        case "??":
          state.confident = leftConfident && (left != null || rightConfident);
          if (!state.confident) return;
          return left != null ? left : right;
      }
    }
    if (path2.isBinaryExpression()) {
      const left = evaluateCached(path2.get("left"), state);
      if (!state.confident) return;
      const right = evaluateCached(path2.get("right"), state);
      if (!state.confident) return;
      switch (path2.node.operator) {
        case "-":
          return left - right;
        case "+":
          return left + right;
        case "/":
          return left / right;
        case "*":
          return left * right;
        case "%":
          return left % right;
        case "**":
          return Math.pow(left, right);
        case "<":
          return left < right;
        case ">":
          return left > right;
        case "<=":
          return left <= right;
        case ">=":
          return left >= right;
        case "==":
          return left == right;
        case "!=":
          return left != right;
        case "===":
          return left === right;
        case "!==":
          return left !== right;
        case "|":
          return left | right;
        case "&":
          return left & right;
        case "^":
          return left ^ right;
        case "<<":
          return left << right;
        case ">>":
          return left >> right;
        case ">>>":
          return left >>> right;
      }
    }
    if (path2.isCallExpression()) {
      const callee = path2.get("callee");
      let context2;
      let func;
      if (callee.isIdentifier() && !path2.scope.getBinding(callee.node.name) && (isValidObjectCallee(callee.node.name) || isValidIdentifierCallee(callee.node.name))) {
        func = commonjsGlobal[callee.node.name];
      }
      if (callee.isMemberExpression()) {
        const object = callee.get("object");
        const property = callee.get("property");
        if (object.isIdentifier() && property.isIdentifier() && isValidObjectCallee(object.node.name) && !isInvalidMethod(property.node.name)) {
          context2 = commonjsGlobal[object.node.name];
          const key = property.node.name;
          if (hasOwnProperty.call(context2, key)) {
            func = context2[key];
          }
        }
        if (object.isLiteral() && property.isIdentifier()) {
          const type = typeof object.node.value;
          if (type === "string" || type === "number") {
            context2 = object.node.value;
            func = context2[property.node.name];
          }
        }
      }
      if (func) {
        const args = path2.get("arguments").map((arg) => evaluateCached(arg, state));
        if (!state.confident) return;
        return func.apply(context2, args);
      }
    }
    deopt(path2, state);
  }
  function evaluateQuasis(path2, quasis, state, raw = false) {
    let str = "";
    let i = 0;
    const exprs = path2.isTemplateLiteral() ? path2.get("expressions") : path2.get("quasi.expressions");
    for (const elem of quasis) {
      if (!state.confident) break;
      str += raw ? elem.value.raw : elem.value.cooked;
      const expr = exprs[i++];
      if (expr) str += String(evaluateCached(expr, state));
    }
    if (!state.confident) return;
    return str;
  }
  function evaluate() {
    const state = {
      confident: true,
      deoptPath: null,
      seen: /* @__PURE__ */ new Map()
    };
    let value = evaluateCached(this, state);
    if (!state.confident) value = void 0;
    return {
      confident: state.confident,
      deopt: state.deoptPath,
      value
    };
  }
  return evaluation;
}
var conversion = {};
var lib = {};
var formatters = {};
var hasRequiredFormatters;
function requireFormatters() {
  if (hasRequiredFormatters) return formatters;
  hasRequiredFormatters = 1;
  Object.defineProperty(formatters, "__esModule", {
    value: true
  });
  formatters.statements = formatters.statement = formatters.smart = formatters.program = formatters.expression = void 0;
  var _t = requireLib$4();
  const {
    assertExpressionStatement
  } = _t;
  function makeStatementFormatter(fn) {
    return {
      code: (str) => `/* @babel/template */;
${str}`,
      validate: () => {
      },
      unwrap: (ast) => {
        return fn(ast.program.body.slice(1));
      }
    };
  }
  formatters.smart = makeStatementFormatter((body) => {
    if (body.length > 1) {
      return body;
    } else {
      return body[0];
    }
  });
  formatters.statements = makeStatementFormatter((body) => body);
  formatters.statement = makeStatementFormatter((body) => {
    if (body.length === 0) {
      throw new Error("Found nothing to return.");
    }
    if (body.length > 1) {
      throw new Error("Found multiple statements but wanted one");
    }
    return body[0];
  });
  const expression = formatters.expression = {
    code: (str) => `(
${str}
)`,
    validate: (ast) => {
      if (ast.program.body.length > 1) {
        throw new Error("Found multiple statements but wanted one");
      }
      if (expression.unwrap(ast).start === 0) {
        throw new Error("Parse result included parens.");
      }
    },
    unwrap: ({
      program
    }) => {
      const [stmt] = program.body;
      assertExpressionStatement(stmt);
      return stmt.expression;
    }
  };
  formatters.program = {
    code: (str) => str,
    validate: () => {
    },
    unwrap: (ast) => ast.program
  };
  return formatters;
}
var builder = {};
var options = {};
var hasRequiredOptions;
function requireOptions() {
  if (hasRequiredOptions) return options;
  hasRequiredOptions = 1;
  Object.defineProperty(options, "__esModule", {
    value: true
  });
  options.merge = merge;
  options.normalizeReplacements = normalizeReplacements;
  options.validate = validate2;
  const _excluded = ["placeholderWhitelist", "placeholderPattern", "preserveComments", "syntacticPlaceholders"];
  function _objectWithoutPropertiesLoose(r, e) {
    if (null == r) return {};
    var t = {};
    for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
      if (-1 !== e.indexOf(n)) continue;
      t[n] = r[n];
    }
    return t;
  }
  function merge(a, b) {
    const {
      placeholderWhitelist = a.placeholderWhitelist,
      placeholderPattern = a.placeholderPattern,
      preserveComments = a.preserveComments,
      syntacticPlaceholders = a.syntacticPlaceholders
    } = b;
    return {
      parser: Object.assign({}, a.parser, b.parser),
      placeholderWhitelist,
      placeholderPattern,
      preserveComments,
      syntacticPlaceholders
    };
  }
  function validate2(opts) {
    if (opts != null && typeof opts !== "object") {
      throw new Error("Unknown template options.");
    }
    const _ref = opts || {}, {
      placeholderWhitelist,
      placeholderPattern,
      preserveComments,
      syntacticPlaceholders
    } = _ref, parser = _objectWithoutPropertiesLoose(_ref, _excluded);
    if (placeholderWhitelist != null && !(placeholderWhitelist instanceof Set)) {
      throw new Error("'.placeholderWhitelist' must be a Set, null, or undefined");
    }
    if (placeholderPattern != null && !(placeholderPattern instanceof RegExp) && placeholderPattern !== false) {
      throw new Error("'.placeholderPattern' must be a RegExp, false, null, or undefined");
    }
    if (preserveComments != null && typeof preserveComments !== "boolean") {
      throw new Error("'.preserveComments' must be a boolean, null, or undefined");
    }
    if (syntacticPlaceholders != null && typeof syntacticPlaceholders !== "boolean") {
      throw new Error("'.syntacticPlaceholders' must be a boolean, null, or undefined");
    }
    if (syntacticPlaceholders === true && (placeholderWhitelist != null || placeholderPattern != null)) {
      throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
    }
    return {
      parser,
      placeholderWhitelist: placeholderWhitelist || void 0,
      placeholderPattern: placeholderPattern == null ? void 0 : placeholderPattern,
      preserveComments: preserveComments == null ? void 0 : preserveComments,
      syntacticPlaceholders: syntacticPlaceholders == null ? void 0 : syntacticPlaceholders
    };
  }
  function normalizeReplacements(replacements) {
    if (Array.isArray(replacements)) {
      return replacements.reduce((acc, replacement2, i) => {
        acc["$" + i] = replacement2;
        return acc;
      }, {});
    } else if (typeof replacements === "object" || replacements == null) {
      return replacements || void 0;
    }
    throw new Error("Template replacements must be an array, object, null, or undefined");
  }
  return options;
}
var string = {};
var parse = {};
var hasRequiredParse;
function requireParse() {
  if (hasRequiredParse) return parse;
  hasRequiredParse = 1;
  Object.defineProperty(parse, "__esModule", {
    value: true
  });
  parse.default = parseAndBuildMetadata;
  var _t = requireLib$4();
  var _parser = require$$5;
  var _codeFrame = requireLib$2();
  const {
    isCallExpression,
    isExpressionStatement,
    isFunction,
    isIdentifier,
    isJSXIdentifier,
    isNewExpression,
    isPlaceholder,
    isStatement,
    isStringLiteral,
    removePropertiesDeep: removePropertiesDeep2,
    traverse: traverse2
  } = _t;
  const PATTERN = /^[_$A-Z0-9]+$/;
  function parseAndBuildMetadata(formatter, code, opts) {
    const {
      placeholderWhitelist,
      placeholderPattern,
      preserveComments,
      syntacticPlaceholders
    } = opts;
    const ast = parseWithCodeFrame(code, opts.parser, syntacticPlaceholders);
    removePropertiesDeep2(ast, {
      preserveComments
    });
    formatter.validate(ast);
    const state = {
      syntactic: {
        placeholders: [],
        placeholderNames: /* @__PURE__ */ new Set()
      },
      legacy: {
        placeholders: [],
        placeholderNames: /* @__PURE__ */ new Set()
      },
      placeholderWhitelist,
      placeholderPattern,
      syntacticPlaceholders
    };
    traverse2(ast, placeholderVisitorHandler, state);
    return Object.assign({
      ast
    }, state.syntactic.placeholders.length ? state.syntactic : state.legacy);
  }
  function placeholderVisitorHandler(node2, ancestors, state) {
    var _state$placeholderWhi;
    let name;
    let hasSyntacticPlaceholders = state.syntactic.placeholders.length > 0;
    if (isPlaceholder(node2)) {
      if (state.syntacticPlaceholders === false) {
        throw new Error("%%foo%%-style placeholders can't be used when '.syntacticPlaceholders' is false.");
      }
      name = node2.name.name;
      hasSyntacticPlaceholders = true;
    } else if (hasSyntacticPlaceholders || state.syntacticPlaceholders) {
      return;
    } else if (isIdentifier(node2) || isJSXIdentifier(node2)) {
      name = node2.name;
    } else if (isStringLiteral(node2)) {
      name = node2.value;
    } else {
      return;
    }
    if (hasSyntacticPlaceholders && (state.placeholderPattern != null || state.placeholderWhitelist != null)) {
      throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
    }
    if (!hasSyntacticPlaceholders && (state.placeholderPattern === false || !(state.placeholderPattern || PATTERN).test(name)) && !((_state$placeholderWhi = state.placeholderWhitelist) != null && _state$placeholderWhi.has(name))) {
      return;
    }
    ancestors = ancestors.slice();
    const {
      node: parent,
      key
    } = ancestors[ancestors.length - 1];
    let type;
    if (isStringLiteral(node2) || isPlaceholder(node2, {
      expectedNode: "StringLiteral"
    })) {
      type = "string";
    } else if (isNewExpression(parent) && key === "arguments" || isCallExpression(parent) && key === "arguments" || isFunction(parent) && key === "params") {
      type = "param";
    } else if (isExpressionStatement(parent) && !isPlaceholder(node2)) {
      type = "statement";
      ancestors = ancestors.slice(0, -1);
    } else if (isStatement(node2) && isPlaceholder(node2)) {
      type = "statement";
    } else {
      type = "other";
    }
    const {
      placeholders: placeholders2,
      placeholderNames
    } = !hasSyntacticPlaceholders ? state.legacy : state.syntactic;
    placeholders2.push({
      name,
      type,
      resolve: (ast) => resolveAncestors(ast, ancestors),
      isDuplicate: placeholderNames.has(name)
    });
    placeholderNames.add(name);
  }
  function resolveAncestors(ast, ancestors) {
    let parent = ast;
    for (let i = 0; i < ancestors.length - 1; i++) {
      const {
        key: key2,
        index: index2
      } = ancestors[i];
      if (index2 === void 0) {
        parent = parent[key2];
      } else {
        parent = parent[key2][index2];
      }
    }
    const {
      key,
      index
    } = ancestors[ancestors.length - 1];
    return {
      parent,
      key,
      index
    };
  }
  function parseWithCodeFrame(code, parserOpts, syntacticPlaceholders) {
    const plugins = (parserOpts.plugins || []).slice();
    if (syntacticPlaceholders !== false) {
      plugins.push("placeholders");
    }
    parserOpts = Object.assign({
      allowAwaitOutsideFunction: true,
      allowReturnOutsideFunction: true,
      allowNewTargetOutsideFunction: true,
      allowSuperOutsideMethod: true,
      allowYieldOutsideFunction: true,
      sourceType: "module"
    }, parserOpts, {
      plugins
    });
    try {
      return (0, _parser.parse)(code, parserOpts);
    } catch (err) {
      const loc = err.loc;
      if (loc) {
        err.message += "\n" + (0, _codeFrame.codeFrameColumns)(code, {
          start: loc
        });
        err.code = "BABEL_TEMPLATE_PARSE_ERROR";
      }
      throw err;
    }
  }
  return parse;
}
var populate = {};
var hasRequiredPopulate;
function requirePopulate() {
  if (hasRequiredPopulate) return populate;
  hasRequiredPopulate = 1;
  Object.defineProperty(populate, "__esModule", {
    value: true
  });
  populate.default = populatePlaceholders;
  var _t = requireLib$4();
  const {
    blockStatement,
    cloneNode: cloneNode2,
    emptyStatement,
    expressionStatement,
    identifier: identifier2,
    isStatement,
    isStringLiteral,
    stringLiteral,
    validate: validate2
  } = _t;
  function populatePlaceholders(metadata, replacements) {
    const ast = cloneNode2(metadata.ast);
    if (replacements) {
      metadata.placeholders.forEach((placeholder) => {
        if (!hasOwnProperty.call(replacements, placeholder.name)) {
          const placeholderName = placeholder.name;
          throw new Error(`Error: No substitution given for "${placeholderName}". If this is not meant to be a
            placeholder you may want to consider passing one of the following options to @babel/template:
            - { placeholderPattern: false, placeholderWhitelist: new Set(['${placeholderName}'])}
            - { placeholderPattern: /^${placeholderName}$/ }`);
        }
      });
      Object.keys(replacements).forEach((key) => {
        if (!metadata.placeholderNames.has(key)) {
          throw new Error(`Unknown substitution "${key}" given`);
        }
      });
    }
    metadata.placeholders.slice().reverse().forEach((placeholder) => {
      try {
        var _ref;
        applyReplacement(placeholder, ast, (_ref = replacements && replacements[placeholder.name]) != null ? _ref : null);
      } catch (e) {
        e.message = `@babel/template placeholder "${placeholder.name}": ${e.message}`;
        throw e;
      }
    });
    return ast;
  }
  function applyReplacement(placeholder, ast, replacement2) {
    if (placeholder.isDuplicate) {
      if (Array.isArray(replacement2)) {
        replacement2 = replacement2.map((node2) => cloneNode2(node2));
      } else if (typeof replacement2 === "object") {
        replacement2 = cloneNode2(replacement2);
      }
    }
    const {
      parent,
      key,
      index
    } = placeholder.resolve(ast);
    if (placeholder.type === "string") {
      if (typeof replacement2 === "string") {
        replacement2 = stringLiteral(replacement2);
      }
      if (!replacement2 || !isStringLiteral(replacement2)) {
        throw new Error("Expected string substitution");
      }
    } else if (placeholder.type === "statement") {
      if (index === void 0) {
        if (!replacement2) {
          replacement2 = emptyStatement();
        } else if (Array.isArray(replacement2)) {
          replacement2 = blockStatement(replacement2);
        } else if (typeof replacement2 === "string") {
          replacement2 = expressionStatement(identifier2(replacement2));
        } else if (!isStatement(replacement2)) {
          replacement2 = expressionStatement(replacement2);
        }
      } else {
        if (replacement2 && !Array.isArray(replacement2)) {
          if (typeof replacement2 === "string") {
            replacement2 = identifier2(replacement2);
          }
          if (!isStatement(replacement2)) {
            replacement2 = expressionStatement(replacement2);
          }
        }
      }
    } else if (placeholder.type === "param") {
      if (typeof replacement2 === "string") {
        replacement2 = identifier2(replacement2);
      }
      if (index === void 0) throw new Error("Assertion failure.");
    } else {
      if (typeof replacement2 === "string") {
        replacement2 = identifier2(replacement2);
      }
      if (Array.isArray(replacement2)) {
        throw new Error("Cannot replace single expression with an array.");
      }
    }
    function set(parent2, key2, value) {
      const node2 = parent2[key2];
      parent2[key2] = value;
      if (node2.type === "Identifier" || node2.type === "Placeholder") {
        if (node2.typeAnnotation) {
          value.typeAnnotation = node2.typeAnnotation;
        }
        if (node2.optional) {
          value.optional = node2.optional;
        }
        if (node2.decorators) {
          value.decorators = node2.decorators;
        }
      }
    }
    if (index === void 0) {
      validate2(parent, key, replacement2);
      set(parent, key, replacement2);
    } else {
      const items = parent[key].slice();
      if (placeholder.type === "statement" || placeholder.type === "param") {
        if (replacement2 == null) {
          items.splice(index, 1);
        } else if (Array.isArray(replacement2)) {
          items.splice(index, 1, ...replacement2);
        } else {
          set(items, index, replacement2);
        }
      } else {
        set(items, index, replacement2);
      }
      validate2(parent, key, items);
      parent[key] = items;
    }
  }
  return populate;
}
var hasRequiredString;
function requireString() {
  if (hasRequiredString) return string;
  hasRequiredString = 1;
  Object.defineProperty(string, "__esModule", {
    value: true
  });
  string.default = stringTemplate;
  var _options = requireOptions();
  var _parse = requireParse();
  var _populate = requirePopulate();
  function stringTemplate(formatter, code, opts) {
    code = formatter.code(code);
    let metadata;
    return (arg) => {
      const replacements = (0, _options.normalizeReplacements)(arg);
      if (!metadata) metadata = (0, _parse.default)(formatter, code, opts);
      return formatter.unwrap((0, _populate.default)(metadata, replacements));
    };
  }
  return string;
}
var literal = {};
var hasRequiredLiteral;
function requireLiteral() {
  if (hasRequiredLiteral) return literal;
  hasRequiredLiteral = 1;
  Object.defineProperty(literal, "__esModule", {
    value: true
  });
  literal.default = literalTemplate;
  var _options = requireOptions();
  var _parse = requireParse();
  var _populate = requirePopulate();
  function literalTemplate(formatter, tpl, opts) {
    const {
      metadata,
      names
    } = buildLiteralData(formatter, tpl, opts);
    return (arg) => {
      const defaultReplacements = {};
      arg.forEach((replacement2, i) => {
        defaultReplacements[names[i]] = replacement2;
      });
      return (arg2) => {
        const replacements = (0, _options.normalizeReplacements)(arg2);
        if (replacements) {
          Object.keys(replacements).forEach((key) => {
            if (hasOwnProperty.call(defaultReplacements, key)) {
              throw new Error("Unexpected replacement overlap.");
            }
          });
        }
        return formatter.unwrap((0, _populate.default)(metadata, replacements ? Object.assign(replacements, defaultReplacements) : defaultReplacements));
      };
    };
  }
  function buildLiteralData(formatter, tpl, opts) {
    let prefix = "BABEL_TPL$";
    const raw = tpl.join("");
    do {
      prefix = "$$" + prefix;
    } while (raw.includes(prefix));
    const {
      names,
      code
    } = buildTemplateCode(tpl, prefix);
    const metadata = (0, _parse.default)(formatter, formatter.code(code), {
      parser: opts.parser,
      placeholderWhitelist: new Set(names.concat(opts.placeholderWhitelist ? Array.from(opts.placeholderWhitelist) : [])),
      placeholderPattern: opts.placeholderPattern,
      preserveComments: opts.preserveComments,
      syntacticPlaceholders: opts.syntacticPlaceholders
    });
    return {
      metadata,
      names
    };
  }
  function buildTemplateCode(tpl, prefix) {
    const names = [];
    let code = tpl[0];
    for (let i = 1; i < tpl.length; i++) {
      const value = `${prefix}${i - 1}`;
      names.push(value);
      code += value + tpl[i];
    }
    return {
      names,
      code
    };
  }
  return literal;
}
var hasRequiredBuilder;
function requireBuilder() {
  if (hasRequiredBuilder) return builder;
  hasRequiredBuilder = 1;
  Object.defineProperty(builder, "__esModule", {
    value: true
  });
  builder.default = createTemplateBuilder;
  var _options = requireOptions();
  var _string = requireString();
  var _literal = requireLiteral();
  const NO_PLACEHOLDER = (0, _options.validate)({
    placeholderPattern: false
  });
  function createTemplateBuilder(formatter, defaultOpts) {
    const templateFnCache = /* @__PURE__ */ new WeakMap();
    const templateAstCache = /* @__PURE__ */ new WeakMap();
    const cachedOpts = defaultOpts || (0, _options.validate)(null);
    return Object.assign((tpl, ...args) => {
      if (typeof tpl === "string") {
        if (args.length > 1) throw new Error("Unexpected extra params.");
        return extendedTrace((0, _string.default)(formatter, tpl, (0, _options.merge)(cachedOpts, (0, _options.validate)(args[0]))));
      } else if (Array.isArray(tpl)) {
        let builder2 = templateFnCache.get(tpl);
        if (!builder2) {
          builder2 = (0, _literal.default)(formatter, tpl, cachedOpts);
          templateFnCache.set(tpl, builder2);
        }
        return extendedTrace(builder2(args));
      } else if (typeof tpl === "object" && tpl) {
        if (args.length > 0) throw new Error("Unexpected extra params.");
        return createTemplateBuilder(formatter, (0, _options.merge)(cachedOpts, (0, _options.validate)(tpl)));
      }
      throw new Error(`Unexpected template param ${typeof tpl}`);
    }, {
      ast: (tpl, ...args) => {
        if (typeof tpl === "string") {
          if (args.length > 1) throw new Error("Unexpected extra params.");
          return (0, _string.default)(formatter, tpl, (0, _options.merge)((0, _options.merge)(cachedOpts, (0, _options.validate)(args[0])), NO_PLACEHOLDER))();
        } else if (Array.isArray(tpl)) {
          let builder2 = templateAstCache.get(tpl);
          if (!builder2) {
            builder2 = (0, _literal.default)(formatter, tpl, (0, _options.merge)(cachedOpts, NO_PLACEHOLDER));
            templateAstCache.set(tpl, builder2);
          }
          return builder2(args)();
        }
        throw new Error(`Unexpected template param ${typeof tpl}`);
      }
    });
  }
  function extendedTrace(fn) {
    let rootStack = "";
    try {
      throw new Error();
    } catch (error) {
      if (error.stack) {
        rootStack = error.stack.split("\n").slice(3).join("\n");
      }
    }
    return (arg) => {
      try {
        return fn(arg);
      } catch (err) {
        err.stack += `
    =============
${rootStack}`;
        throw err;
      }
    };
  }
  return builder;
}
var hasRequiredLib$1;
function requireLib$1() {
  if (hasRequiredLib$1) return lib;
  hasRequiredLib$1 = 1;
  Object.defineProperty(lib, "__esModule", {
    value: true
  });
  lib.statements = lib.statement = lib.smart = lib.program = lib.expression = lib.default = void 0;
  var formatters2 = requireFormatters();
  var _builder = requireBuilder();
  const smart = lib.smart = (0, _builder.default)(formatters2.smart);
  const statement = lib.statement = (0, _builder.default)(formatters2.statement);
  const statements2 = lib.statements = (0, _builder.default)(formatters2.statements);
  const expression = lib.expression = (0, _builder.default)(formatters2.expression);
  const program = lib.program = (0, _builder.default)(formatters2.program);
  lib.default = Object.assign(smart.bind(void 0), {
    smart,
    statement,
    statements: statements2,
    expression,
    program,
    ast: smart.ast
  });
  return lib;
}
var hasRequiredConversion;
function requireConversion() {
  if (hasRequiredConversion) return conversion;
  hasRequiredConversion = 1;
  Object.defineProperty(conversion, "__esModule", {
    value: true
  });
  conversion.arrowFunctionToExpression = arrowFunctionToExpression;
  conversion.ensureBlock = ensureBlock2;
  conversion.ensureFunctionName = ensureFunctionName;
  conversion.splitExportDeclaration = splitExportDeclaration;
  conversion.toComputedKey = toComputedKey2;
  conversion.unwrapFunctionEnvironment = unwrapFunctionEnvironment;
  var _t = requireLib$4();
  var _template = requireLib$1();
  var _visitors = requireVisitors();
  var _context = requireContext();
  const {
    arrowFunctionExpression,
    assignmentExpression,
    binaryExpression,
    blockStatement,
    callExpression,
    conditionalExpression,
    expressionStatement,
    identifier: identifier2,
    isIdentifier,
    jsxIdentifier,
    logicalExpression,
    LOGICAL_OPERATORS,
    memberExpression,
    metaProperty,
    numericLiteral,
    objectExpression,
    restElement,
    returnStatement,
    sequenceExpression,
    spreadElement,
    stringLiteral,
    super: _super,
    thisExpression,
    toExpression: toExpression2,
    unaryExpression,
    toBindingIdentifierName: toBindingIdentifierName2,
    isFunction,
    isAssignmentPattern,
    isRestElement,
    getFunctionName: getFunctionName2,
    cloneNode: cloneNode2,
    variableDeclaration,
    variableDeclarator,
    exportNamedDeclaration,
    exportSpecifier,
    inherits: inherits2
  } = _t;
  function toComputedKey2() {
    let key;
    if (this.isMemberExpression()) {
      key = this.node.property;
    } else if (this.isProperty() || this.isMethod()) {
      key = this.node.key;
    } else {
      throw new ReferenceError("todo");
    }
    if (!this.node.computed) {
      if (isIdentifier(key)) key = stringLiteral(key.name);
    }
    return key;
  }
  function ensureBlock2() {
    const body = this.get("body");
    const bodyNode = body.node;
    if (Array.isArray(body)) {
      throw new Error("Can't convert array path to a block statement");
    }
    if (!bodyNode) {
      throw new Error("Can't convert node without a body");
    }
    if (body.isBlockStatement()) {
      return bodyNode;
    }
    const statements2 = [];
    let stringPath = "body";
    let key;
    let listKey;
    if (body.isStatement()) {
      listKey = "body";
      key = 0;
      statements2.push(body.node);
    } else {
      stringPath += ".body.0";
      if (this.isFunction()) {
        key = "argument";
        statements2.push(returnStatement(body.node));
      } else {
        key = "expression";
        statements2.push(expressionStatement(body.node));
      }
    }
    this.node.body = blockStatement(statements2);
    const parentPath = this.get(stringPath);
    _context.setup.call(body, parentPath, listKey ? parentPath.node[listKey] : parentPath.node, listKey, key);
    return this.node;
  }
  {
    conversion.arrowFunctionToShadowed = function() {
      if (!this.isArrowFunctionExpression()) return;
      this.arrowFunctionToExpression();
    };
  }
  function unwrapFunctionEnvironment() {
    if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration()) {
      throw this.buildCodeFrameError("Can only unwrap the environment of a function.");
    }
    hoistFunctionEnvironment(this);
  }
  function setType(path2, type) {
    path2.node.type = type;
  }
  function arrowFunctionToExpression({
    allowInsertArrow = true,
    allowInsertArrowWithRest = allowInsertArrow,
    noNewArrows = !((_arguments$) => (_arguments$ = arguments[0]) == null ? void 0 : _arguments$.specCompliant)()
  } = {}) {
    if (!this.isArrowFunctionExpression()) {
      throw this.buildCodeFrameError("Cannot convert non-arrow function to a function expression.");
    }
    let self2 = this;
    if (!noNewArrows) {
      var _self$ensureFunctionN;
      self2 = (_self$ensureFunctionN = self2.ensureFunctionName(false)) != null ? _self$ensureFunctionN : self2;
    }
    const {
      thisBinding,
      fnPath: fn
    } = hoistFunctionEnvironment(self2, noNewArrows, allowInsertArrow, allowInsertArrowWithRest);
    fn.ensureBlock();
    setType(fn, "FunctionExpression");
    if (!noNewArrows) {
      const checkBinding = thisBinding ? null : fn.scope.generateUidIdentifier("arrowCheckId");
      if (checkBinding) {
        fn.parentPath.scope.push({
          id: checkBinding,
          init: objectExpression([])
        });
      }
      fn.get("body").unshiftContainer("body", expressionStatement(callExpression(this.hub.addHelper("newArrowCheck"), [thisExpression(), checkBinding ? identifier2(checkBinding.name) : identifier2(thisBinding)])));
      fn.replaceWith(callExpression(memberExpression(fn.node, identifier2("bind")), [checkBinding ? identifier2(checkBinding.name) : thisExpression()]));
      return fn.get("callee.object");
    }
    return fn;
  }
  const getSuperCallsVisitor = (0, _visitors.environmentVisitor)({
    CallExpression(child, {
      allSuperCalls
    }) {
      if (!child.get("callee").isSuper()) return;
      allSuperCalls.push(child);
    }
  });
  function hoistFunctionEnvironment(fnPath, noNewArrows = true, allowInsertArrow = true, allowInsertArrowWithRest = true) {
    let arrowParent;
    let thisEnvFn = fnPath.findParent((p) => {
      if (p.isArrowFunctionExpression()) {
        arrowParent != null ? arrowParent : arrowParent = p;
        return false;
      }
      return p.isFunction() || p.isProgram() || p.isClassProperty({
        static: false
      }) || p.isClassPrivateProperty({
        static: false
      });
    });
    const inConstructor = thisEnvFn.isClassMethod({
      kind: "constructor"
    });
    if (thisEnvFn.isClassProperty() || thisEnvFn.isClassPrivateProperty()) {
      if (arrowParent) {
        thisEnvFn = arrowParent;
      } else if (allowInsertArrow) {
        fnPath.replaceWith(callExpression(arrowFunctionExpression([], toExpression2(fnPath.node)), []));
        thisEnvFn = fnPath.get("callee");
        fnPath = thisEnvFn.get("body");
      } else {
        throw fnPath.buildCodeFrameError("Unable to transform arrow inside class property");
      }
    }
    const {
      thisPaths,
      argumentsPaths,
      newTargetPaths,
      superProps,
      superCalls
    } = getScopeInformation(fnPath);
    if (inConstructor && superCalls.length > 0) {
      if (!allowInsertArrow) {
        throw superCalls[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', it's not possible to compile `super()` in an arrow function without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
      }
      if (!allowInsertArrowWithRest) {
        throw superCalls[0].buildCodeFrameError("When using '@babel/plugin-transform-parameters', it's not possible to compile `super()` in an arrow function with default or rest parameters without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
      }
      const allSuperCalls = [];
      thisEnvFn.traverse(getSuperCallsVisitor, {
        allSuperCalls
      });
      const superBinding = getSuperBinding(thisEnvFn);
      allSuperCalls.forEach((superCall) => {
        const callee = identifier2(superBinding);
        callee.loc = superCall.node.callee.loc;
        superCall.get("callee").replaceWith(callee);
      });
    }
    if (argumentsPaths.length > 0) {
      const argumentsBinding = getBinding(thisEnvFn, "arguments", () => {
        const args = () => identifier2("arguments");
        if (thisEnvFn.scope.path.isProgram()) {
          return conditionalExpression(binaryExpression("===", unaryExpression("typeof", args()), stringLiteral("undefined")), thisEnvFn.scope.buildUndefinedNode(), args());
        } else {
          return args();
        }
      });
      argumentsPaths.forEach((argumentsChild) => {
        const argsRef = identifier2(argumentsBinding);
        argsRef.loc = argumentsChild.node.loc;
        argumentsChild.replaceWith(argsRef);
      });
    }
    if (newTargetPaths.length > 0) {
      const newTargetBinding = getBinding(thisEnvFn, "newtarget", () => metaProperty(identifier2("new"), identifier2("target")));
      newTargetPaths.forEach((targetChild) => {
        const targetRef = identifier2(newTargetBinding);
        targetRef.loc = targetChild.node.loc;
        targetChild.replaceWith(targetRef);
      });
    }
    if (superProps.length > 0) {
      if (!allowInsertArrow) {
        throw superProps[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', it's not possible to compile `super.prop` in an arrow function without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
      }
      const flatSuperProps = superProps.reduce((acc, superProp) => acc.concat(standardizeSuperProperty(superProp)), []);
      flatSuperProps.forEach((superProp) => {
        const key = superProp.node.computed ? "" : superProp.get("property").node.name;
        const superParentPath = superProp.parentPath;
        const isAssignment = superParentPath.isAssignmentExpression({
          left: superProp.node
        });
        const isCall = superParentPath.isCallExpression({
          callee: superProp.node
        });
        const isTaggedTemplate = superParentPath.isTaggedTemplateExpression({
          tag: superProp.node
        });
        const superBinding = getSuperPropBinding(thisEnvFn, isAssignment, key);
        const args = [];
        if (superProp.node.computed) {
          args.push(superProp.get("property").node);
        }
        if (isAssignment) {
          const value = superParentPath.node.right;
          args.push(value);
        }
        const call = callExpression(identifier2(superBinding), args);
        if (isCall) {
          superParentPath.unshiftContainer("arguments", thisExpression());
          superProp.replaceWith(memberExpression(call, identifier2("call")));
          thisPaths.push(superParentPath.get("arguments.0"));
        } else if (isAssignment) {
          superParentPath.replaceWith(call);
        } else if (isTaggedTemplate) {
          superProp.replaceWith(callExpression(memberExpression(call, identifier2("bind"), false), [thisExpression()]));
          thisPaths.push(superProp.get("arguments.0"));
        } else {
          superProp.replaceWith(call);
        }
      });
    }
    let thisBinding;
    if (thisPaths.length > 0 || !noNewArrows) {
      thisBinding = getThisBinding(thisEnvFn, inConstructor);
      if (noNewArrows || inConstructor && hasSuperClass(thisEnvFn)) {
        thisPaths.forEach((thisChild) => {
          const thisRef = thisChild.isJSX() ? jsxIdentifier(thisBinding) : identifier2(thisBinding);
          thisRef.loc = thisChild.node.loc;
          thisChild.replaceWith(thisRef);
        });
        if (!noNewArrows) thisBinding = null;
      }
    }
    return {
      thisBinding,
      fnPath
    };
  }
  function isLogicalOp(op) {
    return LOGICAL_OPERATORS.includes(op);
  }
  function standardizeSuperProperty(superProp) {
    if (superProp.parentPath.isAssignmentExpression() && superProp.parentPath.node.operator !== "=") {
      const assignmentPath = superProp.parentPath;
      const op = assignmentPath.node.operator.slice(0, -1);
      const value = assignmentPath.node.right;
      const isLogicalAssignment = isLogicalOp(op);
      if (superProp.node.computed) {
        const tmp = superProp.scope.generateDeclaredUidIdentifier("tmp");
        const {
          object,
          property
        } = superProp.node;
        assignmentPath.get("left").replaceWith(memberExpression(object, assignmentExpression("=", tmp, property), true));
        assignmentPath.get("right").replaceWith(rightExpression(isLogicalAssignment ? "=" : op, memberExpression(object, identifier2(tmp.name), true), value));
      } else {
        const object = superProp.node.object;
        const property = superProp.node.property;
        assignmentPath.get("left").replaceWith(memberExpression(object, property));
        assignmentPath.get("right").replaceWith(rightExpression(isLogicalAssignment ? "=" : op, memberExpression(object, identifier2(property.name)), value));
      }
      if (isLogicalAssignment) {
        assignmentPath.replaceWith(logicalExpression(op, assignmentPath.node.left, assignmentPath.node.right));
      } else {
        assignmentPath.node.operator = "=";
      }
      return [assignmentPath.get("left"), assignmentPath.get("right").get("left")];
    } else if (superProp.parentPath.isUpdateExpression()) {
      const updateExpr = superProp.parentPath;
      const tmp = superProp.scope.generateDeclaredUidIdentifier("tmp");
      const computedKey = superProp.node.computed ? superProp.scope.generateDeclaredUidIdentifier("prop") : null;
      const parts = [assignmentExpression("=", tmp, memberExpression(superProp.node.object, computedKey ? assignmentExpression("=", computedKey, superProp.node.property) : superProp.node.property, superProp.node.computed)), assignmentExpression("=", memberExpression(superProp.node.object, computedKey ? identifier2(computedKey.name) : superProp.node.property, superProp.node.computed), binaryExpression(superProp.parentPath.node.operator[0], identifier2(tmp.name), numericLiteral(1)))];
      if (!superProp.parentPath.node.prefix) {
        parts.push(identifier2(tmp.name));
      }
      updateExpr.replaceWith(sequenceExpression(parts));
      const left = updateExpr.get("expressions.0.right");
      const right = updateExpr.get("expressions.1.left");
      return [left, right];
    }
    return [superProp];
    function rightExpression(op, left, right) {
      if (op === "=") {
        return assignmentExpression("=", left, right);
      } else {
        return binaryExpression(op, left, right);
      }
    }
  }
  function hasSuperClass(thisEnvFn) {
    return thisEnvFn.isClassMethod() && !!thisEnvFn.parentPath.parentPath.node.superClass;
  }
  const assignSuperThisVisitor = (0, _visitors.environmentVisitor)({
    CallExpression(child, {
      supers,
      thisBinding
    }) {
      if (!child.get("callee").isSuper()) return;
      if (supers.has(child.node)) return;
      supers.add(child.node);
      child.replaceWithMultiple([child.node, assignmentExpression("=", identifier2(thisBinding), identifier2("this"))]);
    }
  });
  function getThisBinding(thisEnvFn, inConstructor) {
    return getBinding(thisEnvFn, "this", (thisBinding) => {
      if (!inConstructor || !hasSuperClass(thisEnvFn)) return thisExpression();
      thisEnvFn.traverse(assignSuperThisVisitor, {
        supers: /* @__PURE__ */ new WeakSet(),
        thisBinding
      });
    });
  }
  function getSuperBinding(thisEnvFn) {
    return getBinding(thisEnvFn, "supercall", () => {
      const argsBinding = thisEnvFn.scope.generateUidIdentifier("args");
      return arrowFunctionExpression([restElement(argsBinding)], callExpression(_super(), [spreadElement(identifier2(argsBinding.name))]));
    });
  }
  function getSuperPropBinding(thisEnvFn, isAssignment, propName) {
    const op = isAssignment ? "set" : "get";
    return getBinding(thisEnvFn, `superprop_${op}:${propName || ""}`, () => {
      const argsList = [];
      let fnBody;
      if (propName) {
        fnBody = memberExpression(_super(), identifier2(propName));
      } else {
        const method = thisEnvFn.scope.generateUidIdentifier("prop");
        argsList.unshift(method);
        fnBody = memberExpression(_super(), identifier2(method.name), true);
      }
      if (isAssignment) {
        const valueIdent = thisEnvFn.scope.generateUidIdentifier("value");
        argsList.push(valueIdent);
        fnBody = assignmentExpression("=", fnBody, identifier2(valueIdent.name));
      }
      return arrowFunctionExpression(argsList, fnBody);
    });
  }
  function getBinding(thisEnvFn, key, init) {
    const cacheKey = "binding:" + key;
    let data = thisEnvFn.getData(cacheKey);
    if (!data) {
      const id = thisEnvFn.scope.generateUidIdentifier(key);
      data = id.name;
      thisEnvFn.setData(cacheKey, data);
      thisEnvFn.scope.push({
        id,
        init: init(data)
      });
    }
    return data;
  }
  const getScopeInformationVisitor = (0, _visitors.environmentVisitor)({
    ThisExpression(child, {
      thisPaths
    }) {
      thisPaths.push(child);
    },
    JSXIdentifier(child, {
      thisPaths
    }) {
      if (child.node.name !== "this") return;
      if (!child.parentPath.isJSXMemberExpression({
        object: child.node
      }) && !child.parentPath.isJSXOpeningElement({
        name: child.node
      })) {
        return;
      }
      thisPaths.push(child);
    },
    CallExpression(child, {
      superCalls
    }) {
      if (child.get("callee").isSuper()) superCalls.push(child);
    },
    MemberExpression(child, {
      superProps
    }) {
      if (child.get("object").isSuper()) superProps.push(child);
    },
    Identifier(child, {
      argumentsPaths
    }) {
      if (!child.isReferencedIdentifier({
        name: "arguments"
      })) return;
      let curr = child.scope;
      do {
        if (curr.hasOwnBinding("arguments")) {
          curr.rename("arguments");
          return;
        }
        if (curr.path.isFunction() && !curr.path.isArrowFunctionExpression()) {
          break;
        }
      } while (curr = curr.parent);
      argumentsPaths.push(child);
    },
    MetaProperty(child, {
      newTargetPaths
    }) {
      if (!child.get("meta").isIdentifier({
        name: "new"
      })) return;
      if (!child.get("property").isIdentifier({
        name: "target"
      })) return;
      newTargetPaths.push(child);
    }
  });
  function getScopeInformation(fnPath) {
    const thisPaths = [];
    const argumentsPaths = [];
    const newTargetPaths = [];
    const superProps = [];
    const superCalls = [];
    fnPath.traverse(getScopeInformationVisitor, {
      thisPaths,
      argumentsPaths,
      newTargetPaths,
      superProps,
      superCalls
    });
    return {
      thisPaths,
      argumentsPaths,
      newTargetPaths,
      superProps,
      superCalls
    };
  }
  function splitExportDeclaration() {
    if (!this.isExportDeclaration() || this.isExportAllDeclaration()) {
      throw new Error("Only default and named export declarations can be split.");
    }
    if (this.isExportNamedDeclaration() && this.get("specifiers").length > 0) {
      throw new Error("It doesn't make sense to split exported specifiers.");
    }
    const declaration = this.get("declaration");
    if (this.isExportDefaultDeclaration()) {
      const standaloneDeclaration = declaration.isFunctionDeclaration() || declaration.isClassDeclaration();
      const exportExpr = declaration.isFunctionExpression() || declaration.isClassExpression();
      const scope2 = declaration.isScope() ? declaration.scope.parent : declaration.scope;
      let id = declaration.node.id;
      let needBindingRegistration = false;
      if (!id) {
        needBindingRegistration = true;
        id = scope2.generateUidIdentifier("default");
        if (standaloneDeclaration || exportExpr) {
          declaration.node.id = cloneNode2(id);
        }
      } else if (exportExpr && scope2.hasBinding(id.name)) {
        needBindingRegistration = true;
        id = scope2.generateUidIdentifier(id.name);
      }
      const updatedDeclaration = standaloneDeclaration ? declaration.node : variableDeclaration("var", [variableDeclarator(cloneNode2(id), declaration.node)]);
      const updatedExportDeclaration = exportNamedDeclaration(null, [exportSpecifier(cloneNode2(id), identifier2("default"))]);
      this.insertAfter(updatedExportDeclaration);
      this.replaceWith(updatedDeclaration);
      if (needBindingRegistration) {
        scope2.registerDeclaration(this);
      }
      return this;
    } else if (this.get("specifiers").length > 0) {
      throw new Error("It doesn't make sense to split exported specifiers.");
    }
    const bindingIdentifiers = declaration.getOuterBindingIdentifiers();
    const specifiers = Object.keys(bindingIdentifiers).map((name) => {
      return exportSpecifier(identifier2(name), identifier2(name));
    });
    const aliasDeclar = exportNamedDeclaration(null, specifiers);
    this.insertAfter(aliasDeclar);
    this.replaceWith(declaration.node);
    return this;
  }
  const refersOuterBindingVisitor = {
    "ReferencedIdentifier|BindingIdentifier"(path2, state) {
      if (path2.node.name !== state.name) return;
      state.needsRename = true;
      path2.stop();
    },
    Scope(path2, state) {
      if (path2.scope.hasOwnBinding(state.name)) {
        path2.skip();
      }
    }
  };
  function ensureFunctionName(supportUnicodeId) {
    if (this.node.id) return this;
    const res = getFunctionName2(this.node, this.parent);
    if (res == null) return this;
    let {
      name
    } = res;
    if (!supportUnicodeId && /[\uD800-\uDFFF]/.test(name)) {
      return null;
    }
    if (name.startsWith("get ") || name.startsWith("set ")) {
      return null;
    }
    name = toBindingIdentifierName2(name.replace(/[/ ]/g, "_"));
    const id = identifier2(name);
    inherits2(id, res.originalNode);
    const state = {
      needsRename: false,
      name
    };
    const {
      scope: scope2
    } = this;
    const binding2 = scope2.getOwnBinding(name);
    if (binding2) {
      if (binding2.kind === "param") {
        state.needsRename = true;
      }
    } else if (scope2.parent.hasBinding(name) || scope2.hasGlobal(name)) {
      this.traverse(refersOuterBindingVisitor, state);
    }
    if (!state.needsRename) {
      this.node.id = id;
      {
        scope2.getProgramParent().references[id.name] = true;
      }
      return this;
    }
    if (scope2.hasBinding(id.name) && !scope2.hasGlobal(id.name)) {
      scope2.rename(id.name);
      this.node.id = id;
      {
        scope2.getProgramParent().references[id.name] = true;
      }
      return this;
    }
    if (!isFunction(this.node)) return null;
    const key = scope2.generateUidIdentifier(id.name);
    const params = [];
    for (let i = 0, len = getFunctionArity(this.node); i < len; i++) {
      params.push(scope2.generateUidIdentifier("x"));
    }
    const call = _template.default.expression.ast`
    (function (${key}) {
      function ${id}(${params}) {
        return ${cloneNode2(key)}.apply(this, arguments);
      }

      ${cloneNode2(id)}.toString = function () {
        return ${cloneNode2(key)}.toString();
      }

      return ${cloneNode2(id)};
    })(${toExpression2(this.node)})
  `;
    return this.replaceWith(call)[0].get("arguments.0");
  }
  function getFunctionArity(node2) {
    const count = node2.params.findIndex((param) => isAssignmentPattern(param) || isRestElement(param));
    return count === -1 ? node2.params.length : count;
  }
  return conversion;
}
var introspection = {};
var hasRequiredIntrospection;
function requireIntrospection() {
  if (hasRequiredIntrospection) return introspection;
  hasRequiredIntrospection = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", {
      value: true
    });
    exports$1._guessExecutionStatusRelativeTo = _guessExecutionStatusRelativeTo;
    exports$1._resolve = _resolve;
    exports$1.canHaveVariableDeclarationOrExpression = canHaveVariableDeclarationOrExpression;
    exports$1.canSwapBetweenExpressionAndStatement = canSwapBetweenExpressionAndStatement;
    exports$1.getSource = getSource;
    exports$1.isCompletionRecord = isCompletionRecord;
    exports$1.isConstantExpression = isConstantExpression;
    exports$1.isInStrictMode = isInStrictMode;
    exports$1.isNodeType = isNodeType;
    exports$1.isStatementOrBlock = isStatementOrBlock;
    exports$1.isStatic = isStatic;
    exports$1.matchesPattern = matchesPattern2;
    exports$1.referencesImport = referencesImport;
    exports$1.resolve = resolve;
    exports$1.willIMaybeExecuteBefore = willIMaybeExecuteBefore;
    var _t = requireLib$4();
    const {
      STATEMENT_OR_BLOCK_KEYS,
      VISITOR_KEYS,
      isBlockStatement,
      isExpression,
      isIdentifier,
      isLiteral,
      isStringLiteral,
      isType: isType2,
      matchesPattern: _matchesPattern
    } = _t;
    function matchesPattern2(pattern, allowPartial) {
      return _matchesPattern(this.node, pattern, allowPartial);
    }
    {
      exports$1.has = function has(key) {
        var _this$node;
        const val = (_this$node = this.node) == null ? void 0 : _this$node[key];
        if (val && Array.isArray(val)) {
          return !!val.length;
        } else {
          return !!val;
        }
      };
    }
    function isStatic() {
      return this.scope.isStatic(this.node);
    }
    {
      exports$1.is = exports$1.has;
      exports$1.isnt = function isnt(key) {
        return !this.has(key);
      };
      exports$1.equals = function equals(key, value) {
        return this.node[key] === value;
      };
    }
    function isNodeType(type) {
      return isType2(this.type, type);
    }
    function canHaveVariableDeclarationOrExpression() {
      return (this.key === "init" || this.key === "left") && this.parentPath.isFor();
    }
    function canSwapBetweenExpressionAndStatement(replacement2) {
      if (this.key !== "body" || !this.parentPath.isArrowFunctionExpression()) {
        return false;
      }
      if (this.isExpression()) {
        return isBlockStatement(replacement2);
      } else if (this.isBlockStatement()) {
        return isExpression(replacement2);
      }
      return false;
    }
    function isCompletionRecord(allowInsideFunction) {
      let path2 = this;
      let first = true;
      do {
        const {
          type,
          container
        } = path2;
        if (!first && (path2.isFunction() || type === "StaticBlock")) {
          return !!allowInsideFunction;
        }
        first = false;
        if (Array.isArray(container) && path2.key !== container.length - 1) {
          return false;
        }
      } while ((path2 = path2.parentPath) && !path2.isProgram() && !path2.isDoExpression());
      return true;
    }
    function isStatementOrBlock() {
      if (this.parentPath.isLabeledStatement() || isBlockStatement(this.container)) {
        return false;
      } else {
        return STATEMENT_OR_BLOCK_KEYS.includes(this.key);
      }
    }
    function referencesImport(moduleSource, importName) {
      if (!this.isReferencedIdentifier()) {
        if (this.isJSXMemberExpression() && this.node.property.name === importName || (this.isMemberExpression() || this.isOptionalMemberExpression()) && (this.node.computed ? isStringLiteral(this.node.property, {
          value: importName
        }) : this.node.property.name === importName)) {
          const object = this.get("object");
          return object.isReferencedIdentifier() && object.referencesImport(moduleSource, "*");
        }
        return false;
      }
      const binding2 = this.scope.getBinding(this.node.name);
      if (!binding2 || binding2.kind !== "module") return false;
      const path2 = binding2.path;
      const parent = path2.parentPath;
      if (!parent.isImportDeclaration()) return false;
      if (parent.node.source.value === moduleSource) {
        if (!importName) return true;
      } else {
        return false;
      }
      if (path2.isImportDefaultSpecifier() && importName === "default") {
        return true;
      }
      if (path2.isImportNamespaceSpecifier() && importName === "*") {
        return true;
      }
      if (path2.isImportSpecifier() && isIdentifier(path2.node.imported, {
        name: importName
      })) {
        return true;
      }
      return false;
    }
    function getSource() {
      const node2 = this.node;
      if (node2.end) {
        const code = this.hub.getCode();
        if (code) return code.slice(node2.start, node2.end);
      }
      return "";
    }
    function willIMaybeExecuteBefore(target) {
      return this._guessExecutionStatusRelativeTo(target) !== "after";
    }
    function getOuterFunction(path2) {
      return path2.isProgram() ? path2 : (path2.parentPath.scope.getFunctionParent() || path2.parentPath.scope.getProgramParent()).path;
    }
    function isExecutionUncertain(type, key) {
      switch (type) {
        case "LogicalExpression":
          return key === "right";
        case "ConditionalExpression":
        case "IfStatement":
          return key === "consequent" || key === "alternate";
        case "WhileStatement":
        case "DoWhileStatement":
        case "ForInStatement":
        case "ForOfStatement":
          return key === "body";
        case "ForStatement":
          return key === "body" || key === "update";
        case "SwitchStatement":
          return key === "cases";
        case "TryStatement":
          return key === "handler";
        case "AssignmentPattern":
          return key === "right";
        case "OptionalMemberExpression":
          return key === "property";
        case "OptionalCallExpression":
          return key === "arguments";
        default:
          return false;
      }
    }
    function isExecutionUncertainInList(paths, maxIndex) {
      for (let i = 0; i < maxIndex; i++) {
        const path2 = paths[i];
        if (isExecutionUncertain(path2.parent.type, path2.parentKey)) {
          return true;
        }
      }
      return false;
    }
    const SYMBOL_CHECKING = /* @__PURE__ */ Symbol();
    function _guessExecutionStatusRelativeTo(target) {
      return _guessExecutionStatusRelativeToCached(this, target, /* @__PURE__ */ new Map());
    }
    function _guessExecutionStatusRelativeToCached(base2, target, cache2) {
      const funcParent = {
        this: getOuterFunction(base2),
        target: getOuterFunction(target)
      };
      if (funcParent.target.node !== funcParent.this.node) {
        return _guessExecutionStatusRelativeToDifferentFunctionsCached(base2, funcParent.target, cache2);
      }
      const paths = {
        target: target.getAncestry(),
        this: base2.getAncestry()
      };
      if (paths.target.includes(base2)) return "after";
      if (paths.this.includes(target)) return "before";
      let commonPath;
      const commonIndex = {
        target: 0,
        this: 0
      };
      while (!commonPath && commonIndex.this < paths.this.length) {
        const path2 = paths.this[commonIndex.this];
        commonIndex.target = paths.target.indexOf(path2);
        if (commonIndex.target >= 0) {
          commonPath = path2;
        } else {
          commonIndex.this++;
        }
      }
      if (!commonPath) {
        throw new Error("Internal Babel error - The two compared nodes don't appear to belong to the same program.");
      }
      if (isExecutionUncertainInList(paths.this, commonIndex.this - 1) || isExecutionUncertainInList(paths.target, commonIndex.target - 1)) {
        return "unknown";
      }
      const divergence = {
        this: paths.this[commonIndex.this - 1],
        target: paths.target[commonIndex.target - 1]
      };
      if (divergence.target.listKey && divergence.this.listKey && divergence.target.container === divergence.this.container) {
        return divergence.target.key > divergence.this.key ? "before" : "after";
      }
      const keys = VISITOR_KEYS[commonPath.type];
      const keyPosition = {
        this: keys.indexOf(divergence.this.parentKey),
        target: keys.indexOf(divergence.target.parentKey)
      };
      return keyPosition.target > keyPosition.this ? "before" : "after";
    }
    function _guessExecutionStatusRelativeToDifferentFunctionsInternal(base2, target, cache2) {
      if (!target.isFunctionDeclaration()) {
        if (_guessExecutionStatusRelativeToCached(base2, target, cache2) === "before") {
          return "before";
        }
        return "unknown";
      } else if (target.parentPath.isExportDeclaration()) {
        return "unknown";
      }
      const binding2 = target.scope.getBinding(target.node.id.name);
      if (!binding2.references) return "before";
      const referencePaths = binding2.referencePaths;
      let allStatus;
      for (const path2 of referencePaths) {
        const childOfFunction = !!path2.find((path3) => path3.node === target.node);
        if (childOfFunction) continue;
        if (path2.key !== "callee" || !path2.parentPath.isCallExpression()) {
          return "unknown";
        }
        const status = _guessExecutionStatusRelativeToCached(base2, path2, cache2);
        if (allStatus && allStatus !== status) {
          return "unknown";
        } else {
          allStatus = status;
        }
      }
      return allStatus;
    }
    function _guessExecutionStatusRelativeToDifferentFunctionsCached(base2, target, cache2) {
      let nodeMap = cache2.get(base2.node);
      let cached;
      if (!nodeMap) {
        cache2.set(base2.node, nodeMap = /* @__PURE__ */ new Map());
      } else if (cached = nodeMap.get(target.node)) {
        if (cached === SYMBOL_CHECKING) {
          return "unknown";
        }
        return cached;
      }
      nodeMap.set(target.node, SYMBOL_CHECKING);
      const result = _guessExecutionStatusRelativeToDifferentFunctionsInternal(base2, target, cache2);
      nodeMap.set(target.node, result);
      return result;
    }
    function resolve(dangerous, resolved) {
      return _resolve.call(this, dangerous, resolved) || this;
    }
    function _resolve(dangerous, resolved) {
      var _resolved;
      if ((_resolved = resolved) != null && _resolved.includes(this)) return;
      resolved = resolved || [];
      resolved.push(this);
      if (this.isVariableDeclarator()) {
        if (this.get("id").isIdentifier()) {
          return this.get("init").resolve(dangerous, resolved);
        }
      } else if (this.isReferencedIdentifier()) {
        const binding2 = this.scope.getBinding(this.node.name);
        if (!binding2) return;
        if (!binding2.constant) return;
        if (binding2.kind === "module") return;
        if (binding2.path !== this) {
          const ret = binding2.path.resolve(dangerous, resolved);
          if (this.find((parent) => parent.node === ret.node)) return;
          return ret;
        }
      } else if (this.isTypeCastExpression()) {
        return this.get("expression").resolve(dangerous, resolved);
      } else if (dangerous && this.isMemberExpression()) {
        const targetKey = this.toComputedKey();
        if (!isLiteral(targetKey)) return;
        const targetName = targetKey.value;
        const target = this.get("object").resolve(dangerous, resolved);
        if (target.isObjectExpression()) {
          const props = target.get("properties");
          for (const prop of props) {
            if (!prop.isProperty()) continue;
            const key = prop.get("key");
            let match = prop.isnt("computed") && key.isIdentifier({
              name: targetName
            });
            match = match || key.isLiteral({
              value: targetName
            });
            if (match) return prop.get("value").resolve(dangerous, resolved);
          }
        } else if (target.isArrayExpression() && !isNaN(+targetName)) {
          const elems = target.get("elements");
          const elem = elems[targetName];
          if (elem) return elem.resolve(dangerous, resolved);
        }
      }
    }
    function isConstantExpression() {
      if (this.isIdentifier()) {
        const binding2 = this.scope.getBinding(this.node.name);
        if (!binding2) return false;
        return binding2.constant;
      }
      if (this.isLiteral()) {
        if (this.isRegExpLiteral()) {
          return false;
        }
        if (this.isTemplateLiteral()) {
          return this.get("expressions").every((expression) => expression.isConstantExpression());
        }
        return true;
      }
      if (this.isUnaryExpression()) {
        if (this.node.operator !== "void") {
          return false;
        }
        return this.get("argument").isConstantExpression();
      }
      if (this.isBinaryExpression()) {
        const {
          operator
        } = this.node;
        return operator !== "in" && operator !== "instanceof" && this.get("left").isConstantExpression() && this.get("right").isConstantExpression();
      }
      if (this.isMemberExpression()) {
        return !this.node.computed && this.get("object").isIdentifier({
          name: "Symbol"
        }) && !this.scope.hasBinding("Symbol", {
          noGlobals: true
        });
      }
      if (this.isCallExpression()) {
        return this.node.arguments.length === 1 && this.get("callee").matchesPattern("Symbol.for") && !this.scope.hasBinding("Symbol", {
          noGlobals: true
        }) && this.get("arguments")[0].isStringLiteral();
      }
      return false;
    }
    function isInStrictMode() {
      const start = this.isProgram() ? this : this.parentPath;
      const strictParent = start.find((path2) => {
        if (path2.isProgram({
          sourceType: "module"
        })) return true;
        if (path2.isClass()) return true;
        if (path2.isArrowFunctionExpression() && !path2.get("body").isBlockStatement()) {
          return false;
        }
        let body;
        if (path2.isFunction()) {
          body = path2.node.body;
        } else if (path2.isProgram()) {
          body = path2.node;
        } else {
          return false;
        }
        for (const directive of body.directives) {
          if (directive.value.value === "use strict") {
            return true;
          }
        }
        return false;
      });
      return !!strictParent;
    }
  })(introspection);
  return introspection;
}
var family = {};
var hasRequiredFamily;
function requireFamily() {
  if (hasRequiredFamily) return family;
  hasRequiredFamily = 1;
  Object.defineProperty(family, "__esModule", {
    value: true
  });
  family._getKey = _getKey;
  family._getPattern = _getPattern;
  family.get = get;
  family.getAllNextSiblings = getAllNextSiblings;
  family.getAllPrevSiblings = getAllPrevSiblings;
  family.getAssignmentIdentifiers = getAssignmentIdentifiers2;
  family.getBindingIdentifierPaths = getBindingIdentifierPaths;
  family.getBindingIdentifiers = getBindingIdentifiers2;
  family.getCompletionRecords = getCompletionRecords;
  family.getNextSibling = getNextSibling;
  family.getOpposite = getOpposite;
  family.getOuterBindingIdentifierPaths = getOuterBindingIdentifierPaths;
  family.getOuterBindingIdentifiers = getOuterBindingIdentifiers2;
  family.getPrevSibling = getPrevSibling;
  family.getSibling = getSibling;
  var _index = requirePath();
  var _t = requireLib$4();
  const {
    getAssignmentIdentifiers: _getAssignmentIdentifiers,
    getBindingIdentifiers: _getBindingIdentifiers,
    getOuterBindingIdentifiers: _getOuterBindingIdentifiers,
    numericLiteral,
    unaryExpression
  } = _t;
  const NORMAL_COMPLETION = 0;
  const BREAK_COMPLETION = 1;
  function NormalCompletion(path2) {
    return {
      type: NORMAL_COMPLETION,
      path: path2
    };
  }
  function BreakCompletion(path2) {
    return {
      type: BREAK_COMPLETION,
      path: path2
    };
  }
  function getOpposite() {
    if (this.key === "left") {
      return this.getSibling("right");
    } else if (this.key === "right") {
      return this.getSibling("left");
    }
    return null;
  }
  function addCompletionRecords(path2, records, context2) {
    if (path2) {
      records.push(..._getCompletionRecords(path2, context2));
    }
    return records;
  }
  function completionRecordForSwitch(cases, records, context2) {
    let lastNormalCompletions = [];
    for (let i = 0; i < cases.length; i++) {
      const casePath = cases[i];
      const caseCompletions = _getCompletionRecords(casePath, context2);
      const normalCompletions = [];
      const breakCompletions = [];
      for (const c of caseCompletions) {
        if (c.type === NORMAL_COMPLETION) {
          normalCompletions.push(c);
        }
        if (c.type === BREAK_COMPLETION) {
          breakCompletions.push(c);
        }
      }
      if (normalCompletions.length) {
        lastNormalCompletions = normalCompletions;
      }
      records.push(...breakCompletions);
    }
    records.push(...lastNormalCompletions);
    return records;
  }
  function normalCompletionToBreak(completions) {
    completions.forEach((c) => {
      c.type = BREAK_COMPLETION;
    });
  }
  function replaceBreakStatementInBreakCompletion(completions, reachable) {
    completions.forEach((c) => {
      if (c.path.isBreakStatement({
        label: null
      })) {
        if (reachable) {
          c.path.replaceWith(unaryExpression("void", numericLiteral(0)));
        } else {
          c.path.remove();
        }
      }
    });
  }
  function getStatementListCompletion(paths, context2) {
    const completions = [];
    if (context2.canHaveBreak) {
      let lastNormalCompletions = [];
      for (let i = 0; i < paths.length; i++) {
        const path2 = paths[i];
        const newContext = Object.assign({}, context2, {
          inCaseClause: false
        });
        if (path2.isBlockStatement() && (context2.inCaseClause || context2.shouldPopulateBreak)) {
          newContext.shouldPopulateBreak = true;
        } else {
          newContext.shouldPopulateBreak = false;
        }
        const statementCompletions = _getCompletionRecords(path2, newContext);
        if (statementCompletions.length > 0 && statementCompletions.every((c) => c.type === BREAK_COMPLETION)) {
          if (lastNormalCompletions.length > 0 && statementCompletions.every((c) => c.path.isBreakStatement({
            label: null
          }))) {
            normalCompletionToBreak(lastNormalCompletions);
            completions.push(...lastNormalCompletions);
            if (lastNormalCompletions.some((c) => c.path.isDeclaration())) {
              completions.push(...statementCompletions);
              if (!context2.shouldPreserveBreak) {
                replaceBreakStatementInBreakCompletion(statementCompletions, true);
              }
            }
            if (!context2.shouldPreserveBreak) {
              replaceBreakStatementInBreakCompletion(statementCompletions, false);
            }
          } else {
            completions.push(...statementCompletions);
            if (!context2.shouldPopulateBreak && !context2.shouldPreserveBreak) {
              replaceBreakStatementInBreakCompletion(statementCompletions, true);
            }
          }
          break;
        }
        if (i === paths.length - 1) {
          completions.push(...statementCompletions);
        } else {
          lastNormalCompletions = [];
          for (let i2 = 0; i2 < statementCompletions.length; i2++) {
            const c = statementCompletions[i2];
            if (c.type === BREAK_COMPLETION) {
              completions.push(c);
            }
            if (c.type === NORMAL_COMPLETION) {
              lastNormalCompletions.push(c);
            }
          }
        }
      }
    } else if (paths.length) {
      for (let i = paths.length - 1; i >= 0; i--) {
        const pathCompletions = _getCompletionRecords(paths[i], context2);
        if (pathCompletions.length > 1 || pathCompletions.length === 1 && !pathCompletions[0].path.isVariableDeclaration() && !pathCompletions[0].path.isEmptyStatement()) {
          completions.push(...pathCompletions);
          break;
        }
      }
    }
    return completions;
  }
  function _getCompletionRecords(path2, context2) {
    let records = [];
    if (path2.isIfStatement()) {
      records = addCompletionRecords(path2.get("consequent"), records, context2);
      records = addCompletionRecords(path2.get("alternate"), records, context2);
    } else if (path2.isDoExpression() || path2.isFor() || path2.isWhile() || path2.isLabeledStatement()) {
      return addCompletionRecords(path2.get("body"), records, context2);
    } else if (path2.isProgram() || path2.isBlockStatement()) {
      return getStatementListCompletion(path2.get("body"), context2);
    } else if (path2.isFunction()) {
      return _getCompletionRecords(path2.get("body"), context2);
    } else if (path2.isTryStatement()) {
      records = addCompletionRecords(path2.get("block"), records, context2);
      records = addCompletionRecords(path2.get("handler"), records, context2);
    } else if (path2.isCatchClause()) {
      return addCompletionRecords(path2.get("body"), records, context2);
    } else if (path2.isSwitchStatement()) {
      return completionRecordForSwitch(path2.get("cases"), records, context2);
    } else if (path2.isSwitchCase()) {
      return getStatementListCompletion(path2.get("consequent"), {
        canHaveBreak: true,
        shouldPopulateBreak: false,
        inCaseClause: true,
        shouldPreserveBreak: context2.shouldPreserveBreak
      });
    } else if (path2.isBreakStatement()) {
      records.push(BreakCompletion(path2));
    } else {
      records.push(NormalCompletion(path2));
    }
    return records;
  }
  function getCompletionRecords(shouldPreserveBreak = false) {
    const records = _getCompletionRecords(this, {
      canHaveBreak: false,
      shouldPopulateBreak: false,
      inCaseClause: false,
      shouldPreserveBreak
    });
    return records.map((r) => r.path);
  }
  function getSibling(key) {
    return _index.default.get({
      parentPath: this.parentPath,
      parent: this.parent,
      container: this.container,
      listKey: this.listKey,
      key
    }).setContext(this.context);
  }
  function getPrevSibling() {
    return this.getSibling(this.key - 1);
  }
  function getNextSibling() {
    return this.getSibling(this.key + 1);
  }
  function getAllNextSiblings() {
    let _key = this.key;
    let sibling = this.getSibling(++_key);
    const siblings = [];
    while (sibling.node) {
      siblings.push(sibling);
      sibling = this.getSibling(++_key);
    }
    return siblings;
  }
  function getAllPrevSiblings() {
    let _key = this.key;
    let sibling = this.getSibling(--_key);
    const siblings = [];
    while (sibling.node) {
      siblings.push(sibling);
      sibling = this.getSibling(--_key);
    }
    return siblings;
  }
  function get(key, context2 = true) {
    if (context2 === true) context2 = this.context;
    const parts = key.split(".");
    if (parts.length === 1) {
      return _getKey.call(this, key, context2);
    } else {
      return _getPattern.call(this, parts, context2);
    }
  }
  function _getKey(key, context2) {
    const node2 = this.node;
    const container = node2[key];
    if (Array.isArray(container)) {
      return container.map((_, i) => {
        return _index.default.get({
          listKey: key,
          parentPath: this,
          parent: node2,
          container,
          key: i
        }).setContext(context2);
      });
    } else {
      return _index.default.get({
        parentPath: this,
        parent: node2,
        container: node2,
        key
      }).setContext(context2);
    }
  }
  function _getPattern(parts, context2) {
    let path2 = this;
    for (const part of parts) {
      if (part === ".") {
        path2 = path2.parentPath;
      } else {
        if (Array.isArray(path2)) {
          path2 = path2[part];
        } else {
          path2 = path2.get(part, context2);
        }
      }
    }
    return path2;
  }
  function getAssignmentIdentifiers2() {
    return _getAssignmentIdentifiers(this.node);
  }
  function getBindingIdentifiers2(duplicates) {
    return _getBindingIdentifiers(this.node, duplicates);
  }
  function getOuterBindingIdentifiers2(duplicates) {
    return _getOuterBindingIdentifiers(this.node, duplicates);
  }
  function getBindingIdentifierPaths(duplicates = false, outerOnly = false) {
    const path2 = this;
    const search = [path2];
    const ids = /* @__PURE__ */ Object.create(null);
    while (search.length) {
      const id = search.shift();
      if (!id) continue;
      if (!id.node) continue;
      const keys = _getBindingIdentifiers.keys[id.node.type];
      if (id.isIdentifier()) {
        if (duplicates) {
          const _ids = ids[id.node.name] = ids[id.node.name] || [];
          _ids.push(id);
        } else {
          ids[id.node.name] = id;
        }
        continue;
      }
      if (id.isExportDeclaration()) {
        const declaration = id.get("declaration");
        if (declaration.isDeclaration()) {
          search.push(declaration);
        }
        continue;
      }
      if (outerOnly) {
        if (id.isFunctionDeclaration()) {
          search.push(id.get("id"));
          continue;
        }
        if (id.isFunctionExpression()) {
          continue;
        }
      }
      if (keys) {
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          const child = id.get(key);
          if (Array.isArray(child)) {
            search.push(...child);
          } else if (child.node) {
            search.push(child);
          }
        }
      }
    }
    return ids;
  }
  function getOuterBindingIdentifierPaths(duplicates = false) {
    return this.getBindingIdentifierPaths(duplicates, true);
  }
  return family;
}
var comments = {};
var hasRequiredComments;
function requireComments() {
  if (hasRequiredComments) return comments;
  hasRequiredComments = 1;
  Object.defineProperty(comments, "__esModule", {
    value: true
  });
  comments.addComment = addComment2;
  comments.addComments = addComments2;
  comments.shareCommentsWithSiblings = shareCommentsWithSiblings;
  var _t = requireLib$4();
  const {
    addComment: _addComment,
    addComments: _addComments
  } = _t;
  function shareCommentsWithSiblings() {
    if (typeof this.key === "string") return;
    const node2 = this.node;
    if (!node2) return;
    const trailing = node2.trailingComments;
    const leading = node2.leadingComments;
    if (!trailing && !leading) return;
    const prev = this.getSibling(this.key - 1);
    const next = this.getSibling(this.key + 1);
    const hasPrev = Boolean(prev.node);
    const hasNext = Boolean(next.node);
    if (hasPrev) {
      if (leading) {
        prev.addComments("trailing", removeIfExisting(leading, prev.node.trailingComments));
      }
      if (trailing && !hasNext) prev.addComments("trailing", trailing);
    }
    if (hasNext) {
      if (trailing) {
        next.addComments("leading", removeIfExisting(trailing, next.node.leadingComments));
      }
      if (leading && !hasPrev) next.addComments("leading", leading);
    }
  }
  function removeIfExisting(list, toRemove) {
    if (!(toRemove != null && toRemove.length)) return list;
    const set = new Set(toRemove);
    return list.filter((el) => {
      return !set.has(el);
    });
  }
  function addComment2(type, content, line) {
    _addComment(this.node, type, content, line);
  }
  function addComments2(type, comments2) {
    _addComments(this.node, type, comments2);
  }
  return comments;
}
var hasRequiredPath;
function requirePath() {
  if (hasRequiredPath) return path;
  hasRequiredPath = 1;
  Object.defineProperty(path, "__esModule", {
    value: true
  });
  path.default = path.SHOULD_STOP = path.SHOULD_SKIP = path.REMOVED = void 0;
  var virtualTypes2 = requireVirtualTypes();
  var _debug = requireSrc();
  var _index = requireLib();
  var _index2 = requireScope();
  var _t = requireLib$4();
  var t = _t;
  var cache2 = requireCache();
  var _generator = requireLib$3();
  var NodePath_ancestry = requireAncestry();
  var NodePath_inference = requireInference();
  var NodePath_replacement = requireReplacement();
  var NodePath_evaluation = requireEvaluation();
  var NodePath_conversion = requireConversion();
  var NodePath_introspection = requireIntrospection();
  var _context = requireContext();
  var NodePath_context = _context;
  var NodePath_removal = requireRemoval();
  var NodePath_modification = requireModification();
  var NodePath_family = requireFamily();
  var NodePath_comments = requireComments();
  var NodePath_virtual_types_validator = requireVirtualTypesValidator();
  const {
    validate: validate2
  } = _t;
  const debug = _debug("babel");
  path.REMOVED = 1 << 0;
  path.SHOULD_STOP = 1 << 1;
  path.SHOULD_SKIP = 1 << 2;
  const NodePath_Final = path.default = class NodePath {
    constructor(hub2, parent) {
      this.contexts = [];
      this.state = null;
      this._traverseFlags = 0;
      this.skipKeys = null;
      this.parentPath = null;
      this.container = null;
      this.listKey = null;
      this.key = null;
      this.node = null;
      this.type = null;
      this._store = null;
      this.parent = parent;
      this.hub = hub2;
      this.data = null;
      this.context = null;
      this.scope = null;
    }
    get removed() {
      return (this._traverseFlags & 1) > 0;
    }
    set removed(v) {
      if (v) this._traverseFlags |= 1;
      else this._traverseFlags &= -2;
    }
    get shouldStop() {
      return (this._traverseFlags & 2) > 0;
    }
    set shouldStop(v) {
      if (v) this._traverseFlags |= 2;
      else this._traverseFlags &= -3;
    }
    get shouldSkip() {
      return (this._traverseFlags & 4) > 0;
    }
    set shouldSkip(v) {
      if (v) this._traverseFlags |= 4;
      else this._traverseFlags &= -5;
    }
    static get({
      hub: hub2,
      parentPath,
      parent,
      container,
      listKey,
      key
    }) {
      if (!hub2 && parentPath) {
        hub2 = parentPath.hub;
      }
      if (!parent) {
        throw new Error("To get a node path the parent needs to exist");
      }
      const targetNode = container[key];
      const paths = cache2.getOrCreateCachedPaths(parent, parentPath);
      let path2 = paths.get(targetNode);
      if (!path2) {
        path2 = new NodePath(hub2, parent);
        if (targetNode) paths.set(targetNode, path2);
      }
      _context.setup.call(path2, parentPath, container, listKey, key);
      return path2;
    }
    getScope(scope2) {
      return this.isScope() ? new _index2.default(this) : scope2;
    }
    setData(key, val) {
      if (this.data == null) {
        this.data = /* @__PURE__ */ Object.create(null);
      }
      return this.data[key] = val;
    }
    getData(key, def) {
      if (this.data == null) {
        this.data = /* @__PURE__ */ Object.create(null);
      }
      let val = this.data[key];
      if (val === void 0 && def !== void 0) val = this.data[key] = def;
      return val;
    }
    hasNode() {
      return this.node != null;
    }
    buildCodeFrameError(msg, Error2 = SyntaxError) {
      return this.hub.buildError(this.node, msg, Error2);
    }
    traverse(visitor, state) {
      (0, _index.default)(this.node, visitor, this.scope, state, this);
    }
    set(key, node2) {
      validate2(this.node, key, node2);
      this.node[key] = node2;
    }
    getPathLocation() {
      const parts = [];
      let path2 = this;
      do {
        let key = path2.key;
        if (path2.inList) key = `${path2.listKey}[${key}]`;
        parts.unshift(key);
      } while (path2 = path2.parentPath);
      return parts.join(".");
    }
    debug(message) {
      if (!debug.enabled) return;
      debug(`${this.getPathLocation()} ${this.type}: ${message}`);
    }
    toString() {
      return (0, _generator.default)(this.node).code;
    }
    get inList() {
      return !!this.listKey;
    }
    set inList(inList) {
      if (!inList) {
        this.listKey = null;
      }
    }
    get parentKey() {
      return this.listKey || this.key;
    }
  };
  const methods2 = {
    findParent: NodePath_ancestry.findParent,
    find: NodePath_ancestry.find,
    getFunctionParent: NodePath_ancestry.getFunctionParent,
    getStatementParent: NodePath_ancestry.getStatementParent,
    getEarliestCommonAncestorFrom: NodePath_ancestry.getEarliestCommonAncestorFrom,
    getDeepestCommonAncestorFrom: NodePath_ancestry.getDeepestCommonAncestorFrom,
    getAncestry: NodePath_ancestry.getAncestry,
    isAncestor: NodePath_ancestry.isAncestor,
    isDescendant: NodePath_ancestry.isDescendant,
    inType: NodePath_ancestry.inType,
    getTypeAnnotation: NodePath_inference.getTypeAnnotation,
    isBaseType: NodePath_inference.isBaseType,
    couldBeBaseType: NodePath_inference.couldBeBaseType,
    baseTypeStrictlyMatches: NodePath_inference.baseTypeStrictlyMatches,
    isGenericType: NodePath_inference.isGenericType,
    replaceWithMultiple: NodePath_replacement.replaceWithMultiple,
    replaceWithSourceString: NodePath_replacement.replaceWithSourceString,
    replaceWith: NodePath_replacement.replaceWith,
    replaceExpressionWithStatements: NodePath_replacement.replaceExpressionWithStatements,
    replaceInline: NodePath_replacement.replaceInline,
    evaluateTruthy: NodePath_evaluation.evaluateTruthy,
    evaluate: NodePath_evaluation.evaluate,
    toComputedKey: NodePath_conversion.toComputedKey,
    ensureBlock: NodePath_conversion.ensureBlock,
    unwrapFunctionEnvironment: NodePath_conversion.unwrapFunctionEnvironment,
    arrowFunctionToExpression: NodePath_conversion.arrowFunctionToExpression,
    splitExportDeclaration: NodePath_conversion.splitExportDeclaration,
    ensureFunctionName: NodePath_conversion.ensureFunctionName,
    matchesPattern: NodePath_introspection.matchesPattern,
    isStatic: NodePath_introspection.isStatic,
    isNodeType: NodePath_introspection.isNodeType,
    canHaveVariableDeclarationOrExpression: NodePath_introspection.canHaveVariableDeclarationOrExpression,
    canSwapBetweenExpressionAndStatement: NodePath_introspection.canSwapBetweenExpressionAndStatement,
    isCompletionRecord: NodePath_introspection.isCompletionRecord,
    isStatementOrBlock: NodePath_introspection.isStatementOrBlock,
    referencesImport: NodePath_introspection.referencesImport,
    getSource: NodePath_introspection.getSource,
    willIMaybeExecuteBefore: NodePath_introspection.willIMaybeExecuteBefore,
    _guessExecutionStatusRelativeTo: NodePath_introspection._guessExecutionStatusRelativeTo,
    resolve: NodePath_introspection.resolve,
    isConstantExpression: NodePath_introspection.isConstantExpression,
    isInStrictMode: NodePath_introspection.isInStrictMode,
    isDenylisted: NodePath_context.isDenylisted,
    visit: NodePath_context.visit,
    skip: NodePath_context.skip,
    skipKey: NodePath_context.skipKey,
    stop: NodePath_context.stop,
    setContext: NodePath_context.setContext,
    requeue: NodePath_context.requeue,
    requeueComputedKeyAndDecorators: NodePath_context.requeueComputedKeyAndDecorators,
    remove: NodePath_removal.remove,
    insertBefore: NodePath_modification.insertBefore,
    insertAfter: NodePath_modification.insertAfter,
    unshiftContainer: NodePath_modification.unshiftContainer,
    pushContainer: NodePath_modification.pushContainer,
    getOpposite: NodePath_family.getOpposite,
    getCompletionRecords: NodePath_family.getCompletionRecords,
    getSibling: NodePath_family.getSibling,
    getPrevSibling: NodePath_family.getPrevSibling,
    getNextSibling: NodePath_family.getNextSibling,
    getAllNextSiblings: NodePath_family.getAllNextSiblings,
    getAllPrevSiblings: NodePath_family.getAllPrevSiblings,
    get: NodePath_family.get,
    getAssignmentIdentifiers: NodePath_family.getAssignmentIdentifiers,
    getBindingIdentifiers: NodePath_family.getBindingIdentifiers,
    getOuterBindingIdentifiers: NodePath_family.getOuterBindingIdentifiers,
    getBindingIdentifierPaths: NodePath_family.getBindingIdentifierPaths,
    getOuterBindingIdentifierPaths: NodePath_family.getOuterBindingIdentifierPaths,
    shareCommentsWithSiblings: NodePath_comments.shareCommentsWithSiblings,
    addComment: NodePath_comments.addComment,
    addComments: NodePath_comments.addComments
  };
  Object.assign(NodePath_Final.prototype, methods2);
  {
    NodePath_Final.prototype.arrowFunctionToShadowed = NodePath_conversion[String("arrowFunctionToShadowed")];
    Object.assign(NodePath_Final.prototype, {
      has: NodePath_introspection[String("has")],
      is: NodePath_introspection[String("is")],
      isnt: NodePath_introspection[String("isnt")],
      equals: NodePath_introspection[String("equals")],
      hoist: NodePath_modification[String("hoist")],
      updateSiblingKeys: NodePath_modification.updateSiblingKeys,
      call: NodePath_context.call,
      isBlacklisted: NodePath_context[String("isBlacklisted")],
      setScope: NodePath_context.setScope,
      resync: NodePath_context.resync,
      popContext: NodePath_context.popContext,
      pushContext: NodePath_context.pushContext,
      setup: NodePath_context.setup,
      setKey: NodePath_context.setKey
    });
  }
  {
    NodePath_Final.prototype._guessExecutionStatusRelativeToDifferentFunctions = NodePath_introspection._guessExecutionStatusRelativeTo;
    NodePath_Final.prototype._guessExecutionStatusRelativeToDifferentFunctions = NodePath_introspection._guessExecutionStatusRelativeTo;
    Object.assign(NodePath_Final.prototype, {
      _getTypeAnnotation: NodePath_inference._getTypeAnnotation,
      _replaceWith: NodePath_replacement._replaceWith,
      _resolve: NodePath_introspection._resolve,
      _call: NodePath_context._call,
      _resyncParent: NodePath_context._resyncParent,
      _resyncKey: NodePath_context._resyncKey,
      _resyncList: NodePath_context._resyncList,
      _resyncRemoved: NodePath_context._resyncRemoved,
      _getQueueContexts: NodePath_context._getQueueContexts,
      _removeFromScope: NodePath_removal._removeFromScope,
      _callRemovalHooks: NodePath_removal._callRemovalHooks,
      _remove: NodePath_removal._remove,
      _markRemoved: NodePath_removal._markRemoved,
      _assertUnremoved: NodePath_removal._assertUnremoved,
      _containerInsert: NodePath_modification._containerInsert,
      _containerInsertBefore: NodePath_modification._containerInsertBefore,
      _containerInsertAfter: NodePath_modification._containerInsertAfter,
      _verifyNodeList: NodePath_modification._verifyNodeList,
      _getKey: NodePath_family._getKey,
      _getPattern: NodePath_family._getPattern
    });
  }
  for (const type of t.TYPES) {
    const typeKey = `is${type}`;
    const fn = t[typeKey];
    NodePath_Final.prototype[typeKey] = function(opts) {
      return fn(this.node, opts);
    };
    NodePath_Final.prototype[`assert${type}`] = function(opts) {
      if (!fn(this.node, opts)) {
        throw new TypeError(`Expected node path of type ${type}`);
      }
    };
  }
  Object.assign(NodePath_Final.prototype, NodePath_virtual_types_validator);
  for (const type of Object.keys(virtualTypes2)) {
    if (type[0] === "_") continue;
    if (!t.TYPES.includes(type)) t.TYPES.push(type);
  }
  return path;
}
var hasRequiredContext$1;
function requireContext$1() {
  if (hasRequiredContext$1) return context;
  hasRequiredContext$1 = 1;
  Object.defineProperty(context, "__esModule", {
    value: true
  });
  context.default = void 0;
  var _index = requirePath();
  var _t = requireLib$4();
  var _context = requireContext();
  const {
    VISITOR_KEYS
  } = _t;
  class TraversalContext {
    constructor(scope2, opts, state, parentPath) {
      this.queue = null;
      this.priorityQueue = null;
      this.parentPath = parentPath;
      this.scope = scope2;
      this.state = state;
      this.opts = opts;
    }
    shouldVisit(node2) {
      const opts = this.opts;
      if (opts.enter || opts.exit) return true;
      if (opts[node2.type]) return true;
      const keys = VISITOR_KEYS[node2.type];
      if (!(keys != null && keys.length)) return false;
      for (const key of keys) {
        if (node2[key]) {
          return true;
        }
      }
      return false;
    }
    create(node2, container, key, listKey) {
      return _index.default.get({
        parentPath: this.parentPath,
        parent: node2,
        container,
        key,
        listKey
      });
    }
    maybeQueue(path2, notPriority) {
      if (this.queue) {
        if (notPriority) {
          this.queue.push(path2);
        } else {
          this.priorityQueue.push(path2);
        }
      }
    }
    visitMultiple(container, parent, listKey) {
      if (container.length === 0) return false;
      const queue = [];
      for (let key = 0; key < container.length; key++) {
        const node2 = container[key];
        if (node2 && this.shouldVisit(node2)) {
          queue.push(this.create(parent, container, key, listKey));
        }
      }
      return this.visitQueue(queue);
    }
    visitSingle(node2, key) {
      if (this.shouldVisit(node2[key])) {
        return this.visitQueue([this.create(node2, node2, key)]);
      } else {
        return false;
      }
    }
    visitQueue(queue) {
      this.queue = queue;
      this.priorityQueue = [];
      const visited = /* @__PURE__ */ new WeakSet();
      let stop = false;
      let visitIndex = 0;
      for (; visitIndex < queue.length; ) {
        const path2 = queue[visitIndex];
        visitIndex++;
        _context.resync.call(path2);
        if (path2.contexts.length === 0 || path2.contexts[path2.contexts.length - 1] !== this) {
          _context.pushContext.call(path2, this);
        }
        if (path2.key === null) continue;
        const {
          node: node2
        } = path2;
        if (visited.has(node2)) continue;
        if (node2) visited.add(node2);
        if (path2.visit()) {
          stop = true;
          break;
        }
        if (this.priorityQueue.length) {
          stop = this.visitQueue(this.priorityQueue);
          this.priorityQueue = [];
          this.queue = queue;
          if (stop) break;
        }
      }
      for (let i = 0; i < visitIndex; i++) {
        _context.popContext.call(queue[i]);
      }
      this.queue = null;
      return stop;
    }
    visit(node2, key) {
      const nodes = node2[key];
      if (!nodes) return false;
      if (Array.isArray(nodes)) {
        return this.visitMultiple(nodes, node2, key);
      } else {
        return this.visitSingle(node2, key);
      }
    }
  }
  context.default = TraversalContext;
  return context;
}
var hasRequiredTraverseNode;
function requireTraverseNode() {
  if (hasRequiredTraverseNode) return traverseNode;
  hasRequiredTraverseNode = 1;
  Object.defineProperty(traverseNode, "__esModule", {
    value: true
  });
  traverseNode.traverseNode = traverseNode$1;
  var _context = requireContext$1();
  requirePath();
  var _t = requireLib$4();
  requireContext();
  const {
    VISITOR_KEYS
  } = _t;
  function traverseNode$1(node2, opts, scope2, state, path2, skipKeys, visitSelf) {
    const keys = VISITOR_KEYS[node2.type];
    if (!keys) return false;
    const context2 = new _context.default(scope2, opts, state, path2);
    if (visitSelf) {
      if (skipKeys != null && skipKeys[path2.parentKey]) return false;
      return context2.visitQueue([path2]);
    }
    for (const key of keys) {
      if (skipKeys != null && skipKeys[key]) continue;
      if (context2.visit(node2, key)) {
        return true;
      }
    }
    return false;
  }
  return traverseNode;
}
var hasRequiredContext;
function requireContext() {
  if (hasRequiredContext) return context$1;
  hasRequiredContext = 1;
  Object.defineProperty(context$1, "__esModule", {
    value: true
  });
  context$1._call = _call;
  context$1._getQueueContexts = _getQueueContexts;
  context$1._resyncKey = _resyncKey;
  context$1._resyncList = _resyncList;
  context$1._resyncParent = _resyncParent;
  context$1._resyncRemoved = _resyncRemoved;
  context$1.call = call;
  context$1.isDenylisted = isDenylisted;
  context$1.popContext = popContext;
  context$1.pushContext = pushContext;
  context$1.requeue = requeue;
  context$1.requeueComputedKeyAndDecorators = requeueComputedKeyAndDecorators;
  context$1.resync = resync;
  context$1.setContext = setContext;
  context$1.setKey = setKey;
  context$1.setScope = setScope;
  context$1.setup = setup;
  context$1.skip = skip;
  context$1.skipKey = skipKey;
  context$1.stop = stop;
  context$1.visit = visit;
  var _traverseNode = requireTraverseNode();
  var _index = requirePath();
  var _removal = requireRemoval();
  var t = requireLib$4();
  function call(key) {
    const opts = this.opts;
    this.debug(key);
    if (this.node) {
      if (_call.call(this, opts[key])) return true;
    }
    if (this.node) {
      var _opts$this$node$type;
      return _call.call(this, (_opts$this$node$type = opts[this.node.type]) == null ? void 0 : _opts$this$node$type[key]);
    }
    return false;
  }
  function _call(fns) {
    if (!fns) return false;
    for (const fn of fns) {
      if (!fn) continue;
      const node2 = this.node;
      if (!node2) return true;
      const ret = fn.call(this.state, this, this.state);
      if (ret && typeof ret === "object" && typeof ret.then === "function") {
        throw new Error(`You appear to be using a plugin with an async traversal visitor, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.`);
      }
      if (ret) {
        throw new Error(`Unexpected return value from visitor method ${fn}`);
      }
      if (this.node !== node2) return true;
      if (this._traverseFlags > 0) return true;
    }
    return false;
  }
  function isDenylisted() {
    var _this$opts$denylist;
    const denylist = (_this$opts$denylist = this.opts.denylist) != null ? _this$opts$denylist : this.opts.blacklist;
    return denylist == null ? void 0 : denylist.includes(this.node.type);
  }
  {
    context$1.isBlacklisted = isDenylisted;
  }
  function restoreContext(path2, context2) {
    if (path2.context !== context2) {
      path2.context = context2;
      path2.state = context2.state;
      path2.opts = context2.opts;
    }
  }
  function visit() {
    var _this$opts$shouldSkip, _this$opts;
    if (!this.node) {
      return false;
    }
    if (this.isDenylisted()) {
      return false;
    }
    if ((_this$opts$shouldSkip = (_this$opts = this.opts).shouldSkip) != null && _this$opts$shouldSkip.call(_this$opts, this)) {
      return false;
    }
    const currentContext = this.context;
    if (this.shouldSkip || call.call(this, "enter")) {
      this.debug("Skip...");
      return this.shouldStop;
    }
    restoreContext(this, currentContext);
    this.debug("Recursing into...");
    this.shouldStop = (0, _traverseNode.traverseNode)(this.node, this.opts, this.scope, this.state, this, this.skipKeys);
    restoreContext(this, currentContext);
    call.call(this, "exit");
    return this.shouldStop;
  }
  function skip() {
    this.shouldSkip = true;
  }
  function skipKey(key) {
    if (this.skipKeys == null) {
      this.skipKeys = {};
    }
    this.skipKeys[key] = true;
  }
  function stop() {
    this._traverseFlags |= _index.SHOULD_SKIP | _index.SHOULD_STOP;
  }
  function setScope() {
    var _this$opts2, _this$scope;
    if ((_this$opts2 = this.opts) != null && _this$opts2.noScope) return;
    let path2 = this.parentPath;
    if ((this.key === "key" || this.listKey === "decorators") && path2.isMethod() || this.key === "discriminant" && path2.isSwitchStatement()) {
      path2 = path2.parentPath;
    }
    let target;
    while (path2 && !target) {
      var _path$opts;
      if ((_path$opts = path2.opts) != null && _path$opts.noScope) return;
      target = path2.scope;
      path2 = path2.parentPath;
    }
    this.scope = this.getScope(target);
    (_this$scope = this.scope) == null || _this$scope.init();
  }
  function setContext(context2) {
    if (this.skipKeys != null) {
      this.skipKeys = {};
    }
    this._traverseFlags = 0;
    if (context2) {
      this.context = context2;
      this.state = context2.state;
      this.opts = context2.opts;
    }
    setScope.call(this);
    return this;
  }
  function resync() {
    if (this.removed) return;
    _resyncParent.call(this);
    _resyncList.call(this);
    _resyncKey.call(this);
  }
  function _resyncParent() {
    if (this.parentPath) {
      this.parent = this.parentPath.node;
    }
  }
  function _resyncKey() {
    if (!this.container) return;
    if (this.node === this.container[this.key]) {
      return;
    }
    if (Array.isArray(this.container)) {
      for (let i = 0; i < this.container.length; i++) {
        if (this.container[i] === this.node) {
          setKey.call(this, i);
          return;
        }
      }
    } else {
      for (const key of Object.keys(this.container)) {
        if (this.container[key] === this.node) {
          setKey.call(this, key);
          return;
        }
      }
    }
    this.key = null;
  }
  function _resyncList() {
    if (!this.parent || !this.inList) return;
    const newContainer = this.parent[this.listKey];
    if (this.container === newContainer) return;
    this.container = newContainer || null;
  }
  function _resyncRemoved() {
    if (this.key == null || !this.container || this.container[this.key] !== this.node) {
      _removal._markRemoved.call(this);
    }
  }
  function popContext() {
    this.contexts.pop();
    if (this.contexts.length > 0) {
      this.setContext(this.contexts[this.contexts.length - 1]);
    } else {
      this.setContext(void 0);
    }
  }
  function pushContext(context2) {
    this.contexts.push(context2);
    this.setContext(context2);
  }
  function setup(parentPath, container, listKey, key) {
    this.listKey = listKey;
    this.container = container;
    this.parentPath = parentPath || this.parentPath;
    setKey.call(this, key);
  }
  function setKey(key) {
    var _this$node;
    this.key = key;
    this.node = this.container[this.key];
    this.type = (_this$node = this.node) == null ? void 0 : _this$node.type;
  }
  function requeue(pathToQueue = this) {
    if (pathToQueue.removed) return;
    const contexts = this.contexts;
    for (const context2 of contexts) {
      context2.maybeQueue(pathToQueue);
    }
  }
  function requeueComputedKeyAndDecorators() {
    const {
      context: context2,
      node: node2
    } = this;
    if (!t.isPrivate(node2) && node2.computed) {
      context2.maybeQueue(this.get("key"));
    }
    if (node2.decorators) {
      for (const decorator of this.get("decorators")) {
        context2.maybeQueue(decorator);
      }
    }
  }
  function _getQueueContexts() {
    let path2 = this;
    let contexts = this.contexts;
    while (!contexts.length) {
      path2 = path2.parentPath;
      if (!path2) break;
      contexts = path2.contexts;
    }
    return contexts;
  }
  return context$1;
}
var hub = {};
var hasRequiredHub;
function requireHub() {
  if (hasRequiredHub) return hub;
  hasRequiredHub = 1;
  Object.defineProperty(hub, "__esModule", {
    value: true
  });
  hub.default = void 0;
  class Hub {
    getCode() {
    }
    getScope() {
    }
    addHelper() {
      throw new Error("Helpers are not supported by the default hub.");
    }
    buildError(node2, msg, Error2 = TypeError) {
      return new Error2(msg);
    }
  }
  hub.default = Hub;
  return hub;
}
var hasRequiredLib;
function requireLib() {
  if (hasRequiredLib) return lib$6;
  hasRequiredLib = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", {
      value: true
    });
    Object.defineProperty(exports$1, "Hub", {
      enumerable: true,
      get: function() {
        return _hub.default;
      }
    });
    Object.defineProperty(exports$1, "NodePath", {
      enumerable: true,
      get: function() {
        return _index.default;
      }
    });
    Object.defineProperty(exports$1, "Scope", {
      enumerable: true,
      get: function() {
        return _index2.default;
      }
    });
    exports$1.visitors = exports$1.default = void 0;
    requireContext();
    var visitors2 = requireVisitors();
    exports$1.visitors = visitors2;
    var _t = requireLib$4();
    var cache2 = requireCache();
    var _traverseNode = requireTraverseNode();
    var _index = requirePath();
    var _index2 = requireScope();
    var _hub = requireHub();
    const {
      VISITOR_KEYS,
      removeProperties: removeProperties2,
      traverseFast: traverseFast2
    } = _t;
    function traverse2(parent, opts = {}, scope2, state, parentPath, visitSelf) {
      if (!parent) return;
      if (!opts.noScope && !scope2) {
        if (parent.type !== "Program" && parent.type !== "File") {
          throw new Error(`You must pass a scope and parentPath unless traversing a Program/File. Instead of that you tried to traverse a ${parent.type} node without passing scope and parentPath.`);
        }
      }
      if (!parentPath && visitSelf) {
        throw new Error("visitSelf can only be used when providing a NodePath.");
      }
      if (!VISITOR_KEYS[parent.type]) {
        return;
      }
      visitors2.explode(opts);
      (0, _traverseNode.traverseNode)(parent, opts, scope2, state, parentPath, void 0, visitSelf);
    }
    exports$1.default = traverse2;
    traverse2.visitors = visitors2;
    traverse2.verify = visitors2.verify;
    traverse2.explode = visitors2.explode;
    traverse2.cheap = function(node2, enter) {
      traverseFast2(node2, enter);
      return;
    };
    traverse2.node = function(node2, opts, scope2, state, path2, skipKeys) {
      (0, _traverseNode.traverseNode)(node2, opts, scope2, state, path2, skipKeys);
    };
    traverse2.clearNode = function(node2, opts) {
      removeProperties2(node2, opts);
    };
    traverse2.removeProperties = function(tree, opts) {
      traverseFast2(tree, traverse2.clearNode, opts);
      return tree;
    };
    traverse2.hasType = function(tree, type, denylistTypes) {
      if (denylistTypes != null && denylistTypes.includes(tree.type)) return false;
      if (tree.type === type) return true;
      return traverseFast2(tree, function(node2) {
        if (denylistTypes != null && denylistTypes.includes(node2.type)) {
          return traverseFast2.skip;
        }
        if (node2.type === type) {
          return traverseFast2.stop;
        }
      });
    };
    traverse2.cache = cache2;
  })(lib$6);
  return lib$6;
}
var libExports$1 = requireLib();
const traverse = /* @__PURE__ */ getDefaultExportFromCjs(libExports$1);
var libExports = requireLib$4();
class CodeParser {
  async scanFile(filePath) {
    const code = await fs$1.promises.readFile(filePath, "utf-8");
    const ast = require$$5.parse(code, {
      sourceType: "module",
      plugins: ["typescript", "jsx"],
      tokens: true
    });
    const items = [];
    const traverseFn = traverse.default || traverse;
    traverseFn(ast, {
      StringLiteral: (path2) => {
        const node2 = path2.node;
        const parent = path2.parent;
        let shouldExtract = true;
        if (libExports.isImportDeclaration(parent) || libExports.isExportNamedDeclaration(parent) || libExports.isExportAllDeclaration(parent)) {
          shouldExtract = false;
        }
        if (libExports.isObjectProperty(parent) && parent.key === node2 && !parent.computed) {
          shouldExtract = false;
        }
        if (libExports.isCallExpression(parent)) {
          const callee = parent.callee;
          const args = parent.arguments;
          if (libExports.isMemberExpression(callee) && libExports.isIdentifier(callee.property) && libExports.isIdentifier(callee.object)) {
            const propName = callee.property.name;
            const objName = callee.object.name;
            if (propName === "get" && args[1] === node2) shouldExtract = false;
            if (propName === "get" && objName === "modules" && args[0] === node2) shouldExtract = false;
            if (propName === "localize" || propName === "format") shouldExtract = false;
          }
          if (libExports.isMemberExpression(callee) && libExports.isIdentifier(callee.object) && callee.object.name === "Hooks") {
            if (args[0] === node2) shouldExtract = false;
          }
          if (libExports.isMemberExpression(callee) && libExports.isIdentifier(callee.object) && callee.object.name === "libWrapper") {
            if (args[0] === node2 || args[1] === node2) shouldExtract = false;
          }
        }
        if (libExports.isBinaryExpression(parent)) {
          shouldExtract = false;
        }
        if (shouldExtract && this.isTranslatable(node2.value)) {
          const startLineIndex = node2.loc ? node2.loc.start.line - 1 : 0;
          const contextLine = code.split(/\r?\n/)[startLineIndex]?.trim() || "";
          items.push({
            id: `${node2.start}-${node2.end}`,
            original: node2.value,
            context: contextLine,
            start: node2.start,
            end: node2.end,
            loc: node2.loc
          });
        }
      },
      // Disable scope tracking for performance on large files
      noScope: true
    });
    return {
      filePath,
      items
    };
  }
  isTranslatable(str) {
    const trimmed = str.trim();
    if (trimmed.length < 2) return false;
    if (trimmed.match(/^[@#$!{_]/)) return false;
    if (trimmed.includes("/") && !trimmed.includes(" ")) return false;
    if (trimmed.includes(".") && !trimmed.includes(" ")) return false;
    if (!trimmed.match(/[a-zA-Z\u4e00-\u9fa5]/)) return false;
    if (!trimmed.includes(" ")) {
      if (trimmed.match(/^[a-z][a-zA-Z0-9_.-]*$/)) return false;
      if (trimmed.match(/^[A-Z0-9_]+$/)) return false;
    }
    const strippedHtml = trimmed.replace(/<[^>]+>/g, "").trim();
    if (trimmed.includes("<") && trimmed.includes(">") && strippedHtml.length === 0) {
      return false;
    }
    return true;
  }
  async applyPatch(filePath, translations) {
    const code = await fs$1.promises.readFile(filePath, "utf-8");
    const s = new MagicString(code);
    const result = await this.scanFile(filePath);
    for (const item of result.items) {
      if (translations[item.id]) {
        let translated = translations[item.id];
        const originalRaw = code.slice(item.start, item.end);
        const quote = originalRaw[0];
        if (quote === "'") {
          translated = translated.replace(/'/g, "\\'");
        } else if (quote === '"') {
          translated = translated.replace(/"/g, '\\"');
        }
        s.overwrite(item.start, item.end, `${quote}${translated}${quote}`);
      }
    }
    return s.toString();
  }
}
const codeParser = new CodeParser();
class GlossaryManager {
  constructor() {
    this.glossariesDir = path__namespace.join(electron.app.getPath("userData"), "glossaries");
    this.configPath = path__namespace.join(electron.app.getPath("userData"), "glossary-config.json");
    this.ensureDirectories();
  }
  async ensureDirectories() {
    try {
      await fs__namespace.mkdir(this.glossariesDir, { recursive: true });
    } catch (e) {
      console.error("Failed to create glossaries directory:", e);
    }
  }
  async listGlossaries() {
    try {
      await this.ensureDirectories();
      const files = await fs__namespace.readdir(this.glossariesDir);
      const jsonFiles = files.filter((f) => f.endsWith(".json"));
      const config = await this.loadConfig();
      const activeNames = config.active || [];
      const glossaries = [];
      for (const file of jsonFiles) {
        const entries = await this.loadGlossary(file.replace(".json", ""));
        glossaries.push({
          name: file.replace(".json", ""),
          enabled: activeNames.includes(file.replace(".json", "")),
          entryCount: entries.length
        });
      }
      return glossaries;
    } catch (error) {
      console.error("Failed to list glossaries:", error);
      return [];
    }
  }
  async loadGlossary(name) {
    try {
      const filePath = path__namespace.join(this.glossariesDir, `${name}.json`);
      const content = await fs__namespace.readFile(filePath, "utf-8");
      return JSON.parse(content);
    } catch (error) {
      return [];
    }
  }
  async saveGlossary(name, entries) {
    try {
      await this.ensureDirectories();
      const filePath = path__namespace.join(this.glossariesDir, `${name}.json`);
      await fs__namespace.writeFile(filePath, JSON.stringify(entries, null, 2), "utf-8");
      return true;
    } catch (error) {
      console.error("Failed to save glossary:", error);
      return false;
    }
  }
  async createGlossary(name) {
    try {
      await this.ensureDirectories();
      const filePath = path__namespace.join(this.glossariesDir, `${name}.json`);
      await fs__namespace.writeFile(filePath, JSON.stringify([], null, 2), "utf-8");
      return true;
    } catch (error) {
      console.error("Failed to create glossary:", error);
      return false;
    }
  }
  async deleteGlossary(name) {
    try {
      const filePath = path__namespace.join(this.glossariesDir, `${name}.json`);
      await fs__namespace.unlink(filePath);
      const config = await this.loadConfig();
      config.active = (config.active || []).filter((n) => n !== name);
      await this.saveConfig(config);
      return true;
    } catch (error) {
      console.error("Failed to delete glossary:", error);
      return false;
    }
  }
  async getActiveGlossaries() {
    const config = await this.loadConfig();
    return config.active || [];
  }
  async setActiveGlossaries(names) {
    try {
      const config = await this.loadConfig();
      config.active = names;
      await this.saveConfig(config);
      return true;
    } catch (error) {
      console.error("Failed to set active glossaries:", error);
      return false;
    }
  }
  async loadMergedGlossary() {
    const activeNames = await this.getActiveGlossaries();
    const merged = [];
    const seen = /* @__PURE__ */ new Set();
    for (const name of activeNames) {
      const entries = await this.loadGlossary(name);
      for (const entry of entries) {
        if (!seen.has(entry.term)) {
          merged.push(entry);
          seen.add(entry.term);
        }
      }
    }
    return merged;
  }
  async loadConfig() {
    try {
      const content = await fs__namespace.readFile(this.configPath, "utf-8");
      return JSON.parse(content);
    } catch (error) {
      return { active: [] };
    }
  }
  async saveConfig(config) {
    await fs__namespace.writeFile(this.configPath, JSON.stringify(config, null, 2), "utf-8");
  }
}
const glossaryManager = new GlossaryManager();
const DEFAULT_PROMPT = ` Foundry VTT  Pathfinder 1e 
 JavaScript 

1.  Pathfinder 1e AC
2. HTML Handlebars {{...}}
3.  "ui.notifications"
4. `;
class AIService {
  async translate(text, config, projectPath = null) {
    if (!config.apiKey) throw new Error("API Key is missing");
    let glossaryContext = "";
    try {
      const glossary = await glossaryManager.loadMergedGlossary();
      if (glossary.length > 0) {
        glossaryContext = "\n\n\n";
        glossary.forEach((entry) => {
          glossaryContext += `- "${entry.term}"  "${entry.definition}"`;
          if (entry.context) glossaryContext += ` (${entry.context})`;
          glossaryContext += "\n";
        });
      }
    } catch (e) {
      console.warn("Failed to load glossary:", e);
    }
    const enhancedPrompt = (config.prompt || DEFAULT_PROMPT) + glossaryContext;
    if (config.provider === "openai" || config.provider === "deepseek") {
      return this.translateOpenAI(text, config, enhancedPrompt);
    } else if (config.provider === "gemini") {
      return this.translateGemini(text, config, enhancedPrompt);
    }
    throw new Error("Unknown provider");
  }
  async translateOpenAI(text, config, prompt) {
    const baseURL = config.provider === "deepseek" ? "https://api.deepseek.com/v1" : "https://api.openai.com/v1";
    const response = await fetch(`${baseURL}/chat/completions`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${config.apiKey}`
      },
      body: JSON.stringify({
        model: config.model,
        messages: [
          { role: "system", content: prompt },
          { role: "user", content: text }
        ]
      })
    });
    if (!response.ok) {
      throw new Error(`AI Request failed: ${response.statusText}`);
    }
    const data = await response.json();
    return data.choices[0].message.content.trim();
  }
  async translateGemini(text, config, prompt) {
    const url = `https://generativelanguage.googleapis.com/v1beta/models/${config.model}:generateContent?key=${config.apiKey}`;
    const response = await fetch(url, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        contents: [{
          parts: [{
            text: `${prompt}:

${text}`
          }]
        }]
      })
    });
    if (!response.ok) {
      throw new Error(`Gemini Request failed: ${response.statusText}`);
    }
    const data = await response.json();
    return data.candidates[0].content.parts[0].text.trim();
  }
}
const aiService = new AIService();
class ModuleExporter {
  async exportModule(projectPath, metadata, files, stagedFiles) {
    try {
      const { canceled, filePaths } = await electron.dialog.showOpenDialog({
        title: "Select Output Directory for New Module",
        properties: ["openDirectory", "createDirectory"]
      });
      if (canceled || filePaths.length === 0) {
        return { success: false, error: "Cancelled" };
      }
      const outputParentDir = filePaths[0];
      const moduleDir = path__namespace.join(outputParentDir, metadata.id);
      const moduleJsonPath = path__namespace.join(moduleDir, "module.json");
      const existingModuleData = {};
      try {
        const existingContent = await fs__namespace.readFile(moduleJsonPath, "utf-8");
        Object.assign(existingModuleData, JSON.parse(existingContent));
      } catch {
      }
      const babeleDirName = metadata.babeleMappingDir || "translations";
      const registerScriptName = "babele.js";
      await fs__namespace.mkdir(moduleDir, { recursive: true });
      await fs__namespace.mkdir(path__namespace.join(moduleDir, "lang"), { recursive: true });
      await fs__namespace.mkdir(path__namespace.join(moduleDir, "scripts"), { recursive: true });
      await fs__namespace.mkdir(path__namespace.join(moduleDir, babeleDirName), { recursive: true });
      const languages = [];
      const esmodules = [];
      let isBabeleModule = false;
      const itemsToProcess = [];
      if (stagedFiles && stagedFiles.length > 0) {
        stagedFiles.forEach((f) => {
          itemsToProcess.push({
            source: f.sourcePath,
            target: f.targetPath,
            type: f.type,
            label: f.label
          });
        });
      } else {
        files.forEach((f) => {
          const source = path__namespace.isAbsolute(f) ? f : path__namespace.join(projectPath, f);
          itemsToProcess.push({ source, target: "", type: "auto" });
        });
      }
      for (const file of itemsToProcess) {
        let { source, target, type } = file;
        const outputFormat = file.outputFormat || "translated";
        let content = "";
        try {
          content = await fs__namespace.readFile(source, "utf-8");
        } catch (e) {
          continue;
        }
        if (!target || type === "auto") {
          const fileName = path__namespace.basename(source);
          if (source.endsWith(".json")) {
            let isBabeleFile = false;
            try {
              const json = JSON.parse(content);
              if (json.label && (json.entries || json.mapping)) isBabeleFile = true;
            } catch {
            }
            if (isBabeleFile) {
              target = `${babeleDirName}/${fileName}`;
              type = "babele";
            } else {
              target = `lang/${fileName}`;
              type = "lang";
            }
          } else if (source.endsWith(".js")) {
            target = `scripts/${fileName}`;
            type = "script";
          }
        }
        const safeTarget = target.replace(/\\/g, "/").replace(/^\//, "");
        const targetAbsolute = path__namespace.join(moduleDir, safeTarget);
        await fs__namespace.mkdir(path__namespace.dirname(targetAbsolute), { recursive: true });
        if (source.endsWith(".json") && outputFormat === "bilingual") {
          const originalPath = source + ".original";
          try {
            const originalContent = await fs__namespace.readFile(originalPath, "utf-8");
            const translatedData = JSON.parse(content);
            const originalData = JSON.parse(originalContent);
            const bilingualData = this.generateBilingual(translatedData, originalData);
            await fs__namespace.writeFile(targetAbsolute, JSON.stringify(bilingualData, null, 2), "utf-8");
          } catch (e) {
            console.warn("No original backup found for bilingual, copying as-is:", source);
            await fs__namespace.copyFile(source, targetAbsolute);
          }
        } else {
          await fs__namespace.copyFile(source, targetAbsolute);
        }
        if (type === "lang" || safeTarget.startsWith("lang/")) {
          const fileName = path__namespace.basename(safeTarget);
          let langCode = "cn";
          let langName = file.label || `-${fileName.replace(".json", "")}`;
          const lowerName = fileName.toLowerCase();
          if (lowerName.includes("en")) {
            langCode = "en";
            langName = "English";
          } else if (lowerName.includes("zh-tw")) {
            langCode = "zh-tw";
            langName = "Chinese (Traditional)";
          }
          languages.push({
            lang: langCode,
            name: langName,
            path: safeTarget
          });
        } else if (type === "script" || safeTarget.startsWith("scripts/")) {
          if (!esmodules.includes(safeTarget)) {
            esmodules.push(safeTarget);
          }
        } else if (type === "babele" || safeTarget.startsWith(babeleDirName) || safeTarget.startsWith("translations") || safeTarget.startsWith("compendium")) {
          isBabeleModule = true;
        }
      }
      const moduleData = {
        id: metadata.id,
        title: metadata.title,
        description: metadata.description || `Translation for ${metadata.title}`,
        version: metadata.version || "1.0.0",
        authors: metadata.authors || [],
        compatibility: metadata.compatibility || { minimum: "10", verified: "11", maximum: "12" },
        relationships: metadata.relationships || { systems: [], requires: [] },
        esmodules: existingModuleData.esmodules || [],
        // Keep existing if any, we merge ours later
        languages: existingModuleData.languages || [],
        systems: existingModuleData.systems || [],
        url: metadata.url || existingModuleData.url,
        manifest: metadata.manifest || existingModuleData.manifest,
        download: metadata.download || existingModuleData.download,
        // Additional properties
        styles: existingModuleData.styles || [],
        packs: existingModuleData.packs || [],
        license: metadata.license || existingModuleData.license,
        readme: metadata.readme || existingModuleData.readme
      };
      if (metadata.relationships?.systems) {
        moduleData.systems = metadata.relationships.systems.map((s) => s.id);
        moduleData.relationships.systems = metadata.relationships.systems;
      }
      languages.forEach((l) => {
        if (!moduleData.languages.some((el) => el.path === l.path)) {
          moduleData.languages.push(l);
        }
      });
      esmodules.forEach((m) => {
        if (!moduleData.esmodules.includes(m)) {
          moduleData.esmodules.push(m);
        }
      });
      if (isBabeleModule) {
        let targetId = "TARGET_ID";
        if (moduleData.relationships.systems && moduleData.relationships.systems.length > 0) {
          targetId = moduleData.relationships.systems[0].id;
        } else if (metadata.id.includes("pf1")) {
          targetId = "pf1";
        } else if (metadata.id.endsWith("-zh")) {
          targetId = metadata.id.replace(/-zh$/, "");
        }
        const registerScriptPath = `scripts/${registerScriptName}`;
        const absoluteScriptPath = path__namespace.join(moduleDir, registerScriptPath);
        let primaryLang = languages.length > 0 ? languages[0].lang : "cn";
        if (primaryLang === "zh-cn") primaryLang = "cn";
        const babeleScriptContent = `Hooks.once('babele.init', (babele) => {
    // Auto-register Babele
    babele.register({
        module: '${moduleData.id}',
        lang: '${primaryLang}',
        dir: '${babeleDirName}',
        // If your files are not named exactly like the compendium packs (e.g. "pf1.spells.json"),
        // you must use the 'files' array to map them manually:
        /*
        files: [
            { path: "companions.json", id: "pf1.pf-companions" },
            { path: "spells.json", id: "pf1.spells" }
        ]
        */
    });
});
`;
        await fs__namespace.writeFile(absoluteScriptPath, babeleScriptContent.trim());
        if (!moduleData.esmodules.includes(registerScriptPath)) {
          moduleData.esmodules.push(registerScriptPath);
        }
        moduleData.relationships.requires = moduleData.relationships.requires || [];
        if (!moduleData.relationships.requires.some((r) => r.id === "babele")) {
          moduleData.relationships.requires.push({
            id: "babele",
            type: "module",
            manifest: "https://gitlab.com/riccisi/foundryvtt-babele/raw/master/module/module.json"
          });
        }
      }
      const finalModuleData = {
        id: moduleData.id,
        title: moduleData.title,
        description: moduleData.description,
        version: moduleData.version,
        authors: moduleData.authors,
        compatibility: moduleData.compatibility,
        relationships: {
          systems: moduleData.relationships.systems || [],
          requires: moduleData.relationships.requires || []
        },
        // Flatten styles/esmodules/languages to top level
        esmodules: moduleData.esmodules,
        styles: moduleData.styles || [],
        languages: moduleData.languages,
        packs: moduleData.packs || [],
        url: moduleData.url,
        manifest: moduleData.manifest,
        download: moduleData.download,
        license: moduleData.license,
        readme: moduleData.readme
      };
      Object.keys(finalModuleData).forEach((key) => finalModuleData[key] === void 0 && delete finalModuleData[key]);
      await fs__namespace.writeFile(moduleJsonPath, JSON.stringify(finalModuleData, null, 2), "utf-8");
      return { success: true, path: moduleDir };
    } catch (error) {
      console.error("Export failed:", error);
      return { success: false, error: error.message };
    }
  }
  async getModuleInfo(projectPath) {
    try {
      const moduleJsonPath = path__namespace.join(projectPath, "module.json");
      const content = await fs__namespace.readFile(moduleJsonPath, "utf-8");
      const data = JSON.parse(content);
      let authors = data.authors || [];
      if (typeof data.author === "string") {
        authors = [{ name: data.author }];
      }
      return {
        id: data.id ? `${data.id}-zh` : "",
        title: data.title ? `${data.title} (Chinese)` : "",
        description: data.description || "",
        version: data.version || "1.0.0",
        authors,
        compatibility: data.compatibility,
        relationships: data.relationships,
        url: data.url,
        manifest: data.manifest,
        download: data.download
      };
    } catch (e) {
      return {};
    }
  }
  /**
   * 
   * @param translatedData  JSON 
   * @param originalData  JSON 
   * @param threshold 
   * @returns  JSON 
   */
  generateBilingual(translatedData, originalData, threshold = 50) {
    const merge = (translated, original) => {
      if (typeof translated === "string" && typeof original === "string") {
        if (original.length < threshold && translated !== original) {
          return `${translated} ${original}`;
        }
        return translated;
      }
      if (Array.isArray(translated) && Array.isArray(original)) {
        return translated.map((item, i) => merge(item, original[i] ?? item));
      }
      if (typeof translated === "object" && typeof original === "object" && translated !== null) {
        const result = {};
        for (const key of Object.keys(translated)) {
          result[key] = merge(translated[key], original?.[key] ?? translated[key]);
        }
        return result;
      }
      return translated;
    };
    return merge(translatedData, originalData);
  }
}
const moduleExporter = new ModuleExporter();
class GlossaryImporter {
  async importFromJsonFile(filePath) {
    try {
      const content = await fs__namespace.readFile(filePath, "utf-8");
      const data = JSON.parse(content);
      const entries = [];
      const seen = /* @__PURE__ */ new Set();
      const skipKeys = ["description", "desc", "description-full", "hint", "help", "tooltip", "notes"];
      const genericKeys = ["label", "name", "title", "value", "text"];
      const extract = (obj, prefix = "") => {
        for (const key in obj) {
          if (skipKeys.includes(key.toLowerCase())) {
            continue;
          }
          const fullKey = prefix ? `${prefix}.${key}` : key;
          if (typeof obj[key] === "object" && obj[key] !== null && !Array.isArray(obj[key])) {
            extract(obj[key], fullKey);
          } else if (typeof obj[key] === "string" && obj[key].trim()) {
            const definition = obj[key].trim();
            if (definition.length > 100) {
              continue;
            }
            const keyParts = fullKey.split(".");
            let term = key;
            if (keyParts.length > 1 && genericKeys.includes(key.toLowerCase())) {
              term = keyParts[keyParts.length - 2];
            }
            const uniqueKey = `${term}:${definition}`;
            if (!seen.has(uniqueKey)) {
              entries.push({
                term,
                definition,
                context: fullKey
                // Full path goes to context
              });
              seen.add(uniqueKey);
            }
          }
        }
      };
      extract(data);
      return entries;
    } catch (error) {
      console.error("Failed to import from JSON:", error);
      throw error;
    }
  }
}
const glossaryImporter = new GlossaryImporter();
class BlacklistManager {
  constructor() {
    this.blacklist = /* @__PURE__ */ new Set();
    this.configPath = path__namespace.join(electron.app.getPath("userData"), "blacklist.json");
    this.load();
  }
  async load() {
    try {
      const content = await fs__namespace.readFile(this.configPath, "utf-8");
      const list = JSON.parse(content);
      this.blacklist = new Set(list);
    } catch (e) {
      this.blacklist = /* @__PURE__ */ new Set();
    }
  }
  async save() {
    try {
      const list = Array.from(this.blacklist);
      await fs__namespace.writeFile(this.configPath, JSON.stringify(list, null, 2), "utf-8");
    } catch (e) {
      console.error("Failed to save blacklist:", e);
    }
  }
  async getList() {
    await this.load();
    return Array.from(this.blacklist).sort();
  }
  async add(key) {
    if (!key) return false;
    this.blacklist.add(key);
    await this.save();
    return true;
  }
  async remove(key) {
    if (this.blacklist.delete(key)) {
      await this.save();
      return true;
    }
    return false;
  }
  async has(key) {
    return this.blacklist.has(key);
  }
  // Check if a key matches any blacklist pattern
  // Supports exact match for now. Could extend to glob/regex if needed.
  // User specifically asked for "system.description.value", which suggests exact key matching for JSON.
  isBlacklisted(key) {
    return this.blacklist.has(key);
  }
}
const blacklistManager = new BlacklistManager();
function createWindow() {
  const mainWindow = new electron.BrowserWindow({
    width: 1280,
    height: 800,
    minWidth: 900,
    minHeight: 670,
    show: false,
    autoHideMenuBar: true,
    ...process.platform === "linux" ? { icon: path$1.join(__dirname, "../../build/icon.png") } : {},
    webPreferences: {
      preload: path$1.join(__dirname, "../preload/index.js"),
      sandbox: false,
      nodeIntegration: true
      // Important for direct file access if needed, though contextBridge is safer
    }
  });
  mainWindow.on("ready-to-show", () => {
    mainWindow.show();
  });
  mainWindow.webContents.setWindowOpenHandler((details) => {
    electron.shell.openExternal(details.url);
    return { action: "deny" };
  });
  if (utils$1.is.dev && process.env["ELECTRON_RENDERER_URL"]) {
    mainWindow.loadURL(process.env["ELECTRON_RENDERER_URL"]);
  } else {
    mainWindow.loadFile(path$1.join(__dirname, "../renderer/index.html"));
  }
  electron.ipcMain.handle("window:resize", (_, width, height) => {
    mainWindow.setSize(width, height);
    mainWindow.center();
  });
  electron.ipcMain.handle("window:getSize", () => {
    const [width, height] = mainWindow.getSize();
    return { width, height };
  });
}
electron.app.whenReady().then(() => {
  utils$1.electronApp.setAppUserModelId("com.electron");
  electron.app.on("browser-window-created", (_, window2) => {
    utils$1.optimizer.watchWindowShortcuts(window2);
  });
  electron.ipcMain.handle("fs:selectDirectory", () => fileSystem.selectDirectory());
  electron.ipcMain.handle("fs:selectFile", (_, e) => fileSystem.selectFile(e));
  electron.ipcMain.handle("fs:readJson", (_, p) => fileSystem.readJson(p));
  electron.ipcMain.handle("fs:writeJson", (_, p, d) => fileSystem.writeJson(p, d));
  electron.ipcMain.handle("fs:readFile", (_, p) => fileSystem.readFile(p));
  electron.ipcMain.handle("fs:writeFile", (_, p, c) => fileSystem.writeFile(p, c));
  electron.ipcMain.handle("fs:getFiles", (_, p, e) => fileSystem.getFiles(p, e));
  electron.ipcMain.handle("fs:showSaveDialog", (_, p) => fileSystem.showSaveDialog(p));
  electron.ipcMain.handle("fs:extractZip", (_, p) => fileSystem.extractZip(p));
  electron.ipcMain.handle("fs:calculateProgress", (_, p) => fileSystem.calculateProgress(p));
  electron.ipcMain.handle("fs:deleteFile", (_, p) => fileSystem.deleteFile(p));
  electron.ipcMain.handle("fs:fileExists", (_, p) => fileSystem.fileExists(p));
  electron.ipcMain.handle("parser:scanFile", (_, p) => codeParser.scanFile(p));
  electron.ipcMain.handle("parser:applyPatch", (_, p, t) => codeParser.applyPatch(p, t));
  electron.ipcMain.handle("ai:translate", (_, text, config, projectPath) => aiService.translate(text, config, projectPath));
  electron.ipcMain.handle("export:exportModule", (_, p, m, f, s) => moduleExporter.exportModule(p, m, f, s));
  electron.ipcMain.handle("export:getModuleInfo", (_, p) => moduleExporter.getModuleInfo(p));
  electron.ipcMain.handle("glossary:list", () => glossaryManager.listGlossaries());
  electron.ipcMain.handle("glossary:load", (_, name) => glossaryManager.loadGlossary(name));
  electron.ipcMain.handle("glossary:save", (_, name, entries) => glossaryManager.saveGlossary(name, entries));
  electron.ipcMain.handle("glossary:create", (_, name) => glossaryManager.createGlossary(name));
  electron.ipcMain.handle("glossary:delete", (_, name) => glossaryManager.deleteGlossary(name));
  electron.ipcMain.handle("glossary:getActive", () => glossaryManager.getActiveGlossaries());
  electron.ipcMain.handle("glossary:setActive", (_, names) => glossaryManager.setActiveGlossaries(names));
  electron.ipcMain.handle("glossary:import", (_, filePath) => glossaryImporter.importFromJsonFile(filePath));
  electron.ipcMain.handle("blacklist:get", () => blacklistManager.getList());
  electron.ipcMain.handle("blacklist:add", (_, key) => blacklistManager.add(key));
  electron.ipcMain.handle("blacklist:remove", (_, key) => blacklistManager.remove(key));
  electron.ipcMain.handle(
    "export:generateBilingual",
    (_, translatedData, originalData, threshold) => moduleExporter.generateBilingual(translatedData, originalData, threshold)
  );
  createWindow();
  electron.app.on("activate", function() {
    if (electron.BrowserWindow.getAllWindows().length === 0) createWindow();
  });
});
electron.app.on("window-all-closed", () => {
  if (process.platform !== "darwin") {
    electron.app.quit();
  }
});
